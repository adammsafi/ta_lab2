---
phase: 07-ta_lab2-feature-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ta_lab2/scripts/features/__init__.py
  - src/ta_lab2/scripts/features/feature_state_manager.py
  - sql/lookups/020_dim_features.sql
  - src/ta_lab2/scripts/setup/ensure_dim_features.py
  - tests/features/test_feature_state_manager.py
autonomous: true

must_haves:
  truths:
    - "FeatureStateManager can track state for multiple feature types (returns, vol, ta)"
    - "dim_features table defines feature metadata and null handling strategies"
    - "State tracking extends EMA pattern with feature_type dimension"
  artifacts:
    - path: "src/ta_lab2/scripts/features/feature_state_manager.py"
      provides: "State manager for feature pipelines"
      exports: ["FeatureStateManager", "FeatureStateConfig"]
    - path: "sql/lookups/020_dim_features.sql"
      provides: "Feature metadata table DDL"
      contains: "CREATE TABLE"
    - path: "src/ta_lab2/scripts/setup/ensure_dim_features.py"
      provides: "Conditional dim_features setup"
      exports: ["ensure_dim_features"]
    - path: "tests/features/test_feature_state_manager.py"
      provides: "Unit tests for state manager"
      min_lines: 150
  key_links:
    - from: "feature_state_manager.py"
      to: "EMAStateManager pattern"
      via: "dataclass config, load_state, update_state_from_output"
      pattern: "class FeatureStateManager"
    - from: "ensure_dim_features.py"
      to: "020_dim_features.sql"
      via: "execute_sql_file()"
      pattern: "execute_sql_file.*020_dim_features"
---

<objective>
Create the feature pipeline infrastructure: FeatureStateManager (extending EMA pattern) and dim_features metadata table.

Purpose: Provides foundation for incremental refresh of returns, volatility, and TA features with configurable null handling per feature type.
Output: State manager class, dim_features DDL, setup script, and unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-CONTEXT.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-RESEARCH.md

# Key existing patterns to follow:
@src/ta_lab2/scripts/emas/ema_state_manager.py
@src/ta_lab2/scripts/setup/ensure_dim_tables.py
@sql/lookups/010_dim_timeframe_create.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dim_features DDL and setup script</name>
  <files>
    sql/lookups/020_dim_features.sql
    src/ta_lab2/scripts/setup/ensure_dim_features.py
    src/ta_lab2/scripts/setup/__init__.py (update if needed)
  </files>
  <action>
    Create dim_features table to store feature metadata and null handling configuration.

    **020_dim_features.sql schema:**
    ```sql
    CREATE TABLE IF NOT EXISTS public.dim_features (
        feature_type        TEXT PRIMARY KEY,      -- 'returns', 'vol', 'ta'
        feature_name        TEXT NOT NULL,         -- 'b2t_pct', 'parkinson_20', 'rsi_14'
        null_strategy       TEXT NOT NULL,         -- 'skip', 'forward_fill', 'interpolate'
        min_data_points     INTEGER DEFAULT 1,     -- Minimum required for calculation
        is_normalized       BOOLEAN DEFAULT FALSE, -- Has z-score column
        description         TEXT,
        created_at          TIMESTAMPTZ DEFAULT now(),
        updated_at          TIMESTAMPTZ DEFAULT now()
    );
    ```

    **Insert default feature configurations:**
    - returns: null_strategy='skip' (skip NULLs, don't interpolate price gaps)
    - vol_parkinson: null_strategy='forward_fill' (carry forward last good value)
    - vol_gk: null_strategy='forward_fill'
    - ta_rsi: null_strategy='interpolate' (linear interpolation for smooth indicators)
    - ta_macd: null_strategy='interpolate'

    **ensure_dim_features.py:**
    - Follow ensure_dim_tables.py pattern exactly
    - table_exists() check using information_schema
    - execute_sql_file() to run DDL
    - Idempotent (CREATE TABLE IF NOT EXISTS)
    - CLI with --dry-run support
  </action>
  <verify>
    python -c "from ta_lab2.scripts.setup.ensure_dim_features import ensure_dim_features; print('import OK')"
    Test --dry-run mode shows what would be created
  </verify>
  <done>
    dim_features DDL exists, setup script imports successfully, --dry-run shows expected operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FeatureStateManager</name>
  <files>
    src/ta_lab2/scripts/features/__init__.py
    src/ta_lab2/scripts/features/feature_state_manager.py
  </files>
  <action>
    Create FeatureStateManager extending EMAStateManager pattern with feature_type dimension.

    **FeatureStateConfig dataclass:**
    ```python
    @dataclass(frozen=True)
    class FeatureStateConfig:
        state_schema: str = "public"
        state_table: str = "cmc_feature_state"
        feature_type: str = "returns"  # NEW: 'returns', 'vol', 'ta'
        ts_column: str = "ts"
        id_column: str = "id"
    ```

    **State table schema (unified for all features):**
    - PRIMARY KEY: (id, feature_type, feature_name)
    - id: INTEGER
    - feature_type: TEXT ('returns', 'vol', 'ta')
    - feature_name: TEXT ('b2t_pct', 'parkinson_20', 'rsi_14')
    - daily_min_seen: TIMESTAMPTZ
    - daily_max_seen: TIMESTAMPTZ
    - last_ts: TIMESTAMPTZ
    - row_count: INTEGER
    - updated_at: TIMESTAMPTZ

    **FeatureStateManager methods:**
    - ensure_state_table(): Create if not exists
    - load_state(ids, feature_type, feature_names): Load with filters
    - update_state_from_output(output_table, output_schema): Upsert from output
    - compute_dirty_window_starts(ids, feature_type): Dict[id, Timestamp]
    - get_null_strategy(feature_name): Query dim_features for null handling

    Follow EMAStateManager implementation exactly for SQL patterns.
  </action>
  <verify>
    python -c "from ta_lab2.scripts.features.feature_state_manager import FeatureStateManager, FeatureStateConfig; print('import OK')"
  </verify>
  <done>
    FeatureStateManager imports successfully with all methods defined
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for FeatureStateManager</name>
  <files>
    tests/features/__init__.py
    tests/features/test_feature_state_manager.py
  </files>
  <action>
    Create comprehensive unit tests following test_ema_state_manager.py pattern.

    **Test structure:**
    1. Test FeatureStateConfig defaults and custom values
    2. Test ensure_state_table() creates table (mock database)
    3. Test load_state() with various filters (ids, feature_type, feature_names)
    4. Test load_state() returns empty DataFrame when table doesn't exist
    5. Test update_state_from_output() upsert logic
    6. Test compute_dirty_window_starts() returns correct timestamps
    7. Test get_null_strategy() returns correct strategy from dim_features
    8. Test get_null_strategy() returns default when feature not found

    **Use unittest.mock for database-free testing:**
    - Mock engine.begin(), engine.connect()
    - Mock pd.read_sql() return values
    - Mock conn.execute() for SQL verification

    **Mark integration tests with pytest.mark.skipif(not TARGET_DB_URL)**
  </action>
  <verify>
    pytest tests/features/test_feature_state_manager.py -v
    All tests pass (expect 8-10 tests)
  </verify>
  <done>
    All unit tests pass, no database required for unit tests
  </done>
</task>

</tasks>

<verification>
- [ ] dim_features DDL creates table with correct schema
- [ ] ensure_dim_features.py follows ensure_dim_tables.py pattern exactly
- [ ] FeatureStateManager extends EMA pattern with feature_type dimension
- [ ] All unit tests pass without database connection
- [ ] Imports work: FeatureStateManager, FeatureStateConfig, ensure_dim_features
</verification>

<success_criteria>
- FeatureStateManager class fully implemented with all methods
- dim_features table DDL exists with null handling strategies
- Setup script is idempotent and follows existing patterns
- 8+ unit tests pass covering all state manager methods
- No hardcoded feature configurations - all from dim_features metadata
</success_criteria>

<output>
After completion, create `.planning/phases/07-ta_lab2-feature-pipeline/07-01-SUMMARY.md`
</output>
