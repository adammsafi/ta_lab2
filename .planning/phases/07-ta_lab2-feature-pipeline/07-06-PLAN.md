---
phase: 07-ta_lab2-feature-pipeline
plan: 06
type: execute
wave: 3
depends_on: [07-03, 07-04, 07-05]
files_modified:
  - src/ta_lab2/scripts/features/daily_features_view.py
  - sql/views/050_cmc_daily_features.sql
  - src/ta_lab2/scripts/features/refresh_cmc_daily_features.py
  - tests/features/test_daily_features_view.py
autonomous: true

must_haves:
  truths:
    - "cmc_daily_features unifies prices, EMAs, returns, vol, and TA in one view"
    - "Unified view supports incremental refresh via feature store pattern"
    - "All feature columns accessible via single SELECT for ML pipelines"
  artifacts:
    - path: "sql/views/050_cmc_daily_features.sql"
      provides: "Unified feature view DDL"
      contains: "CREATE TABLE"
    - path: "src/ta_lab2/scripts/features/daily_features_view.py"
      provides: "Feature store refresh logic"
      exports: ["DailyFeaturesStore", "refresh_daily_features"]
    - path: "src/ta_lab2/scripts/features/refresh_cmc_daily_features.py"
      provides: "CLI refresh script"
      contains: "if __name__"
    - path: "tests/features/test_daily_features_view.py"
      provides: "Tests for unified view"
      min_lines: 150
  key_links:
    - from: "050_cmc_daily_features.sql"
      to: "cmc_price_bars_1d"
      via: "JOIN on (id, ts)"
      pattern: "JOIN.*cmc_price_bars_1d"
    - from: "050_cmc_daily_features.sql"
      to: "cmc_returns_daily"
      via: "LEFT JOIN on (id, ts)"
      pattern: "JOIN.*cmc_returns_daily"
    - from: "050_cmc_daily_features.sql"
      to: "cmc_vol_daily"
      via: "LEFT JOIN on (id, ts)"
      pattern: "JOIN.*cmc_vol_daily"
    - from: "050_cmc_daily_features.sql"
      to: "cmc_ta_daily"
      via: "LEFT JOIN on (id, ts)"
      pattern: "JOIN.*cmc_ta_daily"
    - from: "050_cmc_daily_features.sql"
      to: "cmc_ema_multi_tf_u"
      via: "LEFT JOIN on (id, ts, tf)"
      pattern: "JOIN.*cmc_ema_multi_tf"
---

<objective>
Create cmc_daily_features unified feature store table joining all feature tables.

Purpose: Provides single-table access to all daily features (prices, EMAs, returns, vol, TA) for ML pipelines and signal generation.
Output: Feature store table DDL, refresh script, and tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-CONTEXT.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-03-SUMMARY.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-04-SUMMARY.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-05-SUMMARY.md

# Key existing tables to join:
# cmc_price_bars_1d, cmc_ema_multi_tf_u, cmc_returns_daily, cmc_vol_daily, cmc_ta_daily
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cmc_daily_features table DDL</name>
  <files>
    sql/views/050_cmc_daily_features.sql
  </files>
  <action>
    Create unified feature store table (materialized, not view) with explicit state tracking.

    **Design decisions (per CONTEXT.md):**
    - Implement as **table with incremental refresh** (not view - too slow for ML)
    - Track refresh state via FeatureStateManager (feature_type='daily_features')
    - Include asset_class from dim_sessions for filtering

    **DDL:**
    ```sql
    -- Unified daily feature store (materialized from source tables)
    CREATE TABLE IF NOT EXISTS public.cmc_daily_features (
        -- Primary key
        id              INTEGER NOT NULL,
        ts              TIMESTAMPTZ NOT NULL,

        -- Asset metadata (from join with dim tables)
        asset_class     TEXT,              -- 'crypto', 'equity' from dim_sessions

        -- Price context (from cmc_price_bars_1d)
        open            DOUBLE PRECISION,
        high            DOUBLE PRECISION,
        low             DOUBLE PRECISION,
        close           DOUBLE PRECISION,
        volume          DOUBLE PRECISION,

        -- EMAs (from cmc_ema_multi_tf_u, pivoted for 1D timeframe)
        ema_9           DOUBLE PRECISION,
        ema_10          DOUBLE PRECISION,
        ema_21          DOUBLE PRECISION,
        ema_50          DOUBLE PRECISION,
        ema_200         DOUBLE PRECISION,
        ema_9_d1        DOUBLE PRECISION,  -- First derivative
        ema_21_d1       DOUBLE PRECISION,

        -- Returns (from cmc_returns_daily)
        ret_1d_pct      DOUBLE PRECISION,
        ret_1d_log      DOUBLE PRECISION,
        ret_7d_pct      DOUBLE PRECISION,
        ret_30d_pct     DOUBLE PRECISION,
        ret_1d_pct_zscore DOUBLE PRECISION,
        gap_days        INTEGER,

        -- Volatility (from cmc_vol_daily)
        vol_parkinson_20    DOUBLE PRECISION,
        vol_gk_20           DOUBLE PRECISION,
        vol_parkinson_20_zscore DOUBLE PRECISION,
        atr_14              DOUBLE PRECISION,

        -- Technical indicators (from cmc_ta_daily)
        rsi_14          DOUBLE PRECISION,
        rsi_21          DOUBLE PRECISION,
        macd_12_26      DOUBLE PRECISION,
        macd_signal_9   DOUBLE PRECISION,
        macd_hist_12_26_9 DOUBLE PRECISION,
        stoch_k_14      DOUBLE PRECISION,
        stoch_d_3       DOUBLE PRECISION,
        bb_ma_20        DOUBLE PRECISION,
        bb_width_20     DOUBLE PRECISION,
        adx_14          DOUBLE PRECISION,

        -- Data quality flags (union of source flags)
        has_price_gap   BOOLEAN DEFAULT FALSE,
        has_outlier     BOOLEAN DEFAULT FALSE,

        -- Refresh metadata
        updated_at      TIMESTAMPTZ DEFAULT now(),

        PRIMARY KEY (id, ts)
    );

    -- Indexes for common query patterns
    CREATE INDEX IF NOT EXISTS idx_cmc_daily_features_id_ts
    ON public.cmc_daily_features (id, ts DESC);

    CREATE INDEX IF NOT EXISTS idx_cmc_daily_features_asset_class
    ON public.cmc_daily_features (asset_class, ts DESC);

    COMMENT ON TABLE public.cmc_daily_features IS
    'Unified daily feature store for ML pipelines. Materialized from prices, EMAs, returns, vol, TA.';
    ```
  </action>
  <verify>
    File exists with CREATE TABLE and all feature columns
  </verify>
  <done>
    DDL creates unified table with all feature columns
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DailyFeaturesStore class</name>
  <files>
    src/ta_lab2/scripts/features/daily_features_view.py
  </files>
  <action>
    Create feature store refresh logic with dependency tracking.

    **DailyFeaturesStore:**
    ```python
    class DailyFeaturesStore:
        """
        Manages cmc_daily_features materialized table.

        Refresh pattern:
        1. Identify dirty window (MIN of all source table watermarks)
        2. Delete rows in dirty window
        3. Re-materialize from source tables with JOIN query
        4. Update state

        Source tables (dependency order):
        1. cmc_price_bars_1d (base)
        2. cmc_ema_multi_tf_u (depends on bars)
        3. cmc_returns_daily (depends on bars)
        4. cmc_vol_daily (depends on bars)
        5. cmc_ta_daily (depends on bars)
        """

        def __init__(self, engine: Engine, state_manager: FeatureStateManager):
            self.engine = engine
            self.state_manager = state_manager

        def get_source_watermarks(self, ids: list[int]) -> dict[str, pd.Timestamp]:
            """Get last refresh timestamp for each source table."""
            # Query state for each feature_type
            # Return {table_name: min_timestamp}

        def compute_dirty_window(self, ids: list[int]) -> tuple[pd.Timestamp, pd.Timestamp]:
            """
            Compute dirty window requiring refresh.

            Start = MIN of source watermarks
            End = now()

            If any source has no state, use default_start.
            """

        def refresh_for_ids(
            self,
            ids: list[int],
            start: Optional[str] = None,
            full_refresh: bool = False,
        ) -> int:
            """
            Refresh cmc_daily_features for given IDs.

            Steps:
            1. If full_refresh: DELETE WHERE id IN ids
            2. Else: DELETE WHERE id IN ids AND ts >= dirty_start
            3. INSERT from JOIN query
            4. Update state

            Returns: Number of rows inserted
            """

        def _build_join_query(self, ids: list[int], start: str, end: str) -> str:
            """
            Build the JOIN query to materialize features.

            SELECT from cmc_price_bars_1d p
            LEFT JOIN cmc_ema_multi_tf_u e ON ...
            LEFT JOIN cmc_returns_daily r ON ...
            LEFT JOIN cmc_vol_daily v ON ...
            LEFT JOIN cmc_ta_daily t ON ...
            WHERE p.id IN ids AND p.time_close BETWEEN start AND end
            """

        def _pivot_emas(self, df: pd.DataFrame) -> pd.DataFrame:
            """Pivot EMA table from long to wide format for specific periods."""
    ```

    **refresh_daily_features function:**
    ```python
    def refresh_daily_features(
        engine: Engine,
        ids: list[int],
        start: Optional[str] = None,
        full_refresh: bool = False,
    ) -> int:
        """Convenience function for CLI usage."""
    ```
  </action>
  <verify>
    python -c "from ta_lab2.scripts.features.daily_features_view import DailyFeaturesStore, refresh_daily_features; print('imports OK')"
  </verify>
  <done>
    DailyFeaturesStore imports with all methods implemented
  </done>
</task>

<task type="auto">
  <name>Task 3: Create refresh script and tests</name>
  <files>
    src/ta_lab2/scripts/features/refresh_cmc_daily_features.py
    tests/features/test_daily_features_view.py
  </files>
  <action>
    **refresh_cmc_daily_features.py CLI:**
    ```python
    """
    Refresh unified daily features store.

    Usage:
        python -m ta_lab2.scripts.features.refresh_cmc_daily_features --ids 1,52
        python -m ta_lab2.scripts.features.refresh_cmc_daily_features --all
        python -m ta_lab2.scripts.features.refresh_cmc_daily_features --full-refresh

    Materializes cmc_daily_features from:
    - cmc_price_bars_1d
    - cmc_ema_multi_tf_u
    - cmc_returns_daily
    - cmc_vol_daily
    - cmc_ta_daily

    State tracked in public.cmc_feature_state (feature_type='daily_features').
    """
    ```

    **test_daily_features_view.py tests:**
    1. test_get_source_watermarks - Returns dict with all sources
    2. test_compute_dirty_window_all_populated - MIN of watermarks
    3. test_compute_dirty_window_missing_source - Uses default
    4. test_build_join_query_structure - SQL has all JOINs
    5. test_build_join_query_columns - All feature columns selected
    6. test_refresh_for_ids_incremental - Only dirty window refreshed
    7. test_refresh_for_ids_full - All rows replaced
    8. test_pivot_emas_wide_format - Long to wide conversion
    9. test_data_quality_flags_union - Combines source flags
    10. test_asset_class_populated - From dim_sessions join
    11. test_feature_store_pattern - End-to-end refresh flow
    12. test_ml_query_pattern - Single SELECT returns all features

    Use mock database and verify SQL structure.
  </action>
  <verify>
    pytest tests/features/test_daily_features_view.py -v
    python -m ta_lab2.scripts.features.refresh_cmc_daily_features --help
  </verify>
  <done>
    All tests pass, CLI shows help
  </done>
</task>

</tasks>

<verification>
- [ ] DDL creates cmc_daily_features with columns from all source tables
- [ ] DailyFeaturesStore tracks dirty window from source watermarks
- [ ] JOIN query correctly combines all feature tables
- [ ] EMA columns pivoted from long to wide format
- [ ] Incremental refresh only updates dirty window
- [ ] Data quality flags union from all sources
- [ ] All 12 tests pass
</verification>

<success_criteria>
- cmc_daily_features table provides single-table access to all features
- Columns include: OHLCV, EMAs, returns, vol, TA indicators
- Incremental refresh respects source table watermarks
- Feature store pattern enables efficient ML pipeline queries
- asset_class column enables filtering by market type
</success_criteria>

<output>
After completion, create `.planning/phases/07-ta_lab2-feature-pipeline/07-06-SUMMARY.md`
</output>
