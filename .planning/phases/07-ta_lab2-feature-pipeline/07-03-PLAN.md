---
phase: 07-ta_lab2-feature-pipeline
plan: 03
type: execute
wave: 2
depends_on: [07-01, 07-02]
files_modified:
  - src/ta_lab2/scripts/features/returns_feature.py
  - src/ta_lab2/scripts/features/refresh_cmc_returns_daily.py
  - sql/features/040_cmc_returns_daily.sql
  - tests/features/test_returns_feature.py
autonomous: true

must_haves:
  truths:
    - "cmc_returns_daily calculates returns using lookbacks from dim_timeframe"
    - "Returns feature uses 'skip' null strategy - gaps are preserved"
    - "Multiple return windows calculated (1D, 3D, 5D, 7D, etc.) per tf_days"
  artifacts:
    - path: "src/ta_lab2/scripts/features/returns_feature.py"
      provides: "Returns feature implementation"
      exports: ["ReturnsFeature", "ReturnsConfig"]
    - path: "src/ta_lab2/scripts/features/refresh_cmc_returns_daily.py"
      provides: "CLI refresh script"
      contains: "if __name__"
    - path: "sql/features/040_cmc_returns_daily.sql"
      provides: "Returns table DDL"
      contains: "CREATE TABLE"
    - path: "tests/features/test_returns_feature.py"
      provides: "Unit tests for returns"
      min_lines: 150
  key_links:
    - from: "returns_feature.py"
      to: "BaseFeature"
      via: "class ReturnsFeature(BaseFeature)"
      pattern: "class ReturnsFeature\\(BaseFeature\\)"
    - from: "returns_feature.py"
      to: "dim_timeframe"
      via: "query for tf_days lookback windows"
      pattern: "dim_timeframe"
    - from: "returns_feature.py"
      to: "features/returns.py"
      via: "b2t_pct_delta, b2t_log_delta"
      pattern: "from ta_lab2\\.features\\.returns import"
---

<objective>
Implement cmc_returns_daily feature table with lookbacks from dim_timeframe.

Purpose: Calculate returns over multiple windows (1D, 3D, 5D, 7D, 30D, etc.) derived from dim_timeframe tf_days values.
Output: Returns feature module, refresh script, DDL, and tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-CONTEXT.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-01-SUMMARY.md
@.planning/phases/07-ta_lab2-feature-pipeline/07-02-SUMMARY.md

# Key existing code:
@src/ta_lab2/features/returns.py
@src/ta_lab2/time/dim_timeframe.py
@src/ta_lab2/scripts/returns/refresh_cmc_returns_d1.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cmc_returns_daily DDL</name>
  <files>
    sql/features/040_cmc_returns_daily.sql
  </files>
  <action>
    Create table DDL for daily returns with multiple lookback windows.

    **Schema design:**
    ```sql
    CREATE TABLE IF NOT EXISTS public.cmc_returns_daily (
        id              INTEGER NOT NULL,
        ts              TIMESTAMPTZ NOT NULL,

        -- Price context
        close           DOUBLE PRECISION,

        -- Bar-to-bar returns (always computed)
        ret_1d_pct      DOUBLE PRECISION,  -- 1-day percent return
        ret_1d_log      DOUBLE PRECISION,  -- 1-day log return

        -- Multi-day returns (lookbacks from dim_timeframe tf_days)
        ret_3d_pct      DOUBLE PRECISION,
        ret_5d_pct      DOUBLE PRECISION,
        ret_7d_pct      DOUBLE PRECISION,
        ret_14d_pct     DOUBLE PRECISION,
        ret_21d_pct     DOUBLE PRECISION,
        ret_30d_pct     DOUBLE PRECISION,
        ret_63d_pct     DOUBLE PRECISION,  -- ~3 months
        ret_126d_pct    DOUBLE PRECISION,  -- ~6 months
        ret_252d_pct    DOUBLE PRECISION,  -- ~1 year

        -- Normalized versions
        ret_1d_pct_zscore   DOUBLE PRECISION,
        ret_7d_pct_zscore   DOUBLE PRECISION,
        ret_30d_pct_zscore  DOUBLE PRECISION,

        -- Data quality flags
        gap_days        INTEGER,           -- Days since previous observation
        is_outlier      BOOLEAN DEFAULT FALSE,

        -- Metadata
        updated_at      TIMESTAMPTZ DEFAULT now(),

        PRIMARY KEY (id, ts)
    );

    -- Index for lookups
    CREATE INDEX IF NOT EXISTS idx_cmc_returns_daily_id_ts
    ON public.cmc_returns_daily (id, ts DESC);

    -- Comment
    COMMENT ON TABLE public.cmc_returns_daily IS
    'Daily returns calculated from cmc_price_bars_1d. Lookback windows derived from dim_timeframe tf_days.';
    ```
  </action>
  <verify>
    File exists and contains CREATE TABLE with all columns
  </verify>
  <done>
    DDL file exists with correct schema including z-score columns
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ReturnsFeature class</name>
  <files>
    src/ta_lab2/scripts/features/returns_feature.py
  </files>
  <action>
    Create ReturnsFeature extending BaseFeature.

    **ReturnsConfig:**
    ```python
    @dataclass(frozen=True)
    class ReturnsConfig(FeatureConfig):
        feature_type: str = "returns"
        output_table: str = "cmc_returns_daily"
        null_strategy: str = "skip"  # Per CONTEXT.md - returns skip NULLs
        add_zscore: bool = True

        # Return windows to compute (from dim_timeframe tf_days)
        lookback_windows: tuple[int, ...] = (1, 3, 5, 7, 14, 21, 30, 63, 126, 252)
    ```

    **ReturnsFeature implementation:**
    ```python
    class ReturnsFeature(BaseFeature):
        """
        Compute daily returns with multiple lookback windows.

        Uses existing returns.py functions (b2t_pct_delta, b2t_log_delta)
        for bar-to-bar returns, then computes multi-day returns via
        pct_change(periods=n).

        Lookback windows derived from dim_timeframe tf_days values.
        """

        def load_source_data(self, ids, start, end) -> pd.DataFrame:
            """Load from cmc_price_bars_1d (daily bars)."""
            # Query cmc_price_bars_1d for close prices
            # Include id, time_close as ts, close
            # Order by id, ts ASC for chronological processing

        def get_lookback_windows(self) -> list[int]:
            """Get lookback windows from dim_timeframe."""
            # Query dim_timeframe for distinct tf_days
            # Filter to relevant daily windows (1, 3, 5, 7, 14, 21, 30, etc.)
            # Intersect with config.lookback_windows

        def compute_features(self, df_source: pd.DataFrame) -> pd.DataFrame:
            """
            Compute returns for all windows.

            For each (id):
            1. Sort by ts ascending
            2. Compute bar-to-bar returns (1D pct and log)
            3. For each lookback window n:
               - ret_Nd_pct = close.pct_change(periods=n)
            4. Add gap_days = (ts - ts.shift(1)).dt.days
            """

        def get_output_schema(self) -> dict[str, str]:
            # Return column -> SQL type mapping

        def get_feature_columns(self) -> list[str]:
            # Return list of computed return columns
    ```

    **Important details:**
    - Use existing returns.py functions for b2t calculations
    - Query dim_timeframe to validate lookback windows exist
    - Handle edge cases: insufficient data, all NULLs
    - Add gap_days for data quality tracking
  </action>
  <verify>
    python -c "from ta_lab2.scripts.features.returns_feature import ReturnsFeature, ReturnsConfig; print('imports OK')"
  </verify>
  <done>
    ReturnsFeature imports successfully with all methods implemented
  </done>
</task>

<task type="auto">
  <name>Task 3: Create refresh script and tests</name>
  <files>
    src/ta_lab2/scripts/features/refresh_cmc_returns_daily.py
    tests/features/test_returns_feature.py
  </files>
  <action>
    **refresh_cmc_returns_daily.py CLI:**
    Follow refresh_cmc_ema_multi_tf_from_bars.py pattern.

    ```python
    """
    Incremental daily returns refresh from cmc_price_bars_1d.

    Usage:
        python -m ta_lab2.scripts.features.refresh_cmc_returns_daily --ids 1,52
        python -m ta_lab2.scripts.features.refresh_cmc_returns_daily --all
        python -m ta_lab2.scripts.features.refresh_cmc_returns_daily --full-refresh

    State tracked in public.cmc_feature_state (feature_type='returns').
    """

    def main():
        parser = argparse.ArgumentParser()
        parser.add_argument("--ids", help="Comma-separated IDs")
        parser.add_argument("--all", action="store_true")
        parser.add_argument("--start", help="Start date YYYY-MM-DD")
        parser.add_argument("--full-refresh", action="store_true")
        parser.add_argument("--dry-run", action="store_true")
        args = parser.parse_args()

        # Initialize engine, config, feature
        # Use FeatureStateManager for incremental logic
        # Call feature.compute_for_ids()
        # Update state after completion
    ```

    **test_returns_feature.py tests:**
    1. test_returns_config_defaults - Correct default values
    2. test_returns_config_custom_windows - Custom lookbacks work
    3. test_load_source_data_query - SQL query correct (mock)
    4. test_compute_features_basic - Returns calculated correctly
    5. test_compute_features_gap_days - Gap tracking works
    6. test_compute_features_zscore - Z-score added when configured
    7. test_get_lookback_windows_from_dim - Queries dim_timeframe
    8. test_compute_for_ids_full_flow - Template method works
    9. test_incremental_refresh - Only new rows computed
    10. test_empty_source_data - Handles gracefully

    Use synthetic data with known returns for verification.
  </action>
  <verify>
    pytest tests/features/test_returns_feature.py -v
    python -m ta_lab2.scripts.features.refresh_cmc_returns_daily --help
  </verify>
  <done>
    All tests pass, CLI shows help with all options
  </done>
</task>

</tasks>

<verification>
- [ ] DDL creates table with all return columns and z-scores
- [ ] ReturnsFeature extends BaseFeature correctly
- [ ] Lookback windows queried from dim_timeframe
- [ ] gap_days tracks observation gaps
- [ ] is_outlier flags extreme returns
- [ ] Refresh script supports --ids, --all, --full-refresh, --dry-run
- [ ] All tests pass
</verification>

<success_criteria>
- cmc_returns_daily table created with correct schema
- Returns calculated for windows: 1D, 3D, 5D, 7D, 14D, 21D, 30D, 63D, 126D, 252D
- Z-score normalization added for key windows (1D, 7D, 30D)
- Incremental refresh only computes new rows
- 10+ unit tests pass covering edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/07-ta_lab2-feature-pipeline/07-03-SUMMARY.md`
</output>
