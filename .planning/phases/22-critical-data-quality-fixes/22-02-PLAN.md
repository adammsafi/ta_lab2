---
phase: 22-critical-data-quality-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ta_lab2/scripts/emas/base_ema_refresher.py
  - src/ta_lab2/scripts/emas/ema_state_manager.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "EMA output validation catches NaN, infinity, and out-of-range values"
    - "Validation uses hybrid bounds: price-based (0.5x-2x) + statistical (3 std dev)"
    - "Violations logged to ema_rejects table AND application logs (WARNING level)"
    - "All EMAs written even if invalid (warn and continue, no data loss)"
  artifacts:
    - path: "src/ta_lab2/scripts/emas/base_ema_refresher.py"
      provides: "Central EMA validation layer in save_output()"
      contains: "validate_ema_output"
    - path: "Database"
      provides: "ema_rejects table for audit trail"
      contains: "violation_type, bounds_info"
  key_links:
    - from: "BaseEMARefresher.save_output()"
      to: "validate_ema_output()"
      via: "validation before INSERT"
      pattern: "validate_ema_output.*before.*upsert"
    - from: "validate_ema_output()"
      to: "ema_rejects table"
      via: "log_ema_violation()"
      pattern: "INSERT INTO.*ema_rejects"
---

<objective>
Add EMA output validation with hybrid bounds checking to BaseEMARefresher.

Purpose: GAP-C02 identified that no validation exists for computed EMA values. Broken EMAs (NaN, infinity, negative values) persist to EMA tables and propagate to downstream features/signals without warning.

Output: Central validation layer in BaseEMARefresher.save_output() with ema_rejects table for audit trail.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-critical-data-quality-fixes/22-CONTEXT.md

# Key source files
@src/ta_lab2/scripts/emas/base_ema_refresher.py
@src/ta_lab2/scripts/emas/ema_state_manager.py
@src/ta_lab2/scripts/emas/ema_computation_orchestrator.py

# Phase 21 analysis
@.planning/phases/21-comprehensive-review/deliverables/gap-analysis.md (GAP-C02 details)
@.planning/phases/21-comprehensive-review/deliverables/validation-points.md (EMA validation section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EMA validation functions to base_ema_refresher.py</name>
  <files>src/ta_lab2/scripts/emas/base_ema_refresher.py</files>
  <action>
Add EMA validation functions to base_ema_refresher.py:

1. Create ema_rejects table DDL:
```python
EMA_REJECTS_TABLE_DDL = """
CREATE TABLE IF NOT EXISTS {schema}.{table} (
    id INTEGER,
    tf TEXT,
    period INTEGER,
    timestamp TIMESTAMPTZ,
    ema_value DOUBLE PRECISION,
    violation_type TEXT,  -- 'nan', 'infinity', 'negative', 'out_of_price_bounds', 'out_of_statistical_bounds'
    bounds_info TEXT,     -- JSON with bound details: {"price_min": X, "price_max": Y, "stat_mean": Z, "stat_std": W}
    source_bar_close DOUBLE PRECISION,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (id, tf, period, timestamp, violation_type)
);
"""
```

2. Create get_price_bounds function:
```python
def get_price_bounds(
    engine: Engine,
    id: int,
    tf: str,
    source_table: str,
    lookback_days: int = 90
) -> tuple[float, float]:
    """
    Get price bounds from source bar table for EMA validation.

    Returns (min_bound, max_bound) where:
    - min_bound = 0.5 * MIN(close) over lookback window
    - max_bound = 2.0 * MAX(close) over lookback window

    These wide bounds catch extreme outliers (infinity, corruption)
    while allowing normal price movements.
    """
```

3. Create get_statistical_bounds function:
```python
def get_statistical_bounds(
    engine: Engine,
    id: int,
    tf: str,
    period: int,
    output_table: str,
    lookback_count: int = 100
) -> tuple[float, float, float, float]:
    """
    Get statistical bounds from historical EMA distribution.

    Returns (mean, std, lower_bound, upper_bound) where:
    - mean, std computed from last N EMA values for this (id, tf, period)
    - lower_bound = mean - 3 * std
    - upper_bound = mean + 3 * std

    These narrow bounds catch calculation drift, subtle errors.
    Returns (None, None, None, None) if insufficient history (<10 values).
    """
```

4. Create validate_ema_output function:
```python
def validate_ema_output(
    ema_values: pd.DataFrame,  # columns: id, tf, period, timestamp, ema, close
    price_bounds: dict,         # {(id, tf): (min, max)}
    statistical_bounds: dict,   # {(id, tf, period): (mean, std, lower, upper)}
) -> tuple[pd.DataFrame, list[dict]]:
    """
    Validate EMA output values against hybrid bounds.

    Checks (in order):
    1. NOT NULL / NOT NaN
    2. NOT infinity
    3. NOT negative
    4. Within price bounds (0.5x-2x recent min/max)
    5. Within statistical bounds (mean +/- 3 std)

    Returns:
    - ema_values unchanged (all rows, including invalid)
    - list of violation records for rejects table

    Strategy: Warn and continue - log violations but write all EMAs.
    """
```

5. Create log_ema_violations function:
```python
def log_ema_violations(
    engine: Engine,
    violations: list[dict],
    rejects_table: str,
    schema: str = "public"
) -> int:
    """
    Log EMA violations to rejects table and application logs.

    For each violation:
    - INSERT to rejects table
    - Log at WARNING level: "EMA violation: id={id}, tf={tf}, period={period}, type={violation_type}"

    Returns: Number of violations logged
    """
```

IMPORTANT: Validation must happen IN BaseEMARefresher so all 6 variants inherit it automatically.
  </action>
  <verify>
```bash
python -c "from ta_lab2.scripts.emas.base_ema_refresher import validate_ema_output, get_price_bounds, get_statistical_bounds; print('Import OK')"
```
  </verify>
  <done>
- EMA_REJECTS_TABLE_DDL constant defined
- get_price_bounds queries source bar table with 0.5x-2x multipliers
- get_statistical_bounds queries historical EMA distribution with 3 std dev
- validate_ema_output applies both checks, returns violations list
- log_ema_violations inserts to rejects table AND logs at WARNING level
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation into BaseEMARefresher.save_output()</name>
  <files>src/ta_lab2/scripts/emas/base_ema_refresher.py</files>
  <action>
Integrate validation into the BaseEMARefresher execution flow:

1. Add CLI arguments to base argument parser:
```python
parser.add_argument("--validate-output", action="store_true", default=True,
    help="Validate EMA output (default: True)")
parser.add_argument("--no-validate-output", action="store_false", dest="validate_output",
    help="Skip EMA output validation")
parser.add_argument("--ema-rejects-table", default="ema_rejects",
    help="Table name for EMA violations (default: ema_rejects)")
```

2. Create rejects table at startup (if validation enabled):
```python
if config.validate_output:
    ddl = EMA_REJECTS_TABLE_DDL.format(schema=config.output_schema, table=config.ema_rejects_table)
    with engine.begin() as conn:
        conn.execute(text(ddl))
```

3. Add validation to save_output() or equivalent method:
- BEFORE the final INSERT/UPSERT to EMA table
- Compute bounds ONCE per batch (not per row - batch bound queries)
- Call validate_ema_output with accumulated EMA values
- Call log_ema_violations for any violations found
- THEN proceed with normal INSERT (all rows, including invalid)

4. Add summary logging at script completion:
```python
logger.info(f"EMA validation: {total_violations} violations in {violation_count_by_type}")
```

Performance optimization (from 22-CONTEXT.md):
- Batch bound queries: Get all price bounds in 1-2 queries, not per (id, tf)
- Cache statistical bounds: Compute once at script start, reuse for all EMAs
- Expected overhead: ~1-2% slowdown (5-8 seconds on 6-7 minute refresh)
  </action>
  <verify>
```bash
# Verify CLI arguments
python -c "from ta_lab2.scripts.emas.base_ema_refresher import BaseEMARefresher; parser = BaseEMARefresher.create_base_argument_parser(); args = parser.parse_args(['--help'])" 2>&1 | grep -E "validate-output|ema-rejects"

# Verify validation is in save flow
grep -n "validate_ema_output" src/ta_lab2/scripts/emas/base_ema_refresher.py
```
  </verify>
  <done>
- --validate-output (default True) and --ema-rejects-table CLI arguments available
- ema_rejects table created automatically at startup
- Validation runs BEFORE INSERT, logs violations, continues with write
- Bounds queries batched for performance (1-2 queries, not per row)
- Summary logging shows violation counts at script completion
  </done>
</task>

<task type="auto">
  <name>Task 3: Test validation with all EMA variants</name>
  <files>
src/ta_lab2/scripts/emas/refresh_cmc_ema_multi_tf_from_bars.py
src/ta_lab2/scripts/emas/refresh_cmc_ema_multi_tf_v2.py
src/ta_lab2/scripts/emas/refresh_cmc_ema_multi_tf_cal_from_bars.py
src/ta_lab2/scripts/emas/refresh_cmc_ema_multi_tf_cal_anchor_from_bars.py
  </files>
  <action>
Verify all 4 EMA refresher scripts inherit validation from BaseEMARefresher:

1. Check that each script uses BaseEMARefresher (they should already):
```bash
grep -l "BaseEMARefresher" src/ta_lab2/scripts/emas/refresh_cmc_ema*.py
```

2. Verify --validate-output argument is available in each script:
```bash
for script in refresh_cmc_ema_multi_tf_from_bars refresh_cmc_ema_multi_tf_v2 refresh_cmc_ema_multi_tf_cal_from_bars refresh_cmc_ema_multi_tf_cal_anchor_from_bars; do
    python src/ta_lab2/scripts/emas/${script}.py --help | grep -q "validate-output" && echo "$script: OK" || echo "$script: MISSING"
done
```

3. If any script does NOT inherit from BaseEMARefresher (e.g., v2 might be standalone):
- Add the same validation integration pattern directly to that script
- Import validation functions from base_ema_refresher
- Add CLI arguments and validation call in save flow

4. Run a quick validation test on one ID to confirm flow works:
```bash
python src/ta_lab2/scripts/emas/refresh_cmc_ema_multi_tf_from_bars.py --ids 1 --validate-output
```

IMPORTANT: The goal is automatic inheritance. If scripts properly use BaseEMARefresher, no changes needed to individual scripts. Only modify if they don't inherit the validation.
  </action>
  <verify>
```bash
# All 4 scripts should show validate-output in help
for script in refresh_cmc_ema_multi_tf_from_bars refresh_cmc_ema_multi_tf_v2 refresh_cmc_ema_multi_tf_cal_from_bars refresh_cmc_ema_multi_tf_cal_anchor_from_bars; do
    python src/ta_lab2/scripts/emas/${script}.py --help 2>&1 | grep -q "validate-output" && echo "$script: OK" || echo "$script: NEEDS ATTENTION"
done
```
  </verify>
  <done>
- All 4 EMA refresher scripts have --validate-output argument (via inheritance or direct)
- Running any EMA script with --validate-output creates ema_rejects table
- Validation runs automatically during EMA computation
- No changes needed to scripts that properly inherit from BaseEMARefresher
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema verification:
```sql
-- Check ema_rejects table exists with correct columns
\d ema_rejects
-- Should show: id, tf, period, timestamp, ema_value, violation_type, bounds_info, source_bar_close, created_at
```

2. Functional test:
```bash
# Run EMA refresh with validation
python src/ta_lab2/scripts/emas/refresh_cmc_ema_multi_tf_from_bars.py --ids 1 --validate-output

# Check rejects table (may be empty if no violations)
psql -c "SELECT violation_type, COUNT(*) FROM ema_rejects GROUP BY violation_type;"
```

3. Inheritance verification:
```bash
# All scripts should have the argument
grep -l "validate-output" src/ta_lab2/scripts/emas/refresh_cmc_ema*.py
# Expected: All 4 scripts (via base class or direct)
```

4. Performance check:
- Run full refresh with validation, note total time
- Compare to baseline without validation
- Expected: <2% overhead (5-8 seconds on 6-7 minute refresh)
</verification>

<success_criteria>
1. Hybrid bounds implemented: price-based (0.5x-2x recent min/max) + statistical (mean +/- 3 std)
2. Validation happens in BaseEMARefresher so all 6 variants inherit automatically
3. Violations logged to BOTH ema_rejects table AND application logs (WARNING level)
4. "Warn and continue" strategy: all EMAs written even if invalid (no data loss)
5. Performance overhead < 2% (batched queries, cached bounds)
</success_criteria>

<output>
After completion, create `.planning/phases/22-critical-data-quality-fixes/22-02-SUMMARY.md`
</output>
