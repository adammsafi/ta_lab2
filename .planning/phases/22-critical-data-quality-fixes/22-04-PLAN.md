---
phase: 22-critical-data-quality-fixes
plan: 04
type: execute
wave: 2
depends_on: ["22-03"]
files_modified:
  - src/ta_lab2/scripts/bars/derive_multi_tf_from_1d.py
  - src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Multi-TF bars can be derived from 1D bars instead of price_histories7"
    - "Daily bars copied directly from cmc_price_bars_1d"
    - "Weekly/monthly bars aggregated from daily using same OHLCV math"
    - "Derivation produces identical results to direct source query"
  artifacts:
    - path: "src/ta_lab2/scripts/bars/derive_multi_tf_from_1d.py"
      provides: "Functions to derive multi-TF bars from 1D"
      contains: "aggregate_daily_to_timeframe"
    - path: "src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py"
      provides: "Builder with --from-1d flag for derivation mode"
      contains: "--from-1d"
  key_links:
    - from: "refresh_cmc_price_bars_multi_tf.py --from-1d"
      to: "cmc_price_bars_1d"
      via: "derive_multi_tf_from_1d.aggregate_daily_to_timeframe"
      pattern: "SELECT.*FROM.*cmc_price_bars_1d"
---

<objective>
Create foundation for deriving multi-TF bars from 1D bars (GAP-C03 Part 2: Architectural foundation).

Purpose: GAP-C03 complex fix requires multi-TF builders to read from cmc_price_bars_1d instead of price_histories7. This creates a single source of truth where 1D validation rules propagate to all downstream bars. This plan establishes the derivation logic and adds --from-1d flag to the main multi-TF builder.

Output: derive_multi_tf_from_1d.py module with aggregation functions + --from-1d flag in main builder.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-critical-data-quality-fixes/22-CONTEXT.md

# Key source files
@src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py
@src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py
@src/ta_lab2/scripts/bars/common_snapshot_contract.py
@src/ta_lab2/scripts/bars/polars_bar_operations.py

# Phase 21 analysis
@.planning/phases/21-comprehensive-review/deliverables/gap-analysis.md (GAP-C03 details)
@.planning/phases/21-comprehensive-review/deliverables/data-flow-diagram.md (aggregation logic)

# Dependency
@.planning/phases/22-critical-data-quality-fixes/22-03-SUMMARY.md (if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create derive_multi_tf_from_1d.py module</name>
  <files>src/ta_lab2/scripts/bars/derive_multi_tf_from_1d.py</files>
  <action>
Create a new module with functions to derive multi-TF bars from 1D bars:

```python
"""
Derive multi-timeframe bars from validated 1D bars.

This module provides functions to aggregate daily bars into longer timeframes
(2D, 3D, 5D, 1W, 2W, 4W, 1M, 3M, etc.) using standard OHLCV aggregation rules.

Design principles:
- 1D table is the single source of truth (validated, quality-flagged)
- Daily bars copied directly (no aggregation needed)
- Weekly/monthly bars aggregate from daily using deterministic rules
- Aggregation logic matches existing multi-TF builder (same OHLCV math)

Benefits:
- 1D validation rules propagate to all multi-TF bars automatically
- Unified backfill handling: fix 1D, all downstream rebuilds
- Trade-off: 2x slower refresh (12 min vs 6 min) for data consistency guarantees
"""

from __future__ import annotations

import pandas as pd
import polars as pl
from sqlalchemy.engine import Engine
from typing import Literal

from ta_lab2.scripts.bars.common_snapshot_contract import (
    compute_time_high_low,
    enforce_ohlc_sanity,
)


def load_1d_bars_for_id(
    engine: Engine,
    id: int,
    start_date: str | None = None,
    end_date: str | None = None,
) -> pl.DataFrame:
    """
    Load validated 1D bars for a given ID.

    Args:
        engine: SQLAlchemy engine
        id: Asset ID
        start_date: Optional start date filter (inclusive)
        end_date: Optional end date filter (inclusive)

    Returns:
        Polars DataFrame with columns:
        - id, timestamp, tf, bar_seq
        - open, high, low, close, volume
        - time_high, time_low
        - quality flags (is_partial_start, is_partial_end, is_missing_days)
    """
    pass  # Implementation: SELECT from cmc_price_bars_1d


def aggregate_daily_to_timeframe(
    df_daily: pl.DataFrame,
    target_tf: str,
    alignment: Literal["tf_day", "calendar_us", "calendar_iso"] = "tf_day",
) -> pl.DataFrame:
    """
    Aggregate daily bars into target timeframe.

    Args:
        df_daily: Daily bars from load_1d_bars_for_id()
        target_tf: Target timeframe (2D, 3D, 5D, 1W, 2W, 4W, 1M, 3M, etc.)
        alignment: Calendar alignment mode

    Returns:
        Polars DataFrame with aggregated bars:
        - id, timestamp (period start), tf, bar_seq
        - open (first day's open)
        - high (max of all days' highs)
        - low (min of all days' lows)
        - close (last day's close)
        - volume (sum of all days' volumes)
        - time_high, time_low (deterministic: earliest among ties)
        - Quality flags propagated from source days

    Aggregation rules (match existing multi-TF builder):
    - OHLCV: Standard candlestick aggregation
    - time_high/time_low: Use compute_time_high_low with tie-breaking
    - Quality flags: OR logic (if any source day has flag, bar has flag)
    """
    pass  # Implementation: Polars group_by with aggregation expressions


def derive_multi_tf_bars(
    engine: Engine,
    id: int,
    timeframes: list[str],
    alignment: Literal["tf_day", "calendar_us", "calendar_iso"] = "tf_day",
    start_date: str | None = None,
) -> pl.DataFrame:
    """
    Derive all multi-TF bars for an ID from 1D source.

    Args:
        engine: SQLAlchemy engine
        id: Asset ID
        timeframes: List of target timeframes (e.g., ["1D", "2D", "1W", "1M"])
        alignment: Calendar alignment mode
        start_date: Only process bars from this date (for incremental)

    Returns:
        Polars DataFrame with all derived bars, ready for upsert.
    """
    pass  # Load 1D, iterate timeframes, aggregate each, concat results


def validate_derivation_consistency(
    df_derived: pl.DataFrame,
    df_direct: pl.DataFrame,
    tolerance: float = 1e-10,
) -> tuple[bool, list[str]]:
    """
    Validate that derived bars match directly-computed bars.

    Used during migration to verify derivation logic is correct.

    Returns:
        (is_consistent, list_of_discrepancies)
    """
    pass  # Compare OHLCV values with tolerance
```

Follow existing Polars patterns from polars_bar_operations.py for aggregation.
Use same OHLCV aggregation logic as current multi-TF builder.
  </action>
  <verify>
```bash
python -c "from ta_lab2.scripts.bars.derive_multi_tf_from_1d import load_1d_bars_for_id, aggregate_daily_to_timeframe, derive_multi_tf_bars; print('Import OK')"
```
  </verify>
  <done>
- load_1d_bars_for_id queries cmc_price_bars_1d with filters
- aggregate_daily_to_timeframe implements OHLCV aggregation with Polars
- derive_multi_tf_bars orchestrates full derivation pipeline
- validate_derivation_consistency enables migration verification
- All functions documented with clear docstrings
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --from-1d flag to main multi-TF builder</name>
  <files>src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py</files>
  <action>
Modify refresh_cmc_price_bars_multi_tf.py to support derivation from 1D bars:

1. Add imports:
```python
from ta_lab2.scripts.bars.derive_multi_tf_from_1d import (
    load_1d_bars_for_id,
    aggregate_daily_to_timeframe,
    derive_multi_tf_bars,
)
```

2. Add CLI argument:
```python
parser.add_argument("--from-1d", action="store_true",
    help="Derive multi-TF bars from cmc_price_bars_1d instead of price_histories7")
parser.add_argument("--validate-derivation", action="store_true",
    help="Compare derived bars to direct computation (for migration validation)")
```

3. Add derivation path in processing logic:
```python
def process_id(engine: Engine, id: int, timeframes: list[str], args) -> int:
    if args.from_1d:
        # Derive from 1D bars
        df_bars = derive_multi_tf_bars(
            engine=engine,
            id=id,
            timeframes=timeframes,
            alignment="tf_day",
            start_date=args.start_date if hasattr(args, 'start_date') else None,
        )

        # Optional: validate against direct computation
        if args.validate_derivation:
            df_direct = compute_bars_directly(engine, id, timeframes)  # existing logic
            is_consistent, discrepancies = validate_derivation_consistency(df_bars, df_direct)
            if not is_consistent:
                logger.warning(f"Derivation discrepancies for id={id}: {discrepancies}")
    else:
        # Existing logic: compute from price_histories7
        df_bars = compute_bars_directly(engine, id, timeframes)

    # Rest of processing unchanged (upsert, state update, etc.)
    return len(df_bars)
```

4. Keep existing direct computation path as default (backward compatibility):
- --from-1d must be explicitly specified
- Default behavior unchanged (reads from price_histories7)

5. Log derivation mode at startup:
```python
if args.from_1d:
    logger.info("Deriving multi-TF bars from cmc_price_bars_1d (--from-1d mode)")
else:
    logger.info("Computing multi-TF bars from price_histories7 (direct mode)")
```

IMPORTANT: This task adds the derivation PATH but keeps direct computation as default.
The switch to derivation-only happens in 22-05 after validation.
  </action>
  <verify>
```bash
# Verify CLI arguments
python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py --help | grep -E "from-1d|validate-derivation"

# Verify import works
python -c "from ta_lab2.scripts.bars.refresh_cmc_price_bars_multi_tf import main; print('Import OK')"
```
  </verify>
  <done>
- --from-1d flag available (derives from cmc_price_bars_1d)
- --validate-derivation flag available (compares derived vs direct)
- Default behavior unchanged (direct computation from price_histories7)
- Derivation path uses new derive_multi_tf_from_1d module
- Logging indicates which mode is active
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate derivation produces identical results</name>
  <files>tests/test_bar_contract.py</files>
  <action>
Add validation test to confirm derivation produces identical bars:

1. Add test for derivation consistency:
```python
@pytest.mark.skipif(not DB_AVAILABLE, reason="Database not available")
def test_derivation_matches_direct_computation():
    """
    Validate that --from-1d derivation produces identical bars to direct computation.

    This is critical for migration: derivation must be bit-for-bit identical
    (within floating point tolerance) to existing logic.
    """
    # Run builder in both modes for test ID
    # Compare OHLCV values
    # Assert identical within epsilon
    pass

def test_aggregation_ohlcv_math():
    """
    Unit test for OHLCV aggregation rules:
    - Open = first day's open
    - High = max of all days' highs
    - Low = min of all days' lows
    - Close = last day's close
    - Volume = sum of all days' volumes
    """
    # Test with known input data
    pass

def test_aggregation_quality_flag_propagation():
    """
    Test that quality flags propagate correctly:
    - If any source day has is_missing_days=TRUE, bar has is_missing_days=TRUE
    - If first day has is_partial_start=TRUE, bar has is_partial_start=TRUE
    - If last day has is_partial_end=TRUE, bar has is_partial_end=TRUE
    """
    pass

def test_time_high_low_determinism():
    """
    Test that time_high and time_low are deterministic:
    - Choose earliest timestamp among ties
    - Same as existing compute_time_high_low behavior
    """
    pass
```

2. Run derivation validation with real data (if available):
```bash
# This is a manual validation step
python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py \
    --ids 1 --from-1d --validate-derivation
```

Expected output: "Derivation consistent for id=1" (or warning if discrepancies)
  </action>
  <verify>
```bash
# Run unit tests
pytest tests/test_bar_contract.py -v -k "derivation or aggregation" --tb=short

# If database available, run integration test
python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py --ids 1 --from-1d --validate-derivation 2>&1 | grep -E "consistent|discrepancies"
```
  </verify>
  <done>
- Unit tests verify OHLCV aggregation math
- Unit tests verify quality flag propagation
- Unit tests verify time_high/time_low determinism
- Integration test confirms derivation matches direct computation
- No discrepancies in validation (bit-for-bit identical within epsilon)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Module verification:
```bash
python -c "
from ta_lab2.scripts.bars.derive_multi_tf_from_1d import (
    load_1d_bars_for_id,
    aggregate_daily_to_timeframe,
    derive_multi_tf_bars,
    validate_derivation_consistency,
)
print('All functions importable')
"
```

2. CLI verification:
```bash
python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py --help | grep -E "from-1d|validate-derivation"
# Expected: Both flags documented
```

3. Derivation test (with database):
```bash
# Run with validation
python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py \
    --ids 1 --from-1d --validate-derivation

# Should output: "Derivation consistent for id=1"
```

4. Performance comparison (optional):
```bash
# Time direct mode
time python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py --ids 1
# Time derivation mode
time python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py --ids 1 --from-1d
# Expected: derivation ~2x slower (acceptable trade-off per 22-CONTEXT.md)
```
</verification>

<success_criteria>
1. derive_multi_tf_from_1d.py module provides all aggregation functions
2. --from-1d flag enables derivation mode in main builder
3. --validate-derivation flag compares derived vs direct computation
4. Derivation produces identical results (within epsilon tolerance)
5. Default behavior unchanged (backward compatibility)
6. Tests verify aggregation logic correctness
</success_criteria>

<output>
After completion, create `.planning/phases/22-critical-data-quality-fixes/22-04-SUMMARY.md`
</output>
