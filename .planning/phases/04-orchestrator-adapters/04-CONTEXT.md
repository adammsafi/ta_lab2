# Phase 4: Orchestrator Adapters - Context

**Gathered:** 2026-01-29
**Status:** Ready for planning

<domain>
## Phase Boundary

Build adapter layer to execute tasks on three AI platforms (Claude Code, ChatGPT, Gemini) through a unified interface. Each adapter translates orchestrator requests into platform-specific API calls, subprocess invocations, or CLI commands, then normalizes responses back to a common format.

</domain>

<decisions>
## Implementation Decisions

### Interface Contract
- **Execution model:** Async (asyncio) — adapters return awaitables for better parallel execution and streaming support
- **Core methods:** Comprehensive lifecycle — `submit_task()`, `get_status()`, `get_result()`, `cancel_task()` for full task control
- **Base class vs protocol:** Claude's discretion — choose between abstract base class (code reuse) vs protocol (flexibility)
- **Initialization:** Claude's discretion — constructor args vs factory pattern based on testability needs

### Task Representation
- **Structure:** Structured object (dataclass/dict) — enables rich metadata beyond just prompt text
- **Required fields:**
  - `prompt` (required) — main instruction/question for the AI
  - `context` (optional) — additional context from memory system, previous tasks
  - `files` (optional) — file paths or content for Claude's file operations
  - `constraints` (optional) — token limits, timeout, temperature, model selection
- **Platform-specific fields:** Claude's discretion — balance platform-agnostic abstraction vs platform-specific power
- **File attachments:** Hybrid (path with fallback) — prefer paths, include content when needed

### Result Handling
- **Streaming:** Both modes — `get_result()` returns complete result, `stream_result()` yields partial chunks for flexibility
- **Result object fields:**
  - `output` — AI response text or structured data
  - `status` — success/error/partial execution state
  - `metadata` — tokens used, cost, duration for quota tracking
  - `files` — output files generated by task (e.g., Claude Code writes)
- **Error communication:** Hybrid approach — exceptions for critical adapter failures (auth, network), errors in result object for task failures (invalid prompt, quota exhausted)
- **Result storage:** Claude's discretion — decide whether adapters cache results or orchestrator stores them

### Platform-Specific Features
- **Philosophy:** Preserve unique strengths — expose platform specifics where valuable rather than hiding differences
- **Claude Code file operations:** Claude's discretion — expose via common interface, Claude-specific methods, or data structures only
- **Gemini quota integration:** Claude's discretion — adapter calls quota manager internally, orchestrator manages it, or adapter exposes quota info
- **Capability discovery:** Claude's discretion — capabilities dict for runtime discovery vs try-and-handle-errors

### Claude's Discretion
- Base class vs protocol for adapter interface
- Initialization pattern (constructor vs factory)
- Platform-specific field support in task objects
- File operation exposure strategy
- Gemini quota integration approach
- Capability discovery mechanism
- Result caching/storage responsibility

</decisions>

<specifics>
## Specific Ideas

- Interface should support full task lifecycle (submit → status → result → cancel) not just fire-and-forget
- Async from the start for parallel execution (Phase 5 will need this)
- Preserve platform strengths: Claude's file ops, Gemini's free tier quota, ChatGPT's streaming
- Error handling should distinguish "adapter broke" (exception) from "task failed" (error in result)

</specifics>

<deferred>
## Deferred Ideas

None — discussion stayed within phase scope

</deferred>

---

*Phase: 04-orchestrator-adapters*
*Context gathered: 2026-01-29*
