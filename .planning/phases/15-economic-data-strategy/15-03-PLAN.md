---
phase: 15-economic-data-strategy
plan: 03
type: execute
wave: 2
depends_on: ["15-02"]
files_modified:
  - src/ta_lab2/integrations/economic/__init__.py
  - src/ta_lab2/integrations/economic/base.py
  - src/ta_lab2/integrations/economic/fred_provider.py
  - src/ta_lab2/integrations/economic/types.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Base provider protocol defines interface for economic data providers"
    - "FredProvider wraps fredapi with working get_series method"
    - "Types define standard data structures for economic data"
  artifacts:
    - path: "src/ta_lab2/integrations/economic/__init__.py"
      provides: "Package exports and documentation"
      exports: ["EconomicDataProvider", "FredProvider", "EconomicSeries"]
    - path: "src/ta_lab2/integrations/economic/base.py"
      provides: "Abstract base provider protocol"
      contains: "class EconomicDataProvider"
    - path: "src/ta_lab2/integrations/economic/fred_provider.py"
      provides: "Working fredapi passthrough provider"
      contains: "class FredProvider"
    - path: "src/ta_lab2/integrations/economic/types.py"
      provides: "Data type definitions"
      contains: "class EconomicSeries"
  key_links:
    - from: "fred_provider.py"
      to: "fredapi"
      via: "import"
      pattern: "from fredapi import Fred"
    - from: "fred_provider.py"
      to: "base.py"
      via: "implements"
      pattern: "class FredProvider.*EconomicDataProvider"
---

<objective>
Create integrations.economic skeleton with base classes and working fredapi provider

Purpose: Build production-ready economic data integration skeleton per context requirements. FredProvider actually works by wrapping fredapi (not stub). Includes base protocol for future providers (Fed, etc.), type definitions, and proper optional dependency handling.

Output: ta_lab2.integrations.economic module with working fredapi passthrough that can fetch real FRED data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-economic-data-strategy/15-CONTEXT.md
@.planning/phases/15-economic-data-strategy/15-RESEARCH.md

# Optional dependency patterns
@pyproject.toml
@src/ta_lab2/utils/cache.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types.py with data structures</name>
  <files>src/ta_lab2/integrations/economic/types.py</files>
  <action>
Create types.py with standard data structures for economic data:

```python
"""Type definitions for economic data integration.

Provides standardized data structures for economic time series data,
ensuring consistent interfaces across different data providers
(FRED, Fed, etc.).
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List

import pandas as pd


@dataclass
class EconomicSeries:
    """Standardized economic time series data.

    Attributes:
        series_id: Unique identifier (e.g., "FEDFUNDS", "UNRATE")
        title: Human-readable series title
        data: Time series data as pandas Series with DatetimeIndex
        units: Units of measurement (e.g., "Percent", "Billions of Dollars")
        frequency: Data frequency (e.g., "Daily", "Monthly", "Quarterly")
        source: Data provider (e.g., "FRED", "Fed")
        last_updated: When the data was last updated at source
        metadata: Additional metadata from the provider

    Example:
        >>> series = EconomicSeries(
        ...     series_id="FEDFUNDS",
        ...     title="Federal Funds Effective Rate",
        ...     data=pd.Series([5.33, 5.33], index=pd.to_datetime(["2024-01-01", "2024-01-02"])),
        ...     units="Percent",
        ...     frequency="Daily",
        ...     source="FRED"
        ... )
    """
    series_id: str
    title: str
    data: pd.Series
    units: str = "Unknown"
    frequency: str = "Unknown"
    source: str = "Unknown"
    last_updated: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Ensure data has DatetimeIndex."""
        if not isinstance(self.data.index, pd.DatetimeIndex):
            self.data.index = pd.to_datetime(self.data.index)

    def to_dataframe(self) -> pd.DataFrame:
        """Convert to DataFrame with series_id as column name."""
        return self.data.to_frame(name=self.series_id)

    @property
    def start_date(self) -> Optional[datetime]:
        """First observation date."""
        return self.data.index.min() if len(self.data) > 0 else None

    @property
    def end_date(self) -> Optional[datetime]:
        """Last observation date."""
        return self.data.index.max() if len(self.data) > 0 else None


@dataclass
class FetchResult:
    """Result from fetching economic data.

    Attributes:
        success: Whether the fetch succeeded
        series: The fetched series (None if failed)
        error: Error message (None if succeeded)
        cached: Whether data was served from cache
        fetch_time_ms: Time taken to fetch in milliseconds
    """
    success: bool
    series: Optional[EconomicSeries] = None
    error: Optional[str] = None
    cached: bool = False
    fetch_time_ms: float = 0.0


@dataclass
class SeriesInfo:
    """Metadata about an economic series without the actual data.

    Attributes:
        series_id: Unique identifier
        title: Human-readable title
        units: Units of measurement
        frequency: Data frequency
        seasonal_adjustment: Seasonal adjustment status
        observation_start: First available date
        observation_end: Last available date
        popularity: Popularity ranking (FRED-specific)
    """
    series_id: str
    title: str
    units: str = "Unknown"
    frequency: str = "Unknown"
    seasonal_adjustment: str = "Unknown"
    observation_start: Optional[datetime] = None
    observation_end: Optional[datetime] = None
    popularity: int = 0


# Common FRED series IDs for reference
FRED_SERIES = {
    # Fed policy rates
    "FEDFUNDS": "Federal Funds Effective Rate",
    "DFEDTAR": "Federal Funds Target Rate (single target era)",
    "DFEDTARL": "Federal Funds Target Rate Lower Bound",
    "DFEDTARU": "Federal Funds Target Rate Upper Bound",
    "DISCOUNT": "Primary Credit Rate",

    # Treasury yields
    "DGS10": "10-Year Treasury Constant Maturity Rate",
    "DGS2": "2-Year Treasury Constant Maturity Rate",
    "T10Y2Y": "10-Year Treasury Minus 2-Year Treasury",
    "DGS30": "30-Year Treasury Constant Maturity Rate",

    # Inflation indicators
    "CPIAUCSL": "Consumer Price Index for All Urban Consumers",
    "CPILFESL": "Core CPI (Excluding Food and Energy)",
    "PCEPI": "Personal Consumption Expenditures Price Index",
    "PCEPILFE": "Core PCE Price Index",

    # Employment data
    "UNRATE": "Unemployment Rate",
    "PAYEMS": "Total Nonfarm Payrolls",
    "ICSA": "Initial Claims",
    "JTSJOL": "Job Openings",
}
```
  </action>
  <verify>
Run: `python -c "from ta_lab2.integrations.economic.types import EconomicSeries, FetchResult, FRED_SERIES; print(f'Types OK, {len(FRED_SERIES)} series defined')"` succeeds
  </verify>
  <done>types.py created with EconomicSeries, FetchResult, SeriesInfo, and FRED_SERIES reference</done>
</task>

<task type="auto">
  <name>Task 2: Create base.py with provider protocol</name>
  <files>src/ta_lab2/integrations/economic/base.py</files>
  <action>
Create base.py with abstract provider protocol:

```python
"""Base protocol for economic data providers.

Defines the interface that all economic data providers must implement,
enabling consistent usage across different data sources (FRED, Fed, etc.).
"""
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Optional, List

from ta_lab2.integrations.economic.types import EconomicSeries, FetchResult, SeriesInfo


class EconomicDataProvider(ABC):
    """Abstract base class for economic data providers.

    All providers must implement the core methods for fetching series data
    and metadata. Optional methods for search and batch operations have
    default implementations.

    Attributes:
        name: Provider name (e.g., "FRED", "Fed")
        base_url: API base URL

    Example:
        >>> class MyProvider(EconomicDataProvider):
        ...     name = "MySource"
        ...     def get_series(self, series_id, **kwargs):
        ...         # Implementation
        ...         pass
        ...     def get_series_info(self, series_id):
        ...         # Implementation
        ...         pass
    """
    name: str = "Unknown"
    base_url: str = ""

    @abstractmethod
    def get_series(
        self,
        series_id: str,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        **kwargs
    ) -> FetchResult:
        """Fetch time series data for a given series ID.

        Args:
            series_id: Unique identifier for the series (e.g., "FEDFUNDS")
            start_date: Optional start date filter
            end_date: Optional end date filter
            **kwargs: Provider-specific options

        Returns:
            FetchResult with success status and data or error
        """
        pass

    @abstractmethod
    def get_series_info(self, series_id: str) -> Optional[SeriesInfo]:
        """Fetch metadata about a series without the data.

        Args:
            series_id: Unique identifier for the series

        Returns:
            SeriesInfo with metadata, or None if not found
        """
        pass

    def search(self, query: str, limit: int = 10) -> List[SeriesInfo]:
        """Search for series by keyword.

        Default implementation returns empty list. Override for providers
        that support search (e.g., FRED).

        Args:
            query: Search query string
            limit: Maximum number of results

        Returns:
            List of matching SeriesInfo objects
        """
        return []

    def get_multiple_series(
        self,
        series_ids: List[str],
        **kwargs
    ) -> List[FetchResult]:
        """Fetch multiple series.

        Default implementation calls get_series sequentially.
        Override for providers that support batch fetching.

        Args:
            series_ids: List of series IDs to fetch
            **kwargs: Options passed to get_series

        Returns:
            List of FetchResult objects
        """
        return [self.get_series(sid, **kwargs) for sid in series_ids]

    def validate_api_key(self) -> bool:
        """Check if the provider's API key is valid.

        Default implementation returns True. Override for providers
        that require authentication.

        Returns:
            True if API key is valid or not required
        """
        return True

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}(name={self.name})>"
```
  </action>
  <verify>
Run: `python -c "from ta_lab2.integrations.economic.base import EconomicDataProvider; print('Base protocol OK')"` succeeds
  </verify>
  <done>base.py created with EconomicDataProvider abstract base class</done>
</task>

<task type="auto">
  <name>Task 3: Create fred_provider.py with working fredapi passthrough</name>
  <files>src/ta_lab2/integrations/economic/fred_provider.py</files>
  <action>
Create fred_provider.py with working fredapi passthrough (not stub):

```python
"""FRED data provider using fredapi.

Provides a working implementation of EconomicDataProvider that wraps
the fredapi library. Includes graceful degradation when fredapi is
not installed.

Install fredapi with: pip install ta_lab2[fred]
"""
import os
import time
from datetime import datetime
from typing import Optional, List

import pandas as pd

from ta_lab2.integrations.economic.base import EconomicDataProvider
from ta_lab2.integrations.economic.types import (
    EconomicSeries,
    FetchResult,
    SeriesInfo,
)

# Soft import: allow importing module even if fredapi is missing
try:
    from fredapi import Fred
    FREDAPI_AVAILABLE = True
except ImportError:
    Fred = None  # type: ignore
    FREDAPI_AVAILABLE = False


def _ensure_fredapi_available() -> None:
    """Raise clear error if fredapi is not installed."""
    if not FREDAPI_AVAILABLE:
        raise ImportError(
            "fredapi is required for FredProvider. "
            "Install with: pip install ta_lab2[fred] "
            "or: pip install fredapi>=0.5.2"
        )


class FredProvider(EconomicDataProvider):
    """FRED data provider using fredapi.

    Provides access to Federal Reserve Economic Data (FRED) via the
    fredapi library. Supports all standard FRED operations including
    series fetching, search, and metadata retrieval.

    Attributes:
        name: "FRED"
        base_url: "https://api.stlouisfed.org/fred"
        api_key: FRED API key (from constructor or environment)

    Example:
        >>> provider = FredProvider()  # Uses FRED_API_KEY env var
        >>> result = provider.get_series("FEDFUNDS")
        >>> if result.success:
        ...     print(f"Got {len(result.series.data)} observations")

    Note:
        Requires fredapi package: pip install ta_lab2[fred]
        Requires FRED API key: https://fred.stlouisfed.org/docs/api/api_key.html
    """
    name = "FRED"
    base_url = "https://api.stlouisfed.org/fred"

    def __init__(self, api_key: Optional[str] = None):
        """Initialize FRED provider.

        Args:
            api_key: FRED API key. If None, reads from FRED_API_KEY
                     environment variable.

        Raises:
            ImportError: If fredapi is not installed
            ValueError: If no API key provided or found in environment
        """
        _ensure_fredapi_available()

        self.api_key = api_key or os.getenv("FRED_API_KEY")
        if not self.api_key:
            raise ValueError(
                "FRED API key required. Set FRED_API_KEY environment variable "
                "or pass api_key to constructor. "
                "Get key at: https://fred.stlouisfed.org/docs/api/api_key.html"
            )

        self._client = Fred(api_key=self.api_key)

    def get_series(
        self,
        series_id: str,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        **kwargs
    ) -> FetchResult:
        """Fetch time series data from FRED.

        Args:
            series_id: FRED series ID (e.g., "FEDFUNDS", "UNRATE")
            start_date: Optional start date filter
            end_date: Optional end date filter
            **kwargs: Additional options (frequency, aggregation_method, units)

        Returns:
            FetchResult with EconomicSeries on success, error message on failure

        Example:
            >>> result = provider.get_series("UNRATE", start_date=datetime(2020, 1, 1))
            >>> if result.success:
            ...     print(result.series.data.tail())
        """
        start_time = time.time()

        try:
            # Fetch data from FRED
            data = self._client.get_series(
                series_id,
                observation_start=start_date,
                observation_end=end_date,
                **kwargs
            )

            # Get metadata
            info = self._client.get_series_info(series_id)

            # Build EconomicSeries
            series = EconomicSeries(
                series_id=series_id,
                title=info.get("title", series_id),
                data=data,
                units=info.get("units", "Unknown"),
                frequency=info.get("frequency", "Unknown"),
                source="FRED",
                last_updated=pd.to_datetime(info.get("last_updated")),
                metadata=dict(info)
            )

            return FetchResult(
                success=True,
                series=series,
                fetch_time_ms=(time.time() - start_time) * 1000
            )

        except Exception as e:
            return FetchResult(
                success=False,
                error=str(e),
                fetch_time_ms=(time.time() - start_time) * 1000
            )

    def get_series_info(self, series_id: str) -> Optional[SeriesInfo]:
        """Fetch metadata about a FRED series.

        Args:
            series_id: FRED series ID

        Returns:
            SeriesInfo with metadata, or None if not found
        """
        try:
            info = self._client.get_series_info(series_id)
            return SeriesInfo(
                series_id=series_id,
                title=info.get("title", series_id),
                units=info.get("units", "Unknown"),
                frequency=info.get("frequency", "Unknown"),
                seasonal_adjustment=info.get("seasonal_adjustment", "Unknown"),
                observation_start=pd.to_datetime(info.get("observation_start")),
                observation_end=pd.to_datetime(info.get("observation_end")),
                popularity=info.get("popularity", 0)
            )
        except Exception:
            return None

    def search(self, query: str, limit: int = 10) -> List[SeriesInfo]:
        """Search FRED for series matching query.

        Args:
            query: Search query string
            limit: Maximum results to return

        Returns:
            List of matching SeriesInfo objects

        Example:
            >>> results = provider.search("unemployment rate")
            >>> for r in results[:3]:
            ...     print(f"{r.series_id}: {r.title}")
        """
        try:
            results = self._client.search(query)
            if results is None or len(results) == 0:
                return []

            series_list = []
            for _, row in results.head(limit).iterrows():
                series_list.append(SeriesInfo(
                    series_id=row.get("id", row.name) if hasattr(row, "name") else str(row.get("id", "")),
                    title=row.get("title", ""),
                    units=row.get("units", "Unknown"),
                    frequency=row.get("frequency", "Unknown"),
                    seasonal_adjustment=row.get("seasonal_adjustment", "Unknown"),
                    observation_start=pd.to_datetime(row.get("observation_start")),
                    observation_end=pd.to_datetime(row.get("observation_end")),
                    popularity=row.get("popularity", 0)
                ))
            return series_list

        except Exception:
            return []

    def validate_api_key(self) -> bool:
        """Check if the FRED API key is valid.

        Attempts to fetch a known series to verify the key works.

        Returns:
            True if API key is valid
        """
        try:
            # Try to get info for a common series
            self._client.get_series_info("GNPCA")
            return True
        except Exception:
            return False

    def get_releases(self, limit: int = 100) -> List[dict]:
        """Fetch FRED releases metadata.

        Args:
            limit: Maximum number of releases to fetch

        Returns:
            List of release dictionaries
        """
        try:
            # fredapi doesn't expose releases directly, use raw request
            import requests
            response = requests.get(
                f"{self.base_url}/releases",
                params={"api_key": self.api_key, "file_type": "json", "limit": limit},
                timeout=30
            )
            response.raise_for_status()
            return response.json().get("releases", [])
        except Exception:
            return []
```

Create the integrations/economic/ directory structure.
  </action>
  <verify>
Run: `python -c "from ta_lab2.integrations.economic.fred_provider import FredProvider, FREDAPI_AVAILABLE; print(f'FredProvider importable, fredapi available: {FREDAPI_AVAILABLE}')"` succeeds
  </verify>
  <done>fred_provider.py created with working fredapi passthrough implementation</done>
</task>

<task type="auto">
  <name>Task 4: Create package __init__.py with exports</name>
  <files>src/ta_lab2/integrations/economic/__init__.py</files>
  <action>
Create __init__.py that exports the public API:

```python
"""Economic data integration for ta_lab2.

Provides standardized access to economic data from various sources
(FRED, Fed, etc.) with consistent interfaces, optional caching,
rate limiting, and data quality validation.

Providers:
    FredProvider: Federal Reserve Economic Data (requires fredapi)

Install dependencies:
    pip install ta_lab2[fred]       # For FRED only
    pip install ta_lab2[economic]   # For all economic data providers

Example:
    >>> from ta_lab2.integrations.economic import FredProvider
    >>> provider = FredProvider()  # Uses FRED_API_KEY env var
    >>> result = provider.get_series("FEDFUNDS")
    >>> if result.success:
    ...     print(f"Federal Funds Rate: {result.series.data.iloc[-1]:.2f}%")

Types:
    EconomicSeries: Standardized time series data container
    FetchResult: Result wrapper with success/error status
    SeriesInfo: Series metadata without data

Base Classes:
    EconomicDataProvider: Abstract protocol for data providers

See Also:
    .archive/external-packages/2026-02-03/ALTERNATIVES.md - Ecosystem comparison
    ta_lab2.utils.economic - Extracted utilities from fedtools2
"""

from ta_lab2.integrations.economic.types import (
    EconomicSeries,
    FetchResult,
    SeriesInfo,
    FRED_SERIES,
)
from ta_lab2.integrations.economic.base import EconomicDataProvider
from ta_lab2.integrations.economic.fred_provider import (
    FredProvider,
    FREDAPI_AVAILABLE,
)

__all__ = [
    # Types
    "EconomicSeries",
    "FetchResult",
    "SeriesInfo",
    "FRED_SERIES",
    # Base
    "EconomicDataProvider",
    # Providers
    "FredProvider",
    "FREDAPI_AVAILABLE",
]
```

Also create the parent integrations/__init__.py if it doesn't exist:

```python
"""ta_lab2 integrations package.

Contains integration modules for external data sources and services.

Subpackages:
    economic: FRED and Fed data integration
"""
```
  </action>
  <verify>
Run: `python -c "from ta_lab2.integrations.economic import FredProvider, EconomicSeries, FRED_SERIES; print(f'Exports OK, {len(FRED_SERIES)} series defined')"` succeeds
  </verify>
  <done>Package __init__.py created with all exports, integrations package initialized</done>
</task>

</tasks>

<verification>
1. Directory exists: src/ta_lab2/integrations/economic/
2. types.py defines EconomicSeries, FetchResult, SeriesInfo, FRED_SERIES
3. base.py defines EconomicDataProvider abstract class
4. fred_provider.py implements FredProvider with working fredapi passthrough
5. __init__.py exports all public API
6. FredProvider is importable: `from ta_lab2.integrations.economic import FredProvider`
7. Graceful degradation when fredapi not installed (FREDAPI_AVAILABLE=False)
8. FRED_SERIES includes all 4 context-required categories (Fed policy, Treasury, Inflation, Employment)
</verification>

<success_criteria>
- ta_lab2.integrations.economic module created with provider pattern
- FredProvider actually works (wraps fredapi, not stub)
- EconomicDataProvider protocol enables future providers
- Types provide consistent data structures
- Graceful degradation when fredapi not installed
- FRED_SERIES reference includes all priority data categories from context
</success_criteria>

<output>
After completion, create `.planning/phases/15-economic-data-strategy/15-03-SUMMARY.md`
</output>
