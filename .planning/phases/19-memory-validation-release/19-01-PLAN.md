---
phase: 19-memory-validation-release
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/memory/indexing.py
  - src/ta_lab2/tools/ai_orchestrator/memory/__init__.py
autonomous: true

must_haves:
  truths:
    - "AST-based function extraction works on Python files"
    - "Function signatures include params, types, return types, defaults"
    - "Both src/ and tests/ can be indexed"
    - "Extracted functions stored in memory with function_definition category"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/memory/indexing.py"
      provides: "Function extraction using ast.NodeVisitor"
      exports: ["FunctionExtractor", "extract_functions", "index_codebase_functions"]
  key_links:
    - from: "indexing.py"
      to: "mem0_client.py"
      via: "add memories with function_definition category"
      pattern: "add_memory.*category.*function_definition"
---

<objective>
Create AST-based function extraction and memory indexing

Purpose: Extract all significant Python functions with full signatures (name, params, types, return, docstring) and index them in memory with function_definition category to enable queries like "What does function X do?" and "What uses function X?"

Output: indexing.py module with FunctionExtractor class and index_codebase_functions function
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-memory-validation-release/19-CONTEXT.md
@.planning/phases/19-memory-validation-release/19-RESEARCH.md

# Existing memory module (add new file here)
@src/ta_lab2/tools/ai_orchestrator/memory/__init__.py
@src/ta_lab2/tools/ai_orchestrator/memory/mem0_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FunctionExtractor using ast.NodeVisitor</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/indexing.py</files>
  <action>
Create indexing.py with AST-based function extraction following the research patterns:

```python
"""Function extraction and memory indexing using AST.

Extracts function definitions with full signatures for memory indexing.
Supports src/ and tests/ directories, filtering by significance threshold.

Usage:
    from ta_lab2.tools.ai_orchestrator.memory.indexing import (
        extract_functions,
        index_codebase_functions
    )

    # Extract from single file
    functions = extract_functions(Path("src/ta_lab2/features/ema.py"))

    # Index entire codebase to memory
    result = index_codebase_functions(Path("src/ta_lab2"))
"""
```

1. **FunctionInfo dataclass:**
   - name: str
   - file_path: str (relative to project root)
   - lineno: int
   - docstring: Optional[str]
   - parameters: List[Dict] with name, annotation, default
   - return_annotation: Optional[str]
   - is_async: bool
   - source: str (full function source via ast.unparse)
   - is_test: bool (True if function name starts with "test_")

2. **FunctionExtractor(ast.NodeVisitor):**
   - visit_FunctionDef and visit_AsyncFunctionDef
   - Extract full parameter info including *args, **kwargs
   - Handle defaults (right-aligned with args)
   - Handle keyword-only args and their defaults
   - Extract decorators (store names only)
   - Filter by significance: include if docstring OR >= 3 lines OR name doesn't start with "_"

3. **extract_functions(file_path: Path) -> List[FunctionInfo]:**
   - Parse file with ast.parse()
   - Run FunctionExtractor visitor
   - Return list of FunctionInfo objects
   - Handle SyntaxError gracefully (log and return empty list)

4. **index_codebase_functions(root: Path, include_tests: bool = True) -> IndexingResult:**
   - Walk root directory for .py files
   - Skip __pycache__, .venv, .git directories
   - Extract functions from each file
   - Add to memory via Mem0Client with:
    - category: "function_definition"
    - file: relative path
    - function_name: name
    - lineno: line number
    - has_docstring: bool
    - is_test: bool
    - is_async: bool
   - Use infer=False for batch performance (per Phase 11 patterns)
   - Return IndexingResult with total_files, total_functions, errors

Use only stdlib (ast, pathlib, dataclasses, typing). Follow existing memory module patterns.
  </action>
  <verify>
`python -c "from ta_lab2.tools.ai_orchestrator.memory.indexing import FunctionExtractor, extract_functions; print('Import OK')"`
  </verify>
  <done>FunctionExtractor class extracts function signatures with full metadata including params, types, defaults, docstrings</done>
</task>

<task type="auto">
  <name>Task 2: Add indexing exports to memory __init__.py</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/__init__.py</files>
  <action>
Add indexing module exports to memory package __init__.py:

1. Add import at appropriate location (after existing imports):
   ```python
   from .indexing import (
       FunctionInfo,
       FunctionExtractor,
       extract_functions,
       index_codebase_functions,
       IndexingResult,
   )
   ```

2. Add to __all__ list in "# Indexing" section:
   ```python
   # Indexing
   "FunctionInfo",
   "FunctionExtractor",
   "extract_functions",
   "index_codebase_functions",
   "IndexingResult",
   ```

3. Update module docstring to mention function indexing capability:
   - Add to Quick start example: "Index functions: result = index_codebase_functions(Path('src'))"
  </action>
  <verify>
`python -c "from ta_lab2.tools.ai_orchestrator.memory import extract_functions, index_codebase_functions; print('Package exports OK')"`
  </verify>
  <done>indexing module exports available from memory package</done>
</task>

<task type="auto">
  <name>Task 3: Test function extraction on sample files</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/indexing.py</files>
  <action>
Add a simple validation at module level (guarded by __name__ == "__main__"):

```python
if __name__ == "__main__":
    # Quick validation
    from pathlib import Path

    # Test on a known file
    test_file = Path(__file__).parent / "client.py"
    if test_file.exists():
        functions = extract_functions(test_file)
        print(f"Extracted {len(functions)} functions from {test_file.name}")
        for func in functions[:3]:
            print(f"  - {func.name}({len(func.parameters)} params)")

    # Test on memory module
    memory_dir = Path(__file__).parent
    result = index_codebase_functions(memory_dir, include_tests=False)
    print(f"\nIndexing result: {result.total_files} files, {result.total_functions} functions")
```

Run validation to ensure extraction works:
- Should extract functions from client.py (MemoryClient class methods)
- Should handle both sync and async functions
- Should capture parameters with types and defaults

Note: This is a dry-run test - actual memory indexing happens in Plan 19-02 after relationships are set up.
  </action>
  <verify>
`python -m ta_lab2.tools.ai_orchestrator.memory.indexing` runs without errors and shows extracted functions
  </verify>
  <done>Function extraction validated on actual codebase files</done>
</task>

</tasks>

<verification>
1. `python -c "from ta_lab2.tools.ai_orchestrator.memory.indexing import FunctionExtractor; print('OK')"` passes
2. `python -c "from ta_lab2.tools.ai_orchestrator.memory import extract_functions; print('OK')"` passes
3. `python -m ta_lab2.tools.ai_orchestrator.memory.indexing` extracts functions successfully
4. FunctionInfo includes all signature details (params, types, defaults, docstring)
</verification>

<success_criteria>
- FunctionExtractor class uses ast.NodeVisitor pattern
- extract_functions() returns FunctionInfo with full signatures
- index_codebase_functions() can walk directory tree and extract all functions
- Exports available from memory package __init__.py
- No new dependencies (stdlib only: ast, pathlib, dataclasses, typing)
</success_criteria>

<output>
After completion, create `.planning/phases/19-memory-validation-release/19-01-SUMMARY.md`
</output>
