---
phase: 19-memory-validation-release
plan: 02
type: execute
wave: 2
depends_on: [19-01]
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/memory/relationships.py
  - src/ta_lab2/tools/ai_orchestrator/memory/__init__.py
autonomous: true

must_haves:
  truths:
    - "Relationship types supported: contains, calls, imports, moved_to, similar_to"
    - "File-to-function 'contains' relationships created"
    - "Function-to-function 'calls' relationships detected via AST analysis"
    - "Memory can be queried by relationship type"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/memory/relationships.py"
      provides: "Relationship detection and memory linking"
      exports: ["RelationshipType", "Relationship", "detect_calls", "create_relationship_memory", "link_codebase_relationships"]
  key_links:
    - from: "relationships.py"
      to: "indexing.py"
      via: "uses extracted function info"
      pattern: "from .indexing import"
    - from: "relationships.py"
      to: "mem0_client.py"
      via: "adds relationship memories"
      pattern: "add_memory.*function_relationship"
---

<objective>
Create relationship detection and memory linking module

Purpose: Implement all relationship types (contains, calls, imports, moved_to, similar_to) to enable memory graph queries like "What functions does X call?" and "What files were moved during reorganization?"

Output: relationships.py module with relationship detection and memory linking functions
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-memory-validation-release/19-CONTEXT.md
@.planning/phases/19-memory-validation-release/19-RESEARCH.md

# Function extraction from Plan 19-01
@src/ta_lab2/tools/ai_orchestrator/memory/indexing.py
@src/ta_lab2/tools/ai_orchestrator/memory/__init__.py
@src/ta_lab2/tools/ai_orchestrator/memory/mem0_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create relationship types and detection module</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/relationships.py</files>
  <action>
Create relationships.py with relationship detection and linking:

```python
"""Relationship detection and memory linking.

Detects and stores relationships between code entities:
- contains: file contains function
- calls: function A calls function B
- imports: file imports module
- moved_to: file/function moved during reorganization
- similar_to: functions with high similarity (set by duplicate detection)

Usage:
    from ta_lab2.tools.ai_orchestrator.memory.relationships import (
        detect_calls,
        link_codebase_relationships
    )

    # Detect call relationships in a file
    calls = detect_calls(Path("src/ta_lab2/features/ema.py"))

    # Link all relationships for indexed functions
    result = link_codebase_relationships(Path("src/ta_lab2"))
"""
```

1. **RelationshipType enum:**
   - CONTAINS = "contains"
   - CALLS = "calls"
   - IMPORTS = "imports"
   - MOVED_TO = "moved_to"
   - SIMILAR_TO = "similar_to"

2. **Relationship dataclass:**
   - relationship_type: RelationshipType
   - source_file: str
   - source_entity: Optional[str] (function name for calls, None for file-level)
   - target_file: str
   - target_entity: Optional[str]
   - metadata: Dict[str, Any] (similarity score, move date, etc.)

3. **CallDetector(ast.NodeVisitor):**
   - Visit ast.Call nodes
   - Extract called function names (handle Name, Attribute nodes)
   - Track current function context (which function is making the call)
   - Return List[Tuple[caller_func, called_func]]

4. **detect_calls(file_path: Path) -> List[Relationship]:**
   - Parse file with AST
   - Run CallDetector
   - Return CALLS relationships

5. **detect_imports(file_path: Path) -> List[Relationship]:**
   - Parse file with AST
   - Extract ast.Import and ast.ImportFrom nodes
   - Return IMPORTS relationships with module names

6. **create_contains_relationships(file_path: Path, functions: List[FunctionInfo]) -> List[Relationship]:**
   - For each function extracted from file
   - Create CONTAINS relationship (file -> function)

7. **create_relationship_memory(relationship: Relationship, client: Mem0Client) -> str:**
   - Create memory entry with:
    - category: "function_relationship"
    - relationship_type: relationship.relationship_type.value
    - source_file, source_function (or source_entity)
    - target_file, target_function (or target_entity)
    - Additional metadata from relationship.metadata
   - Use infer=False for performance
   - Return memory ID

8. **link_codebase_relationships(root: Path, client: Mem0Client = None) -> LinkingResult:**
   - Walk directory for .py files
   - For each file: detect_calls(), detect_imports(), create_contains_relationships()
   - Batch add all relationships to memory
   - Return LinkingResult with counts by type

Use only stdlib (ast, pathlib, dataclasses, typing, enum). Integrate with existing indexing.py.
  </action>
  <verify>
`python -c "from ta_lab2.tools.ai_orchestrator.memory.relationships import RelationshipType, detect_calls; print('Import OK')"`
  </verify>
  <done>Relationship detection module created with all five relationship types</done>
</task>

<task type="auto">
  <name>Task 2: Add relationship exports to memory __init__.py</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/__init__.py</files>
  <action>
Add relationship module exports to memory package __init__.py:

1. Add import after indexing imports:
   ```python
   from .relationships import (
       RelationshipType,
       Relationship,
       detect_calls,
       detect_imports,
       create_contains_relationships,
       create_relationship_memory,
       link_codebase_relationships,
       LinkingResult,
   )
   ```

2. Add to __all__ list in "# Relationships" section:
   ```python
   # Relationships
   "RelationshipType",
   "Relationship",
   "detect_calls",
   "detect_imports",
   "create_contains_relationships",
   "create_relationship_memory",
   "link_codebase_relationships",
   "LinkingResult",
   ```

3. Update module docstring to mention relationship linking capability
  </action>
  <verify>
`python -c "from ta_lab2.tools.ai_orchestrator.memory import RelationshipType, link_codebase_relationships; print('Package exports OK')"`
  </verify>
  <done>relationships module exports available from memory package</done>
</task>

<task type="auto">
  <name>Task 3: Validate relationship detection on sample files</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/relationships.py</files>
  <action>
Add validation at module level (guarded by __name__ == "__main__"):

```python
if __name__ == "__main__":
    from pathlib import Path

    # Test call detection on a known file with function calls
    test_file = Path(__file__).parent / "client.py"
    if test_file.exists():
        calls = detect_calls(test_file)
        print(f"Detected {len(calls)} call relationships in {test_file.name}")
        for rel in calls[:5]:
            print(f"  - {rel.source_entity} calls {rel.target_entity}")

        imports = detect_imports(test_file)
        print(f"Detected {len(imports)} import relationships")
        for rel in imports[:5]:
            print(f"  - imports {rel.target_entity}")

    # Test on memory module (dry run - no actual memory writes)
    print("\nDry run summary:")
    memory_dir = Path(__file__).parent
    from .indexing import extract_functions
    total_contains = 0
    total_calls = 0
    for py_file in memory_dir.glob("*.py"):
        functions = extract_functions(py_file)
        total_contains += len(functions)
        total_calls += len(detect_calls(py_file))
    print(f"  Contains relationships: {total_contains}")
    print(f"  Calls relationships: {total_calls}")
```

This validates:
- Call detection works (finds function calls within functions)
- Import detection works (finds import statements)
- Contains relationships can be derived from extracted functions

Note: Actual memory writes happen during full indexing, not in this test.
  </action>
  <verify>
`python -m ta_lab2.tools.ai_orchestrator.memory.relationships` runs and shows detected relationships
  </verify>
  <done>Relationship detection validated - call, import, contains relationships detected</done>
</task>

</tasks>

<verification>
1. `python -c "from ta_lab2.tools.ai_orchestrator.memory.relationships import RelationshipType; print('OK')"` passes
2. `python -c "from ta_lab2.tools.ai_orchestrator.memory import detect_calls; print('OK')"` passes
3. `python -m ta_lab2.tools.ai_orchestrator.memory.relationships` detects relationships successfully
4. All five relationship types defined (contains, calls, imports, moved_to, similar_to)
5. CallDetector extracts function-to-function call relationships
</verification>

<success_criteria>
- RelationshipType enum with all five types
- detect_calls() extracts function-to-function calls via AST
- detect_imports() extracts file-to-module imports
- create_relationship_memory() stores relationships with proper metadata
- link_codebase_relationships() can process entire directory
- No new dependencies (stdlib only)
</success_criteria>

<output>
After completion, create `.planning/phases/19-memory-validation-release/19-02-SUMMARY.md`
</output>
