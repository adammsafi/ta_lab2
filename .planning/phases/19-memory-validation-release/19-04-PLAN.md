---
phase: 19-memory-validation-release
plan: 04
type: execute
wave: 3
depends_on: [19-02, 19-03]
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/memory/graph_validation.py
  - src/ta_lab2/tools/ai_orchestrator/memory/query_validation.py
  - src/ta_lab2/tools/ai_orchestrator/memory/__init__.py
autonomous: true

must_haves:
  truths:
    - "Memory graph validation detects orphaned memories"
    - "Orphan rate threshold validated (5% default, configurable)"
    - "All relationship targets verified to exist"
    - "Query validation tests essential query types"
    - "Function lookup, cross-reference, edit impact queries work"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/memory/graph_validation.py"
      provides: "Memory graph integrity validation with orphan detection"
      exports: ["MemoryGraphValidation", "validate_memory_graph"]
    - path: "src/ta_lab2/tools/ai_orchestrator/memory/query_validation.py"
      provides: "Query capability validation"
      exports: ["QueryValidation", "validate_queries"]
  key_links:
    - from: "graph_validation.py"
      to: "mem0_client.py"
      via: "queries memory for validation"
      pattern: "search_memories|get_all"
    - from: "query_validation.py"
      to: "graph_validation.py"
      via: "combined validation"
      pattern: "from .graph_validation import"
---

<objective>
Create memory graph validation and query capability tests

Purpose: Validate memory graph integrity (orphan detection, relationship target verification) and test query capabilities (function lookup, cross-reference, edit impact analysis) to ensure memory system is complete and functional before v0.5.0 release.

Output: graph_validation.py and query_validation.py modules with validation functions
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-memory-validation-release/19-CONTEXT.md
@.planning/phases/19-memory-validation-release/19-RESEARCH.md

# Memory modules from Plans 19-01 through 19-03
@src/ta_lab2/tools/ai_orchestrator/memory/__init__.py
@src/ta_lab2/tools/ai_orchestrator/memory/mem0_client.py
@src/ta_lab2/tools/ai_orchestrator/memory/query.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory graph validation module</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/graph_validation.py</files>
  <action>
Create graph_validation.py following the research patterns:

```python
"""Memory graph validation with orphan detection.

Validates memory graph integrity:
- Orphan detection (memories with no relationships)
- Relationship target verification (all targets exist)
- Coverage metrics (% of functions with relationships)

Usage:
    from ta_lab2.tools.ai_orchestrator.memory.graph_validation import (
        validate_memory_graph
    )

    result = validate_memory_graph(max_orphan_rate=0.05)
    if result.is_valid:
        print("Memory graph validation passed")
    else:
        print(f"Validation failed: {result.failure_reasons}")
"""
```

1. **MemoryGraphValidation dataclass:**
   - total_functions: int
   - total_relationships: int
   - relationship_breakdown: Dict[str, int]  # by type (contains, calls, etc.)
   - orphaned_functions: List[str]  # file::function format
   - orphan_rate: float
   - missing_targets: List[str]  # relationships pointing to non-existent entities
   - relationship_coverage: float  # % of functions with at least one relationship
   - is_valid: bool
   - failure_reasons: List[str]

   Methods:
   - markdown_report() -> str: Generate report for VALIDATION.md

2. **get_all_function_memories(client: Mem0Client) -> List[Dict]:**
   - Query memories with category="function_definition"
   - Handle pagination (limit=1000 per query, continue until exhausted)
   - Return list of memory payloads

3. **get_all_relationship_memories(client: Mem0Client) -> List[Dict]:**
   - Query memories with category="function_relationship"
   - Handle pagination
   - Return list of memory payloads

4. **detect_orphans(functions: List[Dict], relationships: List[Dict]) -> List[str]:**
   - Build set of functions mentioned in any relationship (source or target)
   - Find functions NOT in that set
   - Filter out acceptable orphans:
     - Functions in __init__.py (exports, not logic)
     - Functions < 3 lines (trivial helpers)
     - Constants/config functions
   - Return list of orphaned function identifiers

5. **verify_relationship_targets(functions: List[Dict], relationships: List[Dict]) -> List[str]:**
   - Build function index (file::name -> exists)
   - Check each relationship's target exists in index
   - Return list of missing targets

6. **validate_memory_graph(client: Mem0Client = None, max_orphan_rate: float = 0.05, max_orphan_rate_tests: float = 0.10) -> MemoryGraphValidation:**
   - Get all function and relationship memories
   - Detect orphans (use higher threshold for tests)
   - Verify relationship targets
   - Calculate metrics
   - Determine is_valid:
     - orphan_rate <= threshold
     - missing_targets == 0
     - total_relationships > 0
   - Return validation result

Use Mem0Client from existing module (don't import Qdrant directly).
  </action>
  <verify>
`python -c "from ta_lab2.tools.ai_orchestrator.memory.graph_validation import validate_memory_graph, MemoryGraphValidation; print('Import OK')"`
  </verify>
  <done>Memory graph validation module created with orphan detection and target verification</done>
</task>

<task type="auto">
  <name>Task 2: Create query validation module</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/query_validation.py</files>
  <action>
Create query_validation.py to test essential query capabilities:

```python
"""Query capability validation.

Tests memory system query capabilities:
1. Function lookup: "What does function X do?"
2. Cross-reference: "What calls function X?"
3. Edit impact: "What would be affected if I change file Y?"
4. Similar functions: "What functions are similar to X?"
5. File inventory: "What functions are in file Z?"

Usage:
    from ta_lab2.tools.ai_orchestrator.memory.query_validation import (
        validate_queries
    )

    result = validate_queries()
    print(f"Query validation: {result.passed_count}/{result.total_count} passed")
"""
```

1. **QueryTest dataclass:**
   - name: str
   - query_type: str  # "function_lookup", "cross_reference", "edit_impact", "similar", "inventory"
   - query: str  # actual query text
   - expected_behavior: str  # what should happen
   - passed: bool
   - result_count: int
   - error: Optional[str]

2. **QueryValidation dataclass:**
   - tests: List[QueryTest]
   - total_count: int
   - passed_count: int
   - failed_count: int
   - is_valid: bool
   - failure_reasons: List[str]

   Methods:
   - markdown_report() -> str: Generate report for VALIDATION.md

3. **test_function_lookup(client: Mem0Client) -> QueryTest:**
   - Query: search for a known function (e.g., "get_mem0_client")
   - Pass if: results include the function with docstring/details
   - Use semantic search via existing search_memories()

4. **test_cross_reference(client: Mem0Client) -> QueryTest:**
   - Query: "What calls search_memories?"
   - Pass if: results include functions that call it (relationship lookup)
   - Search for relationship_type="calls" with target="search_memories"

5. **test_edit_impact(client: Mem0Client) -> QueryTest:**
   - Query: "What would be affected by changing client.py?"
   - Pass if: results include functions that import from or call functions in client.py
   - Combine contains relationships for file + calls to those functions

6. **test_similar_functions(client: Mem0Client) -> QueryTest:**
   - Query: "What functions are similar to MemoryClient.search?"
   - Pass if: returns results (even if empty list is valid for unique functions)
   - Search for relationship_type="similar_to"

7. **test_file_inventory(client: Mem0Client) -> QueryTest:**
   - Query: "What functions are in mem0_client.py?"
   - Pass if: returns list of functions with contains relationships
   - Filter by source_file in relationship metadata

8. **validate_queries(client: Mem0Client = None, min_pass_rate: float = 0.80) -> QueryValidation:**
   - Run all 5 query tests
   - Collect results
   - is_valid = (passed_count / total_count) >= min_pass_rate
   - Return validation result

Each test should:
- Be self-documenting (what it tests and why)
- Handle empty results gracefully
- Log warnings for unexpected results but don't fail on edge cases
  </action>
  <verify>
`python -c "from ta_lab2.tools.ai_orchestrator.memory.query_validation import validate_queries, QueryValidation; print('Import OK')"`
  </verify>
  <done>Query validation module created with five essential query tests</done>
</task>

<task type="auto">
  <name>Task 3: Add validation exports to memory __init__.py</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/__init__.py</files>
  <action>
Add graph and query validation exports to memory package __init__.py:

1. Add imports after similarity imports:
   ```python
   from .graph_validation import (
       MemoryGraphValidation,
       validate_memory_graph,
   )
   from .query_validation import (
       QueryTest,
       QueryValidation,
       validate_queries,
   )
   ```

2. Add to __all__ list in "# Graph Validation" and "# Query Validation" sections:
   ```python
   # Graph Validation
   "MemoryGraphValidation",
   "validate_memory_graph",
   # Query Validation
   "QueryTest",
   "QueryValidation",
   "validate_queries",
   ```

3. Update module docstring to mention validation capabilities:
   - Add: "Validate memory: result = validate_memory_graph()"
   - Add: "Test queries: result = validate_queries()"
  </action>
  <verify>
`python -c "from ta_lab2.tools.ai_orchestrator.memory import validate_memory_graph, validate_queries; print('Package exports OK')"`
  </verify>
  <done>graph_validation and query_validation exports available from memory package</done>
</task>

</tasks>

<verification>
1. `python -c "from ta_lab2.tools.ai_orchestrator.memory.graph_validation import validate_memory_graph; print('OK')"` passes
2. `python -c "from ta_lab2.tools.ai_orchestrator.memory.query_validation import validate_queries; print('OK')"` passes
3. `python -c "from ta_lab2.tools.ai_orchestrator.memory import MemoryGraphValidation, QueryValidation; print('OK')"` passes
4. MemoryGraphValidation.markdown_report() generates valid markdown
5. QueryValidation.markdown_report() generates valid markdown
</verification>

<success_criteria>
- validate_memory_graph() detects orphans and verifies relationship targets
- validate_queries() tests all five query types (lookup, cross-ref, impact, similar, inventory)
- Both return is_valid boolean with clear pass/fail criteria
- Both generate markdown_report() for VALIDATION.md
- Configurable thresholds (orphan rate, pass rate)
- Uses existing memory infrastructure (Mem0Client, search_memories)
</success_criteria>

<output>
After completion, create `.planning/phases/19-memory-validation-release/19-04-SUMMARY.md`
</output>
