---
phase: 02-memory-core-chromadb-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/memory/__init__.py
  - src/ta_lab2/tools/ai_orchestrator/memory/client.py
  - src/ta_lab2/tools/ai_orchestrator/memory/validation.py
  - src/ta_lab2/tools/ai_orchestrator/config.py
  - tests/orchestrator/test_memory_client.py
autonomous: true

must_haves:
  truths:
    - "ChromaDB collection loads without errors"
    - "Validation reports 3,763+ memories"
    - "Embedding dimensions verified as 1536"
    - "Distance metric is cosine (or documented if L2)"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/memory/client.py"
      provides: "MemoryClient class wrapping ChromaDB"
      exports: ["MemoryClient", "get_memory_client"]
    - path: "src/ta_lab2/tools/ai_orchestrator/memory/validation.py"
      provides: "Integrity validation for ChromaDB store"
      exports: ["validate_memory_store", "MemoryValidationResult"]
    - path: "tests/orchestrator/test_memory_client.py"
      provides: "Client and validation tests"
      min_lines: 50
  key_links:
    - from: "src/ta_lab2/tools/ai_orchestrator/memory/client.py"
      to: "ChromaDB at C:/Users/asafi/Documents/ProjectTT/ChatGPT/20251228/out/chromadb"
      via: "PersistentClient path from config"
      pattern: "chromadb\\.PersistentClient"
    - from: "src/ta_lab2/tools/ai_orchestrator/memory/validation.py"
      to: "memory/client.py"
      via: "MemoryClient import"
      pattern: "from.*client.*import.*MemoryClient"
---

<objective>
ChromaDB client wrapper and integrity validation for existing 3,763 memories

Purpose: Establish foundational memory access layer that validates existing ChromaDB store before building search/injection features. This ensures we're building on a solid foundation with correct embedding dimensions and distance metrics.

Output: MemoryClient class, validation module, comprehensive tests proving 3,763 memories are accessible with correct configuration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-memory-core-chromadb-integration/02-RESEARCH.md

# Phase 1 foundation provides config management
@src/ta_lab2/tools/ai_orchestrator/config.py
@src/ta_lab2/tools/ai_orchestrator/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ChromaDB configuration to config.py</name>
  <files>src/ta_lab2/tools/ai_orchestrator/config.py</files>
  <action>
Extend OrchestratorConfig dataclass with ChromaDB settings:

1. Add chromadb_path field (str) defaulting to "C:/Users/asafi/Documents/ProjectTT/ChatGPT/20251228/out/chromadb"
2. Add chromadb_collection_name field (str) defaulting to "project_memories"
3. Add expected_memory_count field (int) defaulting to 3763
4. Add embedding_dimensions field (int) defaulting to 1536

Update load_config() to read from environment variables:
- CHROMADB_PATH
- CHROMADB_COLLECTION_NAME
- EXPECTED_MEMORY_COUNT
- EMBEDDING_DIMENSIONS

Log warning if CHROMADB_PATH does not exist on disk (use pathlib.Path.exists()).
  </action>
  <verify>Run `python -c "from ta_lab2.tools.ai_orchestrator.config import load_config; c = load_config(); print(c.chromadb_path, c.chromadb_collection_name)"` - should print path and collection name</verify>
  <done>Config module extended with ChromaDB settings, environment variable loading works</done>
</task>

<task type="auto">
  <name>Task 2: Create MemoryClient wrapper for ChromaDB</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/__init__.py, src/ta_lab2/tools/ai_orchestrator/memory/client.py</files>
  <action>
Create memory/client.py with MemoryClient class:

```python
"""ChromaDB client wrapper for ta_lab2 memory system."""
import logging
from typing import Optional
import chromadb
from chromadb.api.models.Collection import Collection

logger = logging.getLogger(__name__)

class MemoryClient:
    """Singleton wrapper for ChromaDB PersistentClient.

    Provides thread-safe access to the project_memories collection.
    Use get_memory_client() factory function for access.
    """

    _instance: Optional["MemoryClient"] = None

    def __init__(self, chroma_path: str, collection_name: str = "project_memories"):
        """Initialize ChromaDB client.

        Args:
            chroma_path: Path to ChromaDB persistent storage
            collection_name: Name of collection to use
        """
        self._client = chromadb.PersistentClient(path=chroma_path)
        self._collection_name = collection_name
        self._collection: Optional[Collection] = None
        logger.info(f"MemoryClient initialized with path: {chroma_path}")

    @property
    def collection(self) -> Collection:
        """Get or create the collection."""
        if self._collection is None:
            self._collection = self._client.get_collection(name=self._collection_name)
            logger.info(f"Loaded collection: {self._collection_name}")
        return self._collection

    @property
    def client(self) -> chromadb.ClientAPI:
        """Access underlying ChromaDB client."""
        return self._client

    def count(self) -> int:
        """Return total memory count."""
        return self.collection.count()

    def get_metadata(self) -> dict:
        """Return collection metadata including distance metric."""
        return self.collection.metadata or {}


def get_memory_client(config=None) -> MemoryClient:
    """Factory function to get or create MemoryClient singleton.

    Args:
        config: Optional OrchestratorConfig. If None, loads from environment.

    Returns:
        MemoryClient instance
    """
    if MemoryClient._instance is None:
        if config is None:
            from ta_lab2.tools.ai_orchestrator.config import load_config
            config = load_config()
        MemoryClient._instance = MemoryClient(
            chroma_path=config.chromadb_path,
            collection_name=config.chromadb_collection_name
        )
    return MemoryClient._instance


def reset_memory_client():
    """Reset singleton for testing. Do not use in production."""
    MemoryClient._instance = None
```

Create memory/__init__.py with exports:
```python
"""Memory integration for AI orchestrator."""
from .client import MemoryClient, get_memory_client, reset_memory_client

__all__ = ["MemoryClient", "get_memory_client", "reset_memory_client"]
```
  </action>
  <verify>Run `python -c "from ta_lab2.tools.ai_orchestrator.memory import get_memory_client; c = get_memory_client(); print(f'Count: {c.count()}')"` - should print memory count</verify>
  <done>MemoryClient singleton provides access to ChromaDB collection, count() method returns 3,763+</done>
</task>

<task type="auto">
  <name>Task 3: Create memory validation module</name>
  <files>src/ta_lab2/tools/ai_orchestrator/memory/validation.py, src/ta_lab2/tools/ai_orchestrator/memory/__init__.py</files>
  <action>
Create memory/validation.py with validation functions:

```python
"""Validation utilities for ChromaDB memory store integrity."""
import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional

from .client import MemoryClient, get_memory_client

logger = logging.getLogger(__name__)


@dataclass
class MemoryValidationResult:
    """Result of memory store validation."""

    is_valid: bool
    total_count: int
    expected_count: int
    sample_valid: bool
    metadata_complete: bool
    distance_metric: str
    embedding_dimensions: int
    issues: List[str] = field(default_factory=list)
    validated_at: datetime = field(default_factory=datetime.now)

    def __str__(self) -> str:
        status = "VALID" if self.is_valid else "INVALID"
        return (
            f"MemoryValidation: {status}\n"
            f"  Count: {self.total_count}/{self.expected_count}\n"
            f"  Distance: {self.distance_metric}\n"
            f"  Dimensions: {self.embedding_dimensions}\n"
            f"  Issues: {len(self.issues)}"
        )


def validate_memory_store(
    client: Optional[MemoryClient] = None,
    expected_count: int = 3763,
    expected_dimensions: int = 1536,
    sample_size: int = 10
) -> MemoryValidationResult:
    """Validate ChromaDB memory store integrity.

    Checks:
    1. Total count matches expected (3,763 memories)
    2. Sample embeddings have correct dimensions (1536)
    3. Sample metadata contains required fields
    4. Distance metric configuration (should be cosine)

    Args:
        client: MemoryClient instance. If None, uses get_memory_client().
        expected_count: Expected number of memories
        expected_dimensions: Expected embedding dimensions
        sample_size: Number of samples to validate

    Returns:
        MemoryValidationResult with validation details
    """
    if client is None:
        client = get_memory_client()

    issues = []
    collection = client.collection

    # Check 1: Count validation
    actual_count = collection.count()
    count_valid = actual_count >= expected_count
    if not count_valid:
        issues.append(f"Count mismatch: expected >={expected_count}, got {actual_count}")

    # Check 2: Distance metric
    metadata = collection.metadata or {}
    distance_metric = metadata.get("hnsw:space", "l2")  # ChromaDB defaults to L2
    if distance_metric != "cosine":
        issues.append(f"Distance metric is '{distance_metric}', recommended 'cosine' for text embeddings")

    # Check 3: Sample embedding dimensions
    sample_results = collection.get(
        limit=sample_size,
        include=["embeddings", "metadatas", "documents"]
    )

    sample_valid = True
    detected_dimensions = 0

    if sample_results["embeddings"]:
        for i, emb in enumerate(sample_results["embeddings"]):
            if emb is None:
                issues.append(f"Sample {i}: embedding is None")
                sample_valid = False
            elif len(emb) != expected_dimensions:
                issues.append(f"Sample {i}: dimension {len(emb)}, expected {expected_dimensions}")
                sample_valid = False
            else:
                detected_dimensions = len(emb)
    else:
        issues.append("No embeddings returned in sample")
        sample_valid = False

    # Check 4: Metadata completeness
    metadata_complete = True
    for i, meta in enumerate(sample_results.get("metadatas", [])):
        if not meta:
            issues.append(f"Sample {i}: metadata is empty")
            metadata_complete = False

    # Determine overall validity
    # Note: We don't fail on L2 distance (just warn) since existing data may use it
    is_valid = count_valid and sample_valid and metadata_complete

    result = MemoryValidationResult(
        is_valid=is_valid,
        total_count=actual_count,
        expected_count=expected_count,
        sample_valid=sample_valid,
        metadata_complete=metadata_complete,
        distance_metric=distance_metric,
        embedding_dimensions=detected_dimensions if detected_dimensions else expected_dimensions,
        issues=issues
    )

    logger.info(f"Memory validation complete: {result}")
    return result


def quick_health_check(client: Optional[MemoryClient] = None) -> bool:
    """Quick health check for memory store.

    Returns True if store is accessible and has memories.
    Use validate_memory_store() for detailed validation.
    """
    try:
        if client is None:
            client = get_memory_client()
        return client.count() > 0
    except Exception as e:
        logger.error(f"Memory health check failed: {e}")
        return False
```

Update memory/__init__.py to export validation:
```python
from .client import MemoryClient, get_memory_client, reset_memory_client
from .validation import (
    MemoryValidationResult,
    validate_memory_store,
    quick_health_check
)

__all__ = [
    "MemoryClient",
    "get_memory_client",
    "reset_memory_client",
    "MemoryValidationResult",
    "validate_memory_store",
    "quick_health_check"
]
```
  </action>
  <verify>Run `python -c "from ta_lab2.tools.ai_orchestrator.memory import validate_memory_store; r = validate_memory_store(); print(r)"` - should print validation result</verify>
  <done>Validation module reports count, dimensions, distance metric, and issues list</done>
</task>

<task type="auto">
  <name>Task 4: Create client and validation tests</name>
  <files>tests/orchestrator/test_memory_client.py</files>
  <action>
Create tests/orchestrator/test_memory_client.py with comprehensive tests:

```python
"""Tests for memory client and validation modules."""
import pytest
from unittest.mock import MagicMock, patch
from ta_lab2.tools.ai_orchestrator.memory import (
    MemoryClient,
    get_memory_client,
    reset_memory_client,
    MemoryValidationResult,
    validate_memory_store,
    quick_health_check
)


class TestMemoryClient:
    """Tests for MemoryClient class."""

    def setup_method(self):
        """Reset singleton before each test."""
        reset_memory_client()

    def teardown_method(self):
        """Clean up after each test."""
        reset_memory_client()

    @patch('chromadb.PersistentClient')
    def test_client_initializes_with_path(self, mock_client):
        """Test client initializes with provided path."""
        mock_collection = MagicMock()
        mock_client.return_value.get_collection.return_value = mock_collection

        client = MemoryClient("/test/path", "test_collection")

        mock_client.assert_called_once_with(path="/test/path")
        assert client._collection_name == "test_collection"

    @patch('chromadb.PersistentClient')
    def test_collection_lazy_loads(self, mock_client):
        """Test collection is loaded on first access."""
        mock_collection = MagicMock()
        mock_client.return_value.get_collection.return_value = mock_collection

        client = MemoryClient("/test/path")

        # Collection not loaded yet
        mock_client.return_value.get_collection.assert_not_called()

        # Access triggers load
        _ = client.collection
        mock_client.return_value.get_collection.assert_called_once()

    @patch('chromadb.PersistentClient')
    def test_count_delegates_to_collection(self, mock_client):
        """Test count() calls collection.count()."""
        mock_collection = MagicMock()
        mock_collection.count.return_value = 3763
        mock_client.return_value.get_collection.return_value = mock_collection

        client = MemoryClient("/test/path")

        assert client.count() == 3763
        mock_collection.count.assert_called_once()

    @patch('chromadb.PersistentClient')
    def test_singleton_pattern(self, mock_client):
        """Test get_memory_client returns singleton."""
        mock_collection = MagicMock()
        mock_client.return_value.get_collection.return_value = mock_collection

        with patch('ta_lab2.tools.ai_orchestrator.memory.client.load_config') as mock_config:
            mock_config.return_value = MagicMock(
                chromadb_path="/test/path",
                chromadb_collection_name="test"
            )

            client1 = get_memory_client()
            client2 = get_memory_client()

            assert client1 is client2


class TestMemoryValidation:
    """Tests for memory validation module."""

    def setup_method(self):
        reset_memory_client()

    def teardown_method(self):
        reset_memory_client()

    def test_validation_result_str(self):
        """Test MemoryValidationResult string representation."""
        result = MemoryValidationResult(
            is_valid=True,
            total_count=3763,
            expected_count=3763,
            sample_valid=True,
            metadata_complete=True,
            distance_metric="cosine",
            embedding_dimensions=1536,
            issues=[]
        )

        output = str(result)
        assert "VALID" in output
        assert "3763" in output
        assert "cosine" in output

    def test_validation_result_invalid_str(self):
        """Test invalid result string shows INVALID."""
        result = MemoryValidationResult(
            is_valid=False,
            total_count=100,
            expected_count=3763,
            sample_valid=False,
            metadata_complete=True,
            distance_metric="l2",
            embedding_dimensions=1536,
            issues=["Count mismatch"]
        )

        output = str(result)
        assert "INVALID" in output

    @patch('ta_lab2.tools.ai_orchestrator.memory.validation.get_memory_client')
    def test_validate_checks_count(self, mock_get_client):
        """Test validation checks count against expected."""
        mock_client = MagicMock()
        mock_collection = MagicMock()
        mock_collection.count.return_value = 3763
        mock_collection.metadata = {"hnsw:space": "cosine"}
        mock_collection.get.return_value = {
            "embeddings": [[0.1] * 1536 for _ in range(10)],
            "metadatas": [{"type": "test"} for _ in range(10)],
            "documents": ["doc"] * 10
        }
        mock_client.collection = mock_collection
        mock_get_client.return_value = mock_client

        result = validate_memory_store(expected_count=3763)

        assert result.is_valid
        assert result.total_count == 3763

    @patch('ta_lab2.tools.ai_orchestrator.memory.validation.get_memory_client')
    def test_validate_detects_count_mismatch(self, mock_get_client):
        """Test validation fails on count mismatch."""
        mock_client = MagicMock()
        mock_collection = MagicMock()
        mock_collection.count.return_value = 100
        mock_collection.metadata = {"hnsw:space": "cosine"}
        mock_collection.get.return_value = {
            "embeddings": [[0.1] * 1536 for _ in range(10)],
            "metadatas": [{"type": "test"} for _ in range(10)],
            "documents": ["doc"] * 10
        }
        mock_client.collection = mock_collection
        mock_get_client.return_value = mock_client

        result = validate_memory_store(expected_count=3763)

        assert not result.is_valid
        assert "Count mismatch" in result.issues[0]

    @patch('ta_lab2.tools.ai_orchestrator.memory.validation.get_memory_client')
    def test_validate_warns_on_l2_distance(self, mock_get_client):
        """Test validation warns when using L2 distance."""
        mock_client = MagicMock()
        mock_collection = MagicMock()
        mock_collection.count.return_value = 3763
        mock_collection.metadata = {"hnsw:space": "l2"}  # Not cosine
        mock_collection.get.return_value = {
            "embeddings": [[0.1] * 1536 for _ in range(10)],
            "metadatas": [{"type": "test"} for _ in range(10)],
            "documents": ["doc"] * 10
        }
        mock_client.collection = mock_collection
        mock_get_client.return_value = mock_client

        result = validate_memory_store()

        # Still valid (we warn but don't fail on L2)
        assert result.is_valid
        assert result.distance_metric == "l2"
        assert any("l2" in issue for issue in result.issues)

    @patch('ta_lab2.tools.ai_orchestrator.memory.validation.get_memory_client')
    def test_validate_checks_embedding_dimensions(self, mock_get_client):
        """Test validation checks embedding dimensions."""
        mock_client = MagicMock()
        mock_collection = MagicMock()
        mock_collection.count.return_value = 3763
        mock_collection.metadata = {"hnsw:space": "cosine"}
        # Wrong dimensions
        mock_collection.get.return_value = {
            "embeddings": [[0.1] * 768 for _ in range(10)],  # 768 instead of 1536
            "metadatas": [{"type": "test"} for _ in range(10)],
            "documents": ["doc"] * 10
        }
        mock_client.collection = mock_collection
        mock_get_client.return_value = mock_client

        result = validate_memory_store()

        assert not result.is_valid
        assert not result.sample_valid

    @patch('ta_lab2.tools.ai_orchestrator.memory.validation.get_memory_client')
    def test_quick_health_check_success(self, mock_get_client):
        """Test quick health check returns True when store accessible."""
        mock_client = MagicMock()
        mock_client.count.return_value = 3763
        mock_get_client.return_value = mock_client

        assert quick_health_check() is True

    @patch('ta_lab2.tools.ai_orchestrator.memory.validation.get_memory_client')
    def test_quick_health_check_failure(self, mock_get_client):
        """Test quick health check returns False on error."""
        mock_get_client.side_effect = Exception("Connection failed")

        assert quick_health_check() is False


class TestIntegrationWithRealChromaDB:
    """Integration tests with real ChromaDB (skip if not available)."""

    @pytest.fixture
    def real_client(self):
        """Get real ChromaDB client, skip if unavailable."""
        reset_memory_client()
        try:
            from ta_lab2.tools.ai_orchestrator.config import load_config
            config = load_config()
            import os
            if not os.path.exists(config.chromadb_path):
                pytest.skip(f"ChromaDB not found at {config.chromadb_path}")
            client = get_memory_client(config)
            yield client
        except Exception as e:
            pytest.skip(f"ChromaDB not available: {e}")
        finally:
            reset_memory_client()

    def test_real_chromadb_accessible(self, real_client):
        """Test real ChromaDB is accessible."""
        count = real_client.count()
        assert count > 0, "ChromaDB should have memories"

    def test_real_validation_passes(self, real_client):
        """Test validation against real ChromaDB."""
        result = validate_memory_store(real_client)

        print(f"\nReal ChromaDB Validation:\n{result}")

        # Report but don't fail on warnings
        assert result.total_count >= 3763, f"Expected 3763+ memories, got {result.total_count}"
        assert result.sample_valid, f"Sample validation failed: {result.issues}"
```
  </action>
  <verify>Run `pytest tests/orchestrator/test_memory_client.py -v` - all mock tests pass, integration tests pass if ChromaDB available</verify>
  <done>16+ tests covering client initialization, singleton pattern, validation logic, and real ChromaDB integration</done>
</task>

</tasks>

<verification>
1. `python -c "from ta_lab2.tools.ai_orchestrator.memory import validate_memory_store; print(validate_memory_store())"` - prints validation with 3763+ count
2. `pytest tests/orchestrator/test_memory_client.py -v` - all tests pass
3. Config module loads ChromaDB settings from environment
</verification>

<success_criteria>
- MemoryClient singleton provides access to ChromaDB collection
- validate_memory_store() reports 3,763+ memories with 1536 dimensions
- Distance metric documented (cosine or L2 with warning)
- 16+ tests pass covering all validation scenarios
- MEMO-01 partially satisfied (ChromaDB accessible and validated)
</success_criteria>

<output>
After completion, create `.planning/phases/02-memory-core-chromadb-integration/02-01-SUMMARY.md`
</output>
