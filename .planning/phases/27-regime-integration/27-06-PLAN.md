---
phase: 27-regime-integration
plan: 06
type: execute
wave: 3
depends_on: ["27-01", "27-03"]
files_modified:
  - src/ta_lab2/scripts/signals/generate_signals_ema.py
  - src/ta_lab2/scripts/signals/generate_signals_rsi.py
  - src/ta_lab2/scripts/signals/generate_signals_atr.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_ema_crossover.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_rsi_mean_revert.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_atr_breakout.py
autonomous: true

must_haves:
  truths:
    - "All 3 signal generators accept an optional regime_context parameter (TightenOnlyPolicy or None)"
    - "When regime context is provided, size is scaled by size_mult and stop by stop_mult"
    - "regime_key is recorded in signal records written to DB"
    - "Signal generators log regime filtering/sizing decisions per signal"
    - "--no-regime flag on signal refreshers disables regime context for A/B comparison"
    - "dim_signals.regime_enabled=FALSE causes a signal to skip regime integration"
  artifacts:
    - path: "src/ta_lab2/scripts/signals/generate_signals_ema.py"
      provides: "EMA signal generator with regime awareness"
      contains: "regime_context"
    - path: "src/ta_lab2/scripts/signals/generate_signals_rsi.py"
      provides: "RSI signal generator with regime awareness"
      contains: "regime_context"
    - path: "src/ta_lab2/scripts/signals/generate_signals_atr.py"
      provides: "ATR signal generator with regime awareness"
      contains: "regime_context"
  key_links:
    - from: "src/ta_lab2/scripts/signals/generate_signals_ema.py"
      to: "cmc_regimes table"
      via: "SQL query for latest regime per (id, tf)"
      pattern: "SELECT.*FROM.*cmc_regimes"
    - from: "src/ta_lab2/scripts/signals/generate_signals_ema.py"
      to: "src/ta_lab2/regimes/resolver.py"
      via: "import TightenOnlyPolicy"
      pattern: "from ta_lab2.regimes.resolver import TightenOnlyPolicy"
---

<objective>
Wire regime context into all 3 signal generators with full TightenOnlyPolicy enforcement.

Purpose: Signal generators need to apply regime-based position sizing and filtering. When a regime says size_mult=0.4 (choppy market), signals should scale position size down. When orders="passive", aggressive breakout signals should be suppressed.
Output: All 3 generators accept regime context, apply policy, record regime_key, support --no-regime flag.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-regime-integration/27-RESEARCH.md
@src/ta_lab2/scripts/signals/generate_signals_ema.py
@src/ta_lab2/scripts/signals/generate_signals_rsi.py
@src/ta_lab2/scripts/signals/generate_signals_atr.py
@src/ta_lab2/regimes/resolver.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add regime context loading and application to signal generators</name>
  <files>
    src/ta_lab2/scripts/signals/generate_signals_ema.py
    src/ta_lab2/scripts/signals/generate_signals_rsi.py
    src/ta_lab2/scripts/signals/generate_signals_atr.py
  </files>
  <action>
Add a shared helper function (can be in a new file `src/ta_lab2/scripts/signals/regime_utils.py` or inline in each generator):

**load_regime_context(engine, asset_id, ts, tf='1D') -> Optional[TightenOnlyPolicy]:**
```python
def load_regime_context(engine, asset_id: int, ts, tf: str = '1D'):
    """Load the most recent regime for an asset at or before timestamp ts."""
    sql = text("""
        SELECT regime_key, size_mult, stop_mult, orders, gross_cap, pyramids
        FROM public.cmc_regimes
        WHERE id = :id AND tf = :tf AND ts <= :ts
        ORDER BY ts DESC LIMIT 1
    """)
    with engine.connect() as conn:
        row = conn.execute(sql, {"id": asset_id, "tf": tf, "ts": ts}).fetchone()
    if row is None:
        return None, None
    policy = TightenOnlyPolicy(
        size_mult=float(row[1]),
        stop_mult=float(row[2]),
        orders=row[3],
        gross_cap=float(row[4]),
        pyramids=bool(row[5]),
    )
    return policy, row[0]  # (TightenOnlyPolicy, regime_key)
```

**For EACH of the 3 generators**, modify `generate_for_ids()`:

1. Add parameter: `regime_enabled: bool = True`
2. If regime_enabled is True:
   - Before generating signals, for each asset in the groupby("id") loop:
     a. Get the latest timestamp for this asset's feature data
     b. Call `load_regime_context(engine, asset_id, latest_ts)` to get (policy, regime_key)
     c. If policy is not None:
        - **Size scaling**: Multiply any computed position size by `policy.size_mult`
        - **Setup filtering**: If the signal's setup type is not in `policy.setups` (when setups is not None/empty), skip the signal entry. Map signal types to setup categories:
          - EMA crossover -> "breakout" or "pullback" (depending on direction relative to trend)
          - RSI mean revert -> "mean_revert"
          - ATR breakout -> "breakout"
        - **Orders mode**: If policy.orders == "passive", log a warning but still generate (record in metadata). If policy.orders == "conservative", only accept signals with confirm_bars > 0 (already the default).
        - **Pyramiding**: If policy.pyramids is False, skip entry if there's already an open position for this asset+signal_id
     d. Log: `f"Regime context for id={asset_id}: regime_key={regime_key}, size_mult={policy.size_mult}, orders={policy.orders}"`
3. Add `regime_key` to all signal records:
   - In `_transform_signals_to_records`: Add `"regime_key": regime_key` to each record dict
   - If regime_enabled=False or no regime found: regime_key = None

**IMPORTANT**: Do NOT break existing functionality. The regime_enabled parameter defaults to True, and if cmc_regimes is empty (not yet computed), load_regime_context returns None and signals generate as before (no filtering, no scaling, regime_key=None).

**Specific modifications per generator:**

For **EMASignalGenerator**:
- In `_transform_signals_to_records`, add regime_key to each record dict
- Before entry signals: check if "breakout" or "pullback" is in policy.setups (if setups is not None)
- Scale: no explicit size column in current code, so just log the regime and set regime_key

For **RSISignalGenerator**:
- In `transform_signals_to_records`, add regime_key to each record dict
- Before entry signals: check if "mean_revert" is in policy.setups (if setups is not None)
- If "stand_down" in policy.setups and "mean_revert" not in policy.setups: skip entry, log "Regime stand_down: suppressing RSI entry"

For **ATRSignalGenerator**:
- In `_transform_signals_to_records`, add regime_key to each record dict
- Before entry signals: check if "breakout" is in policy.setups (if setups is not None)
- If policy.orders == "passive": skip breakout signals entirely, log "Regime passive: suppressing ATR breakout"
  </action>
  <verify>
Verify each generator still imports and has the new parameter:
```python
python -c "
from ta_lab2.scripts.signals.generate_signals_ema import EMASignalGenerator
from ta_lab2.scripts.signals.generate_signals_rsi import RSISignalGenerator
from ta_lab2.scripts.signals.generate_signals_atr import ATRSignalGenerator
import inspect

for cls in [EMASignalGenerator, RSISignalGenerator, ATRSignalGenerator]:
    sig = inspect.signature(cls.generate_for_ids)
    params = list(sig.parameters.keys())
    assert 'regime_enabled' in params, f'{cls.__name__} missing regime_enabled parameter'
    print(f'OK: {cls.__name__}.generate_for_ids has regime_enabled parameter')
"
```
  </verify>
  <done>All 3 generators accept regime_enabled parameter, load regime context from DB, apply setup filtering, and record regime_key in signal records.</done>
</task>

<task type="auto">
  <name>Task 2: Add --no-regime flag to signal refresher scripts</name>
  <files>
    src/ta_lab2/scripts/signals/refresh_cmc_signals_ema_crossover.py
    src/ta_lab2/scripts/signals/refresh_cmc_signals_rsi_mean_revert.py
    src/ta_lab2/scripts/signals/refresh_cmc_signals_atr_breakout.py
  </files>
  <action>
For each of the 3 signal refresher scripts (refresh_cmc_signals_*.py):

1. Add `--no-regime` CLI flag:
   ```python
   parser.add_argument("--no-regime", action="store_true",
                       help="Disable regime context for A/B comparison backtesting")
   ```

2. Before calling `generator.generate_for_ids()`, check dim_signals.regime_enabled:
   ```python
   # Check per-signal regime_enabled flag from dim_signals
   regime_enabled = not args.no_regime
   if regime_enabled:
       # Check if this specific signal has regime_enabled=FALSE in dim_signals
       if not config.get("regime_enabled", True):
           regime_enabled = False
           logger.info(f"  Regime disabled for {config['signal_name']} (dim_signals.regime_enabled=FALSE)")
   ```

3. Pass to generator:
   ```python
   n = generator.generate_for_ids(
       ids=ids,
       signal_config=config,
       full_refresh=args.full_refresh,
       regime_enabled=regime_enabled,
   )
   ```

4. Also update `run_all_signal_refreshes.py`:
   - Add `--no-regime` flag
   - Pass `regime_enabled` through to `refresh_signal_type()`
   - Update `refresh_signal_type()` signature to accept `regime_enabled: bool`

5. Update `load_active_signals()` to include `regime_enabled` from dim_signals:
   - In the SQL query that loads signal configs, add `regime_enabled` column
   - Include in the returned config dict
   - Handle missing column gracefully (default True if column doesn't exist yet)
  </action>
  <verify>
```bash
python -m ta_lab2.scripts.signals.refresh_cmc_signals_ema_crossover --help | grep -i regime
```
Should show --no-regime flag in help output.

```bash
python -m ta_lab2.scripts.signals.refresh_cmc_signals_ema_crossover --ids 1 --dry-run --no-regime
```
Should show "Regime disabled" in output.
  </verify>
  <done>
- All 3 refresher scripts have --no-regime flag
- dim_signals.regime_enabled is checked per signal
- run_all_signal_refreshes.py passes regime flag through
- A/B comparison possible: run with vs without --no-regime
  </done>
</task>

</tasks>

<verification>
- All 3 generators have regime_enabled parameter
- --no-regime flag works on all 3 refresher scripts
- Regime context loads from cmc_regimes (or returns None if empty)
- regime_key is included in signal records
- Existing signal generation still works when no regime data exists
</verification>

<success_criteria>
- Signal generators apply regime-based filtering (setup checks)
- regime_key recorded in all new signal records
- --no-regime flag disables regime for A/B comparison
- No regression: signals generate correctly when cmc_regimes is empty
</success_criteria>

<output>
After completion, create `.planning/phases/27-regime-integration/27-06-SUMMARY.md`
</output>
