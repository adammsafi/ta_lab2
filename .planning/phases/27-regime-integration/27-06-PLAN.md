---
phase: 27-regime-integration
plan: 06
type: execute
wave: 3
depends_on: ["27-01", "27-03"]
files_modified:
  - src/ta_lab2/scripts/signals/generate_signals_ema.py
  - src/ta_lab2/scripts/signals/generate_signals_rsi.py
  - src/ta_lab2/scripts/signals/generate_signals_atr.py
  - src/ta_lab2/scripts/signals/regime_utils.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_ema_crossover.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_rsi_mean_revert.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_atr_breakout.py
autonomous: true

must_haves:
  truths:
    - "All 3 signal generators accept an optional regime_context parameter (TightenOnlyPolicy or None)"
    - "When regime context is provided, size is scaled by size_mult and stop by stop_mult"
    - "regime_key is recorded in signal records written to DB"
    - "Signal generators log regime filtering/sizing decisions per signal"
    - "--no-regime flag on signal refreshers disables regime context for A/B comparison"
    - "dim_signals.regime_enabled=FALSE causes a signal to skip regime integration"
    - "RSI feature_snapshot dict is serialized to JSON string before DB write (fixes pre-existing bug)"
  artifacts:
    - path: "src/ta_lab2/scripts/signals/regime_utils.py"
      provides: "Shared regime context loading utility for signal generators"
      exports: ["load_regime_context_batch"]
    - path: "src/ta_lab2/scripts/signals/generate_signals_ema.py"
      provides: "EMA signal generator with regime awareness"
      contains: "regime_context"
    - path: "src/ta_lab2/scripts/signals/generate_signals_rsi.py"
      provides: "RSI signal generator with regime awareness and feature_snapshot fix"
      contains: "regime_context"
    - path: "src/ta_lab2/scripts/signals/generate_signals_atr.py"
      provides: "ATR signal generator with regime awareness"
      contains: "regime_context"
  key_links:
    - from: "src/ta_lab2/scripts/signals/regime_utils.py"
      to: "cmc_regimes table"
      via: "batch SQL query loading regime for all IDs in date range"
      pattern: "SELECT.*FROM.*cmc_regimes"
    - from: "src/ta_lab2/scripts/signals/generate_signals_ema.py"
      to: "src/ta_lab2/scripts/signals/regime_utils.py"
      via: "import load_regime_context_batch"
      pattern: "from.*regime_utils import"
---

<objective>
Wire regime context into all 3 signal generators with full TightenOnlyPolicy enforcement. Fix the pre-existing RSI feature_snapshot serialization bug.

Purpose: Signal generators need to apply regime-based position sizing and filtering. When a regime says size_mult=0.4 (choppy market), signals should scale position size down. When orders="passive", aggressive breakout signals should be suppressed.
Output: All 3 generators accept regime context, apply policy, record regime_key, support --no-regime flag. RSI generator writes to DB without dict serialization errors.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-regime-integration/27-RESEARCH.md
@src/ta_lab2/scripts/signals/generate_signals_ema.py
@src/ta_lab2/scripts/signals/generate_signals_rsi.py
@src/ta_lab2/scripts/signals/generate_signals_atr.py
@src/ta_lab2/regimes/resolver.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create regime_utils.py with batch regime loading and fix RSI feature_snapshot bug</name>
  <files>
    src/ta_lab2/scripts/signals/regime_utils.py
    src/ta_lab2/scripts/signals/generate_signals_rsi.py
  </files>
  <action>
**Create regime_utils.py** with a batch-load-and-merge strategy (NOT per-signal-point N DB queries):

```python
def load_regime_context_batch(engine, ids: list[int], tf: str = '1D') -> pd.DataFrame:
    """
    Batch-load regime data for all IDs at once.

    Returns DataFrame with columns: id, ts, regime_key, size_mult, stop_mult, orders, gross_cap, pyramids.
    Signal generators merge this onto their feature DataFrame on (id, ts) to get
    point-in-time regime context without N individual queries.

    Strategy: Single SQL query loads regime for all IDs, then merge_asof or exact merge
    in the generator gives point-in-time context per signal entry.
    """
    sql = text("""
        SELECT id, ts, regime_key, size_mult, stop_mult, orders, gross_cap, pyramids
        FROM public.cmc_regimes
        WHERE id = ANY(:ids) AND tf = :tf
        ORDER BY id, ts
    """)
    with engine.connect() as conn:
        df = pd.read_sql(sql, conn, params={"ids": ids, "tf": tf})
    if not df.empty:
        df["ts"] = pd.to_datetime(df["ts"], utc=True)
    return df


def merge_regime_context(feature_df: pd.DataFrame, regime_df: pd.DataFrame) -> pd.DataFrame:
    """
    Merge regime context onto feature data using merge_asof (backward).

    For each (id, ts) in feature_df, finds the most recent regime row at or before that ts.
    Adds columns: regime_key, size_mult, stop_mult, orders, gross_cap, pyramids.
    """
    if regime_df.empty:
        # No regime data — add NULL regime columns
        for col in ["regime_key", "size_mult", "stop_mult", "orders", "gross_cap", "pyramids"]:
            feature_df[col] = None
        return feature_df

    # merge_asof requires sorted keys
    feature_df = feature_df.sort_values(["id", "ts"])
    regime_df = regime_df.sort_values(["id", "ts"])

    result = pd.merge_asof(
        feature_df,
        regime_df,
        on="ts",
        by="id",
        direction="backward",
    )
    return result
```

**Fix RSI feature_snapshot serialization bug** in `generate_signals_rsi.py`:

The existing code at ~line 449 has a no-op lambda:
```python
# BROKEN (no-op):
df_records["feature_snapshot"] = df_records["feature_snapshot"].apply(
    lambda x: x if pd.isna(x) else x
)
```

Replace with actual JSON serialization:
```python
import json

# FIX: Serialize dict to JSON string for PostgreSQL JSONB compatibility
df_records["feature_snapshot"] = df_records["feature_snapshot"].apply(
    lambda x: json.dumps(x) if isinstance(x, dict) else x
)
```

This fixes the pre-existing `can't adapt type 'dict'` error documented in MEMORY.md and RESEARCH.md Pitfall 5. Without this fix, the RSI signal generator cannot write to DB at all, which would block the end-to-end checkpoint in Plan 27-07.
  </action>
  <verify>
Verify regime_utils imports cleanly:
```python
python -c "
from ta_lab2.scripts.signals.regime_utils import load_regime_context_batch, merge_regime_context
print('Import OK: regime_utils')
"
```

Verify RSI feature_snapshot fix with synthetic data:
```python
python -c "
import json
import pandas as pd

# Simulate what RSI generator does
data = {'feature_snapshot': [{'close': 100.0, 'rsi_14': 28.5}, None, {'close': 200.0, 'rsi_14': 72.0}]}
df = pd.DataFrame(data)

# Apply the fix
df['feature_snapshot'] = df['feature_snapshot'].apply(
    lambda x: json.dumps(x) if isinstance(x, dict) else x
)

# Verify all values are strings or None (not dicts)
for val in df['feature_snapshot']:
    if val is not None:
        assert isinstance(val, str), f'Expected string, got {type(val)}: {val}'
        json.loads(val)  # Verify it's valid JSON
print('PASS: feature_snapshot serialization works')
"
```
  </verify>
  <done>
- regime_utils.py provides batch loading (single SQL query) and merge_asof for point-in-time regime context
- RSI feature_snapshot dict serialization bug fixed (json.dumps instead of no-op lambda)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add regime context to EMA signal generator</name>
  <files>
    src/ta_lab2/scripts/signals/generate_signals_ema.py
    src/ta_lab2/scripts/signals/refresh_cmc_signals_ema_crossover.py
  </files>
  <action>
**Modify EMASignalGenerator in generate_signals_ema.py:**

1. Add parameter to `generate_for_ids()`: `regime_enabled: bool = True`
2. If regime_enabled:
   - At start of generate_for_ids, call `load_regime_context_batch(engine, ids)` to batch-load all regime data
   - Use `merge_regime_context(feature_df, regime_df)` to add regime columns to feature data
   - For each signal entry, read regime_key, size_mult from the merged row
   - In `_transform_signals_to_records`, add `"regime_key": row.get("regime_key")` to each record
   - Log: `f"Regime: {regime_key}, size_mult={size_mult}"` per entry signal
   - Apply setup filtering: if regime says orders="passive", log warning for breakout signals
3. If regime_enabled=False or no regime data: regime_key = None, no filtering

**Modify refresh_cmc_signals_ema_crossover.py:**

1. Add `--no-regime` CLI flag:
   ```python
   parser.add_argument("--no-regime", action="store_true",
                       help="Disable regime context for A/B comparison backtesting")
   ```
2. Pass regime_enabled to generator:
   ```python
   regime_enabled = not args.no_regime
   ```
  </action>
  <verify>
```python
python -c "
from ta_lab2.scripts.signals.generate_signals_ema import EMASignalGenerator
import inspect
sig = inspect.signature(EMASignalGenerator.generate_for_ids)
params = list(sig.parameters.keys())
assert 'regime_enabled' in params, f'Missing regime_enabled, got: {params}'
print('OK: EMASignalGenerator.generate_for_ids has regime_enabled parameter')
"
```

```bash
python -m ta_lab2.scripts.signals.refresh_cmc_signals_ema_crossover --help | grep -i regime
```
Should show --no-regime flag.
  </verify>
  <done>EMA generator accepts regime_enabled, loads batch regime context, applies filtering, records regime_key.</done>
</task>

<task type="auto">
  <name>Task 3: Add regime context to RSI and ATR signal generators + refresher flags</name>
  <files>
    src/ta_lab2/scripts/signals/generate_signals_rsi.py
    src/ta_lab2/scripts/signals/generate_signals_atr.py
    src/ta_lab2/scripts/signals/refresh_cmc_signals_rsi_mean_revert.py
    src/ta_lab2/scripts/signals/refresh_cmc_signals_atr_breakout.py
    src/ta_lab2/scripts/signals/run_all_signal_refreshes.py
  </files>
  <action>
**Modify RSISignalGenerator in generate_signals_rsi.py:**

Same pattern as EMA generator (Task 2):
1. Add `regime_enabled: bool = True` parameter to `generate_for_ids()`
2. Batch-load and merge regime context
3. Add regime_key to signal records
4. Apply setup filtering: if regime says "stand_down" in setups and "mean_revert" not in setups, skip entry and log
5. Log regime context per signal

**Modify ATRSignalGenerator in generate_signals_atr.py:**

Same pattern:
1. Add `regime_enabled: bool = True` parameter to `generate_for_ids()`
2. Batch-load and merge regime context
3. Add regime_key to signal records
4. Apply filtering: if policy.orders == "passive", skip breakout signals entirely, log "Regime passive: suppressing ATR breakout"

**Modify refresh_cmc_signals_rsi_mean_revert.py and refresh_cmc_signals_atr_breakout.py:**

1. Add `--no-regime` CLI flag to each
2. Pass regime_enabled through to generator
3. Check dim_signals.regime_enabled per signal config

**Modify run_all_signal_refreshes.py:**

`run_all_signal_refreshes.py` does NOT use subprocesses — it directly calls
`generator.generate_for_ids(ids, cfg, full_refresh=full_refresh)`. Thread regime_enabled through
the call chain as follows:

1. Add `--no-regime` flag to the top-level argument parser:
   ```python
   parser.add_argument("--no-regime", action="store_true",
                       help="Disable regime context for A/B comparison backtesting")
   ```
2. Derive regime_enabled from the parsed arg:
   ```python
   regime_enabled = not args.no_regime
   ```
3. Thread regime_enabled through `refresh_signal_type()`:
   ```python
   def refresh_signal_type(signal_type, ids, cfg, full_refresh=False, regime_enabled=True):
       ...
   ```
4. Thread regime_enabled through `run_parallel_refresh()`:
   ```python
   def run_parallel_refresh(signal_types, ids, cfg, full_refresh=False, regime_enabled=True):
       ...
       refresh_signal_type(..., regime_enabled=regime_enabled)
   ```
5. Pass regime_enabled to the generator call:
   ```python
   generator.generate_for_ids(ids, cfg, full_refresh=full_refresh, regime_enabled=regime_enabled)
   ```

**IMPORTANT**: Do NOT break existing functionality. The regime_enabled parameter defaults to True, and if cmc_regimes is empty (not yet computed), load_regime_context_batch returns empty DataFrame and merge_regime_context adds NULL regime columns — signals generate as before (no filtering, no scaling, regime_key=None).
  </action>
  <verify>
```python
python -c "
from ta_lab2.scripts.signals.generate_signals_rsi import RSISignalGenerator
from ta_lab2.scripts.signals.generate_signals_atr import ATRSignalGenerator
import inspect

for cls in [RSISignalGenerator, ATRSignalGenerator]:
    sig = inspect.signature(cls.generate_for_ids)
    params = list(sig.parameters.keys())
    assert 'regime_enabled' in params, f'{cls.__name__} missing regime_enabled, got: {params}'
    print(f'OK: {cls.__name__}.generate_for_ids has regime_enabled parameter')
"
```

```bash
python -m ta_lab2.scripts.signals.refresh_cmc_signals_rsi_mean_revert --help | grep -i regime
python -m ta_lab2.scripts.signals.refresh_cmc_signals_atr_breakout --help | grep -i regime
```
Both should show --no-regime flag.

```bash
python -m ta_lab2.scripts.signals.run_all_signal_refreshes --help | grep -i regime
```
Should show --no-regime flag.
  </verify>
  <done>
- RSI generator has regime awareness + feature_snapshot fix (from Task 1)
- ATR generator has regime awareness with passive-mode breakout suppression
- All 3 refresher scripts have --no-regime flag
- run_all_signal_refreshes.py threads regime_enabled through refresh_signal_type() and run_parallel_refresh(), passing it to generator.generate_for_ids()
  </done>
</task>

</tasks>

<verification>
- All 3 generators have regime_enabled parameter
- --no-regime flag works on all 3 refresher scripts and run_all_signal_refreshes.py
- Regime context loads from cmc_regimes via batch query (or returns None/empty if empty)
- regime_key is included in signal records
- RSI feature_snapshot serialization bug fixed (json.dumps)
- Existing signal generation still works when no regime data exists
</verification>

<success_criteria>
- Signal generators apply regime-based filtering (setup checks)
- regime_key recorded in all new signal records
- --no-regime flag disables regime for A/B comparison
- No regression: signals generate correctly when cmc_regimes is empty
- RSI signal generator writes to DB without 'can't adapt type dict' error
</success_criteria>

<output>
After completion, create `.planning/phases/27-regime-integration/27-06-SUMMARY.md`
</output>
