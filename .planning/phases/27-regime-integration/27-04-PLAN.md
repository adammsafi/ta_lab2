---
phase: 27-regime-integration
plan: 04
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - src/ta_lab2/regimes/hysteresis.py
  - src/ta_lab2/scripts/regimes/regime_flips.py
  - src/ta_lab2/scripts/regimes/regime_stats.py
autonomous: true

must_haves:
  truths:
    - "HysteresisTracker prevents rapid regime flipping by requiring min_bars_hold before accepting a change"
    - "Flip detection identifies regime transitions with old_regime, new_regime, duration_bars"
    - "Regime stats computes per-asset, per-regime summary statistics (n_bars, pct_of_history, avg_ret)"
  artifacts:
    - path: "src/ta_lab2/regimes/hysteresis.py"
      provides: "Real hysteresis implementation replacing the stub in resolver.py"
      exports: ["HysteresisTracker"]
      min_lines: 40
    - path: "src/ta_lab2/scripts/regimes/regime_flips.py"
      provides: "DB-backed flip detection and writing"
      exports: ["detect_regime_flips", "write_flips_to_db"]
    - path: "src/ta_lab2/scripts/regimes/regime_stats.py"
      provides: "DB-backed regime stats computation and writing"
      exports: ["compute_regime_stats", "write_stats_to_db"]
  key_links:
    - from: "src/ta_lab2/regimes/hysteresis.py"
      to: "src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py"
      via: "imported and called during labeling"
      pattern: "HysteresisTracker"
    - from: "src/ta_lab2/scripts/regimes/regime_flips.py"
      to: "cmc_regime_flips table"
      via: "scoped DELETE + INSERT"
      pattern: "DELETE FROM.*cmc_regime_flips"
---

<objective>
Build the hysteresis tracker, flip detection, and regime stats modules.

Purpose: The current hysteresis in resolver.py is a stub that always accepts changes. Real hysteresis prevents rapid regime flipping (important for avoiding whipsaw in position sizing). Flips and stats tables provide analytics for regime behavior analysis.
Output: HysteresisTracker class, regime_flips.py, regime_stats.py modules.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-regime-integration/27-RESEARCH.md
@src/ta_lab2/regimes/resolver.py
@src/ta_lab2/regimes/flips.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HysteresisTracker class</name>
  <files>
    src/ta_lab2/regimes/hysteresis.py
  </files>
  <action>
Create `src/ta_lab2/regimes/hysteresis.py` with a stateful HysteresisTracker class:

```python
@dataclass
class HysteresisTracker:
    """
    Prevents rapid regime flipping by requiring min_bars_hold before accepting a change.

    Tracks bars_since_flip per (layer) and only accepts a regime change if
    the new regime has been held for at least min_bars_hold consecutive bars.

    Tighten-only semantics: A tightening change (reduced size_mult) is accepted immediately.
    Only loosening changes (increased size_mult) require the hold period.
    """
    min_bars_hold: int = 3  # default: require 3 bars before accepting loosening change

    # Internal state
    _current: dict[str, str]  # layer -> current accepted regime key
    _pending: dict[str, str]  # layer -> pending (not yet accepted) regime key
    _pending_count: dict[str, int]  # layer -> bars the pending regime has been seen
```

Methods:
- `__init__(self, min_bars_hold=3)`: Initialize with empty state dicts
- `update(self, layer: str, new_key: str, is_tightening: bool = False) -> str`:
  - If new_key == current for this layer: reset pending, return current
  - If is_tightening: accept immediately (tightening is always safe), update current, return new_key
  - If new_key == pending for this layer: increment pending_count
    - If pending_count >= min_bars_hold: accept (update current, clear pending, return new_key)
    - Else: return current (hold off)
  - If new_key != pending: start new pending (reset count to 1), return current
  - If no current yet (first call): accept immediately, return new_key
- `get_current(self, layer: str) -> Optional[str]`: Return current accepted regime for layer
- `reset(self)`: Clear all state

Also add a convenience function:
```python
def is_tightening_change(old_key: str, new_key: str, policy_table) -> bool:
    """Check if switching from old_key to new_key would tighten (reduce) risk."""
    old_policy = _match_policy(old_key, policy_table)
    new_policy = _match_policy(new_key, policy_table)
    return new_policy.get("size_mult", 1.0) <= old_policy.get("size_mult", 1.0)
```

Import `_match_policy` from resolver.py for the tightening check.

Add to `src/ta_lab2/regimes/__init__.py`: export HysteresisTracker (in a try/except block matching existing pattern).
  </action>
  <verify>
```python
python -c "
from ta_lab2.regimes.hysteresis import HysteresisTracker

ht = HysteresisTracker(min_bars_hold=3)

# First call: accept immediately
result = ht.update('L2', 'Up-Normal-Normal')
assert result == 'Up-Normal-Normal', f'Expected Up-Normal-Normal, got {result}'

# Change request: should hold
result = ht.update('L2', 'Sideways-High-Normal')
assert result == 'Up-Normal-Normal', f'Expected hold (Up-Normal-Normal), got {result}'

# Same change, 2nd bar
result = ht.update('L2', 'Sideways-High-Normal')
assert result == 'Up-Normal-Normal', f'Expected hold (Up-Normal-Normal), got {result}'

# Same change, 3rd bar: now accept
result = ht.update('L2', 'Sideways-High-Normal')
assert result == 'Sideways-High-Normal', f'Expected accepted (Sideways-High-Normal), got {result}'

# Tightening: accept immediately
result = ht.update('L2', 'Down-High-Stressed', is_tightening=True)
assert result == 'Down-High-Stressed', f'Expected immediate accept, got {result}'

print('PASS: HysteresisTracker works correctly')
"
```
  </verify>
  <done>HysteresisTracker correctly holds regime changes for min_bars_hold period, accepts tightening immediately, and tracks per-layer state.</done>
</task>

<task type="auto">
  <name>Task 2: Create regime_flips.py and regime_stats.py</name>
  <files>
    src/ta_lab2/scripts/regimes/regime_flips.py
    src/ta_lab2/scripts/regimes/regime_stats.py
  </files>
  <action>
**regime_flips.py** - Detect and store regime transitions:

`detect_regime_flips(regime_df: pd.DataFrame) -> pd.DataFrame`:
- Takes DataFrame with columns: id, ts, tf, regime_key, l0_label, l1_label, l2_label
- For each (id, tf) group, sorted by ts:
  - Compare consecutive regime_key values (and per-layer labels)
  - When regime_key changes: record a "composite" flip
  - When l0_label changes: record an "L0" flip
  - When l1_label changes: record an "L1" flip
  - When l2_label changes: record an "L2" flip
  - Compute duration_bars = bars since last flip for this layer
- Return DataFrame with columns: id, ts, tf, layer, old_regime, new_regime, duration_bars
- Skip rows where old_regime is None (first observation)

`write_flips_to_db(engine, flips_df, ids, tf='1D')`:
- Scoped DELETE + INSERT:
  ```python
  with engine.begin() as conn:
      conn.execute(text("DELETE FROM public.cmc_regime_flips WHERE id = ANY(:ids) AND tf = :tf"),
                   {"ids": ids, "tf": tf})
  flips_df.to_sql("cmc_regime_flips", engine, schema="public", if_exists="append", index=False, method="multi")
  ```
- Return rows written

**regime_stats.py** - Compute and store regime statistics:

`compute_regime_stats(regime_df: pd.DataFrame, returns_df: pd.DataFrame = None) -> pd.DataFrame`:
- Takes the regime DataFrame (from cmc_regimes)
- Groups by (id, tf, regime_key)
- Computes per group:
  - n_bars: count of rows
  - pct_of_history: n_bars / total_bars_for_this_(id, tf)
  - avg_ret_1d: mean of daily return if returns_df provided (merge on id, ts)
  - std_ret_1d: std of daily return if returns_df provided
- If returns_df is None, avg_ret_1d and std_ret_1d are NULL
- Add computed_at = pd.Timestamp.now(tz='UTC')
- Return DataFrame with columns: id, tf, regime_key, n_bars, pct_of_history, avg_ret_1d, std_ret_1d, computed_at

`write_stats_to_db(engine, stats_df, ids, tf='1D')`:
- Scoped DELETE + INSERT on cmc_regime_stats (same pattern)
- Return rows written

Both modules should use logging and handle empty DataFrames gracefully.
  </action>
  <verify>
```python
python -c "
import pandas as pd
from ta_lab2.scripts.regimes.regime_flips import detect_regime_flips

# Synthetic regime data with a flip
data = {
    'id': [1]*5,
    'ts': pd.date_range('2025-01-01', periods=5, freq='D'),
    'tf': ['1D']*5,
    'regime_key': ['Up-Normal-Normal','Up-Normal-Normal','Up-Normal-Normal','Sideways-High-Normal','Sideways-High-Normal'],
    'l0_label': [None]*5,
    'l1_label': [None]*5,
    'l2_label': ['Up-Normal-Normal','Up-Normal-Normal','Up-Normal-Normal','Sideways-High-Normal','Sideways-High-Normal'],
}
df = pd.DataFrame(data)
flips = detect_regime_flips(df)
print(flips)
assert len(flips) >= 1, 'Expected at least 1 flip'
assert flips.iloc[0]['new_regime'] == 'Sideways-High-Normal'
print('PASS: detect_regime_flips works')
"
```
  </verify>
  <done>
- detect_regime_flips identifies regime transitions per layer with duration_bars
- compute_regime_stats produces per-regime summaries
- Both writers use scoped DELETE + INSERT pattern
  </done>
</task>

</tasks>

<verification>
- HysteresisTracker holds changes for min_bars_hold, accepts tightening immediately
- Flip detection finds transitions in synthetic data
- Stats computation produces correct n_bars and pct_of_history
- All modules import cleanly
</verification>

<success_criteria>
- HysteresisTracker prevents rapid flipping (3-bar default hold)
- Tightening changes bypass hold period
- Flip detection works for composite and per-layer transitions
- Stats computation handles missing returns gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/27-regime-integration/27-04-SUMMARY.md`
</output>
