---
phase: 27-regime-integration
plan: 05
type: execute
wave: 3
depends_on: ["27-03", "27-04"]
files_modified:
  - src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py
autonomous: true

must_haves:
  truths:
    - "refresh_cmc_regimes.py applies hysteresis before writing regime labels"
    - "Regime flips are detected and written to cmc_regime_flips after each asset"
    - "Regime stats are computed and written to cmc_regime_stats after each asset"
    - "Comovement stats are computed and written to cmc_regime_comovement after each asset"
    - "CLI supports --no-hysteresis, --min-hold-bars flags for experimentation"
    - "Version hash is computed for reproducibility tracking"
  artifacts:
    - path: "src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py"
      provides: "Complete regime refresh script with hysteresis, flips, stats, and comovement"
      min_lines: 300
  key_links:
    - from: "src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py"
      to: "src/ta_lab2/regimes/hysteresis.py"
      via: "import HysteresisTracker"
      pattern: "HysteresisTracker"
    - from: "src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py"
      to: "src/ta_lab2/scripts/regimes/regime_flips.py"
      via: "import detect_regime_flips, write_flips_to_db"
      pattern: "detect_regime_flips"
    - from: "src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py"
      to: "src/ta_lab2/scripts/regimes/regime_stats.py"
      via: "import compute_regime_stats, write_stats_to_db"
      pattern: "compute_regime_stats"
    - from: "src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py"
      to: "src/ta_lab2/scripts/regimes/regime_comovement.py"
      via: "import compute_and_write_comovement, write_comovement_to_db"
      pattern: "compute_and_write_comovement"
---

<objective>
Wire hysteresis, flip detection, stats, and comovement into the core refresh script to produce the complete regime pipeline.

Purpose: Plans 03 and 04 built the core computation and the analytics modules separately. This plan integrates them: apply hysteresis to smooth labels, detect+store flips, compute+store stats, compute+store comovement, and add all remaining CLI flags.
Output: Complete refresh_cmc_regimes.py that writes to all 4 regime tables (cmc_regimes, cmc_regime_flips, cmc_regime_stats, cmc_regime_comovement).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-regime-integration/27-RESEARCH.md

# Prior plan summaries (needed: these plans create the modules being integrated)
@.planning/phases/27-regime-integration/27-03-SUMMARY.md
@.planning/phases/27-regime-integration/27-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate hysteresis into compute_regimes_for_id</name>
  <files>
    src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py
  </files>
  <action>
Modify the existing `compute_regimes_for_id()` function in refresh_cmc_regimes.py to:

1. Accept optional `hysteresis_tracker: Optional[HysteresisTracker] = None` parameter
2. After forward-filling multi-TF labels to daily index, before resolving policy:
   - If hysteresis_tracker is provided, apply it to each row's per-layer labels
   - For each row in the daily output (iterating chronologically):
     a. For each enabled layer (L0, L1, L2):
        - Get raw label from the forward-filled merge
        - Check if this is a tightening change: `is_tightening_change(current, new, policy_table)`
        - Call `hysteresis_tracker.update(layer, new_label, is_tightening=is_tightening)`
        - Use the returned (potentially held) label as the effective label
     b. Re-compose regime_key from effective labels
     c. Re-resolve policy using effective labels
   - NOTE: This per-row iteration is acceptable because daily data is at most ~3,650 rows per asset (10 years), and hysteresis is inherently sequential
3. If hysteresis_tracker is None, skip hysteresis (existing behavior preserved)

Also add `compute_version_hash(policy_table, code_version="1.0")`:
- Compute SHA-256 of sorted policy table keys + values + code_version string
- Return hex digest[:16] (short hash for readability)
- Set this on all output rows as regime_version_hash

Add CLI flags to main():
- `--no-hysteresis`: Skip hysteresis (set hysteresis_tracker=None)
- `--min-hold-bars` (default 3): HysteresisTracker(min_bars_hold=args.min_hold_bars)
  </action>
  <verify>
```bash
python -m ta_lab2.scripts.regimes.refresh_cmc_regimes --ids 1 --dry-run -v
```
Should show hysteresis being applied (or note "hysteresis: OFF" if --no-hysteresis).
  </verify>
  <done>Hysteresis is applied per-layer per-row before policy resolution. --no-hysteresis flag allows disabling. Version hash is computed.</done>
</task>

<task type="auto">
  <name>Task 2: Wire flips, stats, and comovement into the main refresh loop</name>
  <files>
    src/ta_lab2/scripts/regimes/refresh_cmc_regimes.py
  </files>
  <action>
Modify the main() function's per-asset loop to:

1. After compute_regimes_for_id() returns the regime DataFrame:
   a. Call `detect_regime_flips(regime_df)` to get flips DataFrame
   b. Call `compute_regime_stats(regime_df)` to get stats DataFrame
   c. Call `compute_and_write_comovement(engine, asset_id, daily_df)` to compute comovement
      - daily_df is the merged bars+EMAs DataFrame from load_regime_input_data
      - This module internally calls compute_ema_comovement_stats() and lead_lag_max_corr()
   d. If not dry_run:
      - Call `write_regimes_to_db(engine, regime_df)` (already exists from Plan 03)
      - Call `write_flips_to_db(engine, flips_df, ids=[asset_id])` if flips_df not empty
      - Call `write_stats_to_db(engine, stats_df, ids=[asset_id])` if stats_df not empty
      - Call `write_comovement_to_db(engine, como_df, ids=[asset_id])` if como_df not empty
   e. Log summary per asset:
      - Number of regime rows written
      - Number of flips detected
      - Number of unique regime_keys
      - Regime distribution (value_counts of regime_key, top 5)
      - Number of comovement pairs computed

2. Optionally load returns data for stats computation:
   - Query `SELECT id, ts, ret_1d FROM public.cmc_returns WHERE id = :id AND tf = '1D'` (if table exists)
   - Pass to compute_regime_stats(regime_df, returns_df=returns_df)
   - If cmc_returns doesn't exist or is empty, pass returns_df=None (stats will have NULL avg_ret)
   - Wrap in try/except to gracefully handle missing returns table

3. Print final summary after all assets processed:
   - Total assets processed
   - Total regime rows, flips, stats rows, comovement rows written
   - Time elapsed
   - Any assets that failed (with error messages)

Import the new modules at the top:
```python
from ta_lab2.regimes.hysteresis import HysteresisTracker, is_tightening_change
from ta_lab2.scripts.regimes.regime_flips import detect_regime_flips, write_flips_to_db
from ta_lab2.scripts.regimes.regime_stats import compute_regime_stats, write_stats_to_db
from ta_lab2.scripts.regimes.regime_comovement import compute_and_write_comovement, write_comovement_to_db
```
  </action>
  <verify>
```bash
python -m ta_lab2.scripts.regimes.refresh_cmc_regimes --ids 1 --dry-run -v
```
Should show:
- Regime labels computed for id=1
- Flips detected (some number)
- Stats computed (unique regime_keys)
- Comovement pairs computed
- Version hash
- "DRY RUN" messages (no actual writes)

Then test actual write with a single asset:
```bash
python -m ta_lab2.scripts.regimes.refresh_cmc_regimes --ids 1 -v
```
Verify data in DB:
```bash
python -c "
from sqlalchemy import create_engine, text
import os
engine = create_engine(os.environ['TARGET_DB_URL'])
with engine.connect() as conn:
    for t in ['cmc_regimes', 'cmc_regime_flips', 'cmc_regime_stats', 'cmc_regime_comovement']:
        r = conn.execute(text(f'SELECT COUNT(*) FROM public.{t} WHERE id = 1'))
        print(f'{t}: {r.scalar()} rows')
"
```
  </verify>
  <done>
- Complete refresh pipeline writes to all 4 regime tables
- Flips detected and stored with duration_bars
- Stats computed with regime distribution
- Comovement stats computed for EMA pairs and stored
- Returns data optionally merged for avg_ret_1d
- Final summary shows total processed, failures, timing
  </done>
</task>

</tasks>

<verification>
- `python -m ta_lab2.scripts.regimes.refresh_cmc_regimes --ids 1 -v` completes without error
- cmc_regimes has rows for id=1 with non-null regime_key and policy fields
- cmc_regime_flips has transition records (if any regime changes occurred)
- cmc_regime_stats has per-regime summary rows
- cmc_regime_comovement has EMA pair rows
- --no-hysteresis flag works (more frequent regime changes without it)
</verification>

<success_criteria>
- All 4 regime tables populated for at least one asset
- Hysteresis reduces flip count vs --no-hysteresis
- CLI flags work: --no-hysteresis, --min-hold-bars, --policy-file, --cal-scheme
- Script can process multiple assets: --ids 1,52,1027
- Comovement stats reflect EMA alignment/sign agreement as mandated by CONTEXT.md
</success_criteria>

<output>
After completion, create `.planning/phases/27-regime-integration/27-05-SUMMARY.md`
</output>
