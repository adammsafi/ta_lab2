---
phase: 27-regime-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ta_lab2/scripts/regimes/__init__.py
  - src/ta_lab2/scripts/regimes/regime_data_loader.py
autonomous: true

must_haves:
  truths:
    - "EMA pivot function converts long-format DB rows (id, ts, period, ema) to wide-format (id, ts, close_ema_20, close_ema_50, ...) matching labeler expectations"
    - "Bar loader queries the correct calendar tables with time_close AS ts aliasing"
    - "EMA loader handles both cmc_ema_multi_tf_u (daily) and cmc_ema_multi_tf_cal_iso/us (weekly/monthly)"
    - "Loaded bars and pivoted EMAs merge cleanly on (id, ts) for each timeframe"
  artifacts:
    - path: "src/ta_lab2/scripts/regimes/__init__.py"
      provides: "Package init for regime scripts"
    - path: "src/ta_lab2/scripts/regimes/regime_data_loader.py"
      provides: "DB data loading and EMA pivot utilities"
      exports: ["load_bars_for_tf", "load_and_pivot_emas", "load_regime_input_data"]
  key_links:
    - from: "src/ta_lab2/scripts/regimes/regime_data_loader.py"
      to: "cmc_price_bars_multi_tf_cal_iso"
      via: "SQL query with time_close AS ts"
      pattern: "time_close AS ts"
    - from: "src/ta_lab2/scripts/regimes/regime_data_loader.py"
      to: "cmc_ema_multi_tf_cal_iso"
      via: "SQL query with pivot"
      pattern: "pivot_table.*period.*ema"
---

<objective>
Build the data loading and EMA pivot utilities that bridge DB tables to the regime labeler interface.

Purpose: The regime labelers expect wide-format DataFrames with columns like close_ema_20, close_ema_50, close_ema_200. The DB stores EMAs in long format with a period column. This plan builds the critical pivot/rename step that is the #1 integration risk identified in research.
Output: regime_data_loader.py module with load_bars_for_tf(), load_and_pivot_emas(), and load_regime_input_data() functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-regime-integration/27-RESEARCH.md
@src/ta_lab2/regimes/labels.py
@src/ta_lab2/regimes/data_budget.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create regime_data_loader.py with EMA pivot and bar loading</name>
  <files>
    src/ta_lab2/scripts/regimes/__init__.py
    src/ta_lab2/scripts/regimes/regime_data_loader.py
  </files>
  <action>
Create `src/ta_lab2/scripts/regimes/` directory with `__init__.py` (empty).

Create `regime_data_loader.py` with these functions:

**pivot_emas_to_wide(ema_df, periods, price_col="close"):**
- Takes a DataFrame from cmc_ema_multi_tf_cal_iso/us or cmc_ema_multi_tf_u
- Filters to only the specified periods: `ema_df[ema_df["period"].isin(periods)]`
- Pivots: `pivot_table(index=["id", "ts"], columns="period", values="ema")`
- Renames columns to `{price_col}_ema_{period}` format (e.g., close_ema_20, close_ema_50)
- Returns DataFrame with (id, ts, close_ema_X, close_ema_Y, ...)
- CRITICAL: Column is `ema` not `ema_value` in the DB tables. The DB column for the EMA value is just `ema`.

**load_bars_for_tf(engine, asset_id, tf, cal_scheme="iso"):**
- For tf="1M" or tf="1W": Query from `cmc_price_bars_multi_tf_cal_iso` (or `_cal_us` if cal_scheme="us")
  - SELECT id, time_close AS ts, open, high, low, close, volume FROM ... WHERE id = :id AND tf = :tf ORDER BY ts
  - CRITICAL: Calendar bar tables use `time_close` not `ts` -- must alias
- For tf="1D": Query from `cmc_price_bars_multi_tf`
  - SELECT id, time_close AS ts, open, high, low, close, volume FROM ... WHERE id = :id AND tf = '1D' ORDER BY ts
- Return DataFrame sorted by ts

**load_emas_for_tf(engine, asset_id, tf, periods, cal_scheme="iso"):**
- For tf="1M" or tf="1W": Query from `cmc_ema_multi_tf_cal_iso` (or `_cal_us`)
  - SELECT id, ts, period, ema FROM ... WHERE id = :id AND tf = :tf AND period = ANY(:periods) ORDER BY ts
- For tf="1D": Query from `cmc_ema_multi_tf_u`
  - SELECT id, ts, period, ema FROM ... WHERE id = :id AND tf = '1D' AND period = ANY(:periods) AND alignment_source = 'multi_tf' ORDER BY ts
  - CRITICAL: Filter alignment_source = 'multi_tf' for daily EMAs (Pitfall 6 from research)
- Return raw long-format DataFrame

**load_and_pivot_emas(engine, asset_id, tf, periods, price_col="close", cal_scheme="iso"):**
- Calls load_emas_for_tf() then pivot_emas_to_wide()
- Returns wide-format DataFrame ready for labeler consumption

**load_regime_input_data(engine, asset_id, cal_scheme="iso"):**
- Master function that loads all 3 TF datasets for a single asset:
  - monthly_bars + monthly_emas (periods=[12, 24, 48]) -> merged on (id, ts)
  - weekly_bars + weekly_emas (periods=[20, 50, 200]) -> merged on (id, ts)
  - daily_bars + daily_emas (periods=[20, 50, 100]) -> merged on (id, ts)
- Uses pd.merge(left, right, on=["id", "ts"], how="left") for each TF
- Returns dict: {"monthly": df, "weekly": df, "daily": df}
- Each df has columns: id, ts, open, high, low, close, volume, close_ema_X, close_ema_Y, close_ema_Z

EMA period mapping (from RESEARCH.md, confirmed against labels.py defaults):
- L0 Monthly: periods [12, 24, 48] -> close_ema_12, close_ema_24, close_ema_48
- L1 Weekly: periods [20, 50, 200] -> close_ema_20, close_ema_50, close_ema_200
- L2 Daily: periods [20, 50, 100] -> close_ema_20, close_ema_50, close_ema_100

Use sqlalchemy text() for all queries, pass params dict. Use pd.read_sql(). Handle empty results gracefully (return empty DataFrame with correct columns).
  </action>
  <verify>
Write a quick smoke test that imports and exercises the pivot function with synthetic data:
```python
python -c "
import pandas as pd
from ta_lab2.scripts.regimes.regime_data_loader import pivot_emas_to_wide

# Synthetic long-format EMA data
data = {
    'id': [1,1,1,1,1,1],
    'ts': pd.date_range('2025-01-01', periods=2, freq='D').tolist() * 3,
    'period': [20,20,50,50,200,200],
    'ema': [100.0, 101.0, 99.0, 100.0, 95.0, 96.0],
}
df = pd.DataFrame(data)

result = pivot_emas_to_wide(df, periods=[20, 50, 200])
print('Columns:', list(result.columns))
assert 'close_ema_20' in result.columns, 'Missing close_ema_20'
assert 'close_ema_50' in result.columns, 'Missing close_ema_50'
assert 'close_ema_200' in result.columns, 'Missing close_ema_200'
assert len(result) == 2, f'Expected 2 rows, got {len(result)}'
print('PASS: pivot_emas_to_wide works correctly')
print(result)
"
```

Also verify the module imports cleanly:
```python
python -c "from ta_lab2.scripts.regimes.regime_data_loader import load_bars_for_tf, load_and_pivot_emas, load_regime_input_data; print('Import OK')"
```
  </verify>
  <done>
- pivot_emas_to_wide correctly transforms long-format (id, ts, period, ema) to wide-format (id, ts, close_ema_X)
- load_bars_for_tf correctly aliases time_close AS ts for calendar bar tables
- load_emas_for_tf filters alignment_source for daily EMAs
- load_regime_input_data returns 3 merged DataFrames ready for labeler consumption
  </done>
</task>

</tasks>

<verification>
- Module imports without errors
- Pivot function produces correct column names matching labeler expectations
- Calendar bar queries alias time_close to ts
- Daily EMA queries filter alignment_source = 'multi_tf'
- Empty result handling returns empty DataFrames (not crashes)
</verification>

<success_criteria>
- pivot_emas_to_wide converts long-format EMAs to close_ema_{period} columns
- load_regime_input_data returns dict with monthly/weekly/daily DataFrames
- Column names match exactly what labels.py label_layer_*() functions expect
</success_criteria>

<output>
After completion, create `.planning/phases/27-regime-integration/27-02-SUMMARY.md`
</output>
