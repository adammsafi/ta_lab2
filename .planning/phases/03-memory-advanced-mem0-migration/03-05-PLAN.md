---
phase: 03-memory-advanced-mem0-migration
plan: 05
type: execute
wave: 4
depends_on: ["03-04"]
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/memory/api.py
  - tests/orchestrator/test_memory_api.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "REST API exposes memory health endpoint"
    - "Conflict detection available via API"
    - "All 3,763 memories accessible through Mem0 layer"
    - "API returns health status and conflict resolution results"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/memory/api.py"
      provides: "Updated REST API with Mem0, health, and conflict endpoints"
      exports: ["create_memory_api"]
    - path: "tests/orchestrator/test_memory_api.py"
      provides: "Updated API tests"
      min_lines: 120
  key_links:
    - from: "api.py"
      to: "health.py"
      via: "MemoryHealthMonitor"
      pattern: "MemoryHealthMonitor"
    - from: "api.py"
      to: "conflict.py"
      via: "add_with_conflict_check"
      pattern: "add_with_conflict_check"
---

<objective>
Update REST API with Mem0 integration, health monitoring, and conflict detection endpoints

Purpose: Cross-platform access (Claude/ChatGPT/Gemini) needs the new Mem0 features exposed via HTTP. This plan adds health monitoring and conflict detection endpoints to the existing FastAPI application.

Output: Complete REST API with /health/memory, /conflict/check, and /conflict/add endpoints alongside existing search/context endpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-memory-advanced-mem0-migration/03-RESEARCH.md

# Prior plan outputs needed
@src/ta_lab2/tools/ai_orchestrator/memory/api.py
@src/ta_lab2/tools/ai_orchestrator/memory/health.py
@src/ta_lab2/tools/ai_orchestrator/memory/conflict.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add health monitoring endpoint to REST API</name>
  <files>
    src/ta_lab2/tools/ai_orchestrator/memory/api.py
  </files>
  <action>
    1. Add Pydantic models for health endpoints:

       class HealthReportResponse(BaseModel):
           total_memories: int
           healthy: int
           stale: int
           deprecated: int
           missing_metadata: int
           age_distribution: dict[str, int]
           scan_timestamp: str

       class StaleMemoryResponse(BaseModel):
           id: str
           content_preview: str  # First 100 chars
           last_verified: Optional[str]
           age_days: int

       class RefreshRequest(BaseModel):
           memory_ids: list[str] = Field(..., min_items=1, max_items=100)

    2. Add health endpoints:

       @app.get("/api/v1/memory/health", response_model=HealthReportResponse)
       async def get_memory_health(staleness_days: int = 90):
           """Generate memory health report showing stale and deprecated memories."""
           from .health import MemoryHealthMonitor
           monitor = MemoryHealthMonitor(staleness_days=staleness_days)
           report = monitor.generate_health_report()
           return HealthReportResponse(
               total_memories=report.total_memories,
               healthy=report.healthy,
               stale=report.stale,
               deprecated=report.deprecated,
               missing_metadata=report.missing_metadata,
               age_distribution=report.age_distribution,
               scan_timestamp=report.scan_timestamp
           )

       @app.get("/api/v1/memory/health/stale", response_model=list[StaleMemoryResponse])
       async def get_stale_memories(staleness_days: int = 90, limit: int = 50):
           """Get list of stale memories for review."""
           from .health import scan_stale_memories
           stale = scan_stale_memories(staleness_days=staleness_days)[:limit]
           return [
               StaleMemoryResponse(
                   id=m["id"],
                   content_preview=m["content"][:100],
                   last_verified=m.get("last_verified"),
                   age_days=m["age_days"]
               )
               for m in stale
           ]

       @app.post("/api/v1/memory/health/refresh")
       async def refresh_verification(request: RefreshRequest):
           """Mark memories as verified (refreshes last_verified timestamp)."""
           from .health import MemoryHealthMonitor
           monitor = MemoryHealthMonitor()
           count = monitor.refresh_verification(request.memory_ids)
           return {"refreshed": count, "memory_ids": request.memory_ids}

    3. Use lazy imports to avoid circular dependencies
  </action>
  <verify>
    python -c "
from ta_lab2.tools.ai_orchestrator.memory.api import create_memory_api
app = create_memory_api()
routes = [r.path for r in app.routes]
assert '/api/v1/memory/health' in routes, 'Health endpoint missing'
print('Health endpoints added')
"
  </verify>
  <done>
    Health monitoring endpoints added to REST API
  </done>
</task>

<task type="auto">
  <name>Task 2: Add conflict detection endpoints to REST API</name>
  <files>
    src/ta_lab2/tools/ai_orchestrator/memory/api.py
  </files>
  <action>
    1. Add Pydantic models for conflict endpoints:

       class ConflictCheckRequest(BaseModel):
           content: str = Field(..., min_length=1, max_length=10000)
           user_id: str = Field(default="orchestrator")
           similarity_threshold: float = Field(default=0.85, ge=0.5, le=1.0)

       class PotentialConflict(BaseModel):
           memory_id: str
           content: str
           similarity: float
           metadata: Optional[dict] = None

       class ConflictCheckResponse(BaseModel):
           has_conflicts: bool
           conflicts: list[PotentialConflict]

       class AddWithConflictRequest(BaseModel):
           content: str = Field(..., min_length=1, max_length=10000)
           user_id: str = Field(default="orchestrator")
           metadata: Optional[dict] = None
           role: str = Field(default="user")  # For message formatting

       class ConflictResolutionResponse(BaseModel):
           memory_id: str
           operation: str  # ADD, UPDATE, DELETE, NOOP
           confidence: float
           reason: str

    2. Add conflict endpoints:

       @app.post("/api/v1/memory/conflict/check", response_model=ConflictCheckResponse)
       async def check_conflicts(request: ConflictCheckRequest):
           """Check if content conflicts with existing memories."""
           from .conflict import detect_conflicts
           conflicts = detect_conflicts(
               content=request.content,
               user_id=request.user_id,
               similarity_threshold=request.similarity_threshold
           )
           return ConflictCheckResponse(
               has_conflicts=len(conflicts) > 0,
               conflicts=[
                   PotentialConflict(
                       memory_id=c["memory_id"],
                       content=c["content"],
                       similarity=c["similarity"],
                       metadata=c.get("metadata")
                   )
                   for c in conflicts
               ]
           )

       @app.post("/api/v1/memory/conflict/add", response_model=ConflictResolutionResponse)
       async def add_with_conflict_resolution(request: AddWithConflictRequest):
           """Add memory with automatic conflict detection and resolution."""
           from .conflict import add_with_conflict_check

           # Format as message for Mem0
           messages = [
               {"role": request.role, "content": request.content}
           ]

           result = add_with_conflict_check(
               messages=messages,
               user_id=request.user_id,
               metadata=request.metadata
           )

           return ConflictResolutionResponse(
               memory_id=result.memory_id,
               operation=result.operation,
               confidence=result.confidence,
               reason=result.reason
           )

    3. Add error handling for conflict operations
  </action>
  <verify>
    python -c "
from ta_lab2.tools.ai_orchestrator.memory.api import create_memory_api
app = create_memory_api()
routes = [r.path for r in app.routes]
assert '/api/v1/memory/conflict/check' in routes, 'Conflict check endpoint missing'
assert '/api/v1/memory/conflict/add' in routes, 'Conflict add endpoint missing'
print('Conflict endpoints added')
"
  </verify>
  <done>
    Conflict detection endpoints added to REST API
  </done>
</task>

<task type="auto">
  <name>Task 3: Update tests and validate complete API</name>
  <files>
    tests/orchestrator/test_memory_api.py
  </files>
  <action>
    1. Add tests for new endpoints to test_memory_api.py:

       Health endpoint tests:
       - test_get_memory_health_returns_report: Health endpoint returns valid report
       - test_get_memory_health_custom_staleness: Custom staleness_days parameter works
       - test_get_stale_memories_returns_list: Stale memories endpoint returns list
       - test_get_stale_memories_limit: Limit parameter respected
       - test_refresh_verification_updates: Refresh endpoint updates timestamps
       - test_refresh_verification_validation: Invalid request rejected

       Conflict endpoint tests:
       - test_check_conflicts_no_conflicts: Clean content returns has_conflicts=false
       - test_check_conflicts_finds_conflict: Similar content flagged
       - test_check_conflicts_custom_threshold: Custom threshold works
       - test_add_with_conflict_resolution: Add endpoint returns resolution
       - test_add_with_conflict_metadata: Metadata passed through

       Integration tests:
       - test_full_workflow_add_search_health: End-to-end workflow
       - Mark with @pytest.mark.integration

    2. Run updated tests:
       pytest tests/orchestrator/test_memory_api.py -v

    3. Verify OpenAPI docs include new endpoints:
       python -c "
from ta_lab2.tools.ai_orchestrator.memory.api import create_memory_api
app = create_memory_api()
openapi = app.openapi()
paths = list(openapi['paths'].keys())
print(f'API has {len(paths)} endpoints')
for p in paths:
    print(f'  {p}')
"
  </action>
  <verify>
    pytest tests/orchestrator/test_memory_api.py -v --tb=short

    All tests pass. OpenAPI docs show health and conflict endpoints.
  </verify>
  <done>
    Complete API test suite validates health and conflict endpoints
  </done>
</task>

</tasks>

<verification>
1. /api/v1/memory/health returns HealthReportResponse
2. /api/v1/memory/health/stale returns list of stale memories
3. /api/v1/memory/health/refresh updates last_verified
4. /api/v1/memory/conflict/check detects potential conflicts
5. /api/v1/memory/conflict/add resolves conflicts automatically
6. OpenAPI docs (/docs) show all new endpoints
7. All tests pass
</verification>

<success_criteria>
- Health monitoring accessible via REST API
- Conflict detection accessible via REST API
- Claude/ChatGPT/Gemini can query memory health cross-platform
- All endpoints documented in OpenAPI
- Test suite validates all new endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/03-memory-advanced-mem0-migration/03-05-SUMMARY.md`
</output>
