---
phase: 03-memory-advanced-mem0-migration
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/memory/conflict.py
  - tests/orchestrator/test_conflict_detection.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Contradictory memories are detected before they poison context"
    - "Conflict resolution produces ADD, UPDATE, DELETE, or NOOP operation"
    - "Context-dependent truths are distinguished from actual contradictions"
    - "Conflict detection results are logged for review"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/memory/conflict.py"
      provides: "Conflict detection and resolution module"
      exports: ["detect_conflicts", "resolve_conflict", "ConflictResult"]
    - path: "tests/orchestrator/test_conflict_detection.py"
      provides: "Conflict detection tests"
      min_lines: 80
  key_links:
    - from: "conflict.py"
      to: "Mem0Client.add(infer=True)"
      via: "Mem0's LLM-powered resolver"
      pattern: "infer.*True"
    - from: "conflict.py"
      to: "Mem0Client.search"
      via: "semantic similarity check"
      pattern: "\\.search\\("
---

<objective>
Implement conflict detection and resolution for contradictory memories (MEMO-05)

Purpose: Without conflict detection, the memory system can store contradictory facts (e.g., "EMA uses 14 periods" and "EMA uses 20 periods") that poison AI context and cause incorrect decisions. Mem0's infer=True uses LLM-powered resolution to detect and handle these conflicts automatically.

Output: Conflict detection module that identifies contradictions, distinguishes context-dependent truths, and logs resolution decisions for review.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-memory-advanced-mem0-migration/03-RESEARCH.md

# Prior plan outputs needed
@src/ta_lab2/tools/ai_orchestrator/memory/mem0_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict detection module</name>
  <files>
    src/ta_lab2/tools/ai_orchestrator/memory/conflict.py
  </files>
  <action>
    1. Create conflict.py with:

       ConflictResult dataclass:
       - memory_id: str (ID of memory involved)
       - operation: str (ADD, UPDATE, DELETE, NOOP)
       - confidence: float (0.0-1.0, how certain the resolution is)
       - reason: str (why this operation was chosen)
       - original_content: str (the new content that was checked)
       - conflicting_memory: Optional[str] = None (ID of existing memory it conflicts with)
       - conflicting_content: Optional[str] = None (content of conflicting memory)
       - timestamp: str (ISO 8601 when conflict was detected)

       detect_conflicts function:
       - def detect_conflicts(content: str, user_id: str = "orchestrator", client: Mem0Client = None, similarity_threshold: float = 0.85) -> list[dict]
       - Search for semantically similar memories (>threshold)
       - Return list of potential conflicts with similarity scores
       - Each result includes: memory_id, content, similarity, metadata

       resolve_conflict function:
       - def resolve_conflict(new_content: str, user_id: str = "orchestrator", metadata: dict = None, client: Mem0Client = None) -> ConflictResult
       - Uses client.add(messages=[...], user_id=user_id, metadata=metadata, infer=True)
       - Mem0's infer=True automatically:
         - Detects duplicates and contradictions
         - Uses GPT-4o-mini to determine resolution
         - Returns operation type (ADD/UPDATE/DELETE/NOOP)
       - Parse Mem0's response to build ConflictResult
       - Log the resolution for audit trail

       add_with_conflict_check function:
       - def add_with_conflict_check(messages: list[dict], user_id: str = "orchestrator", metadata: dict = None, client: Mem0Client = None, log_conflicts: bool = True) -> dict
       - Wrapper that calls resolve_conflict and logs results
       - If log_conflicts=True, write to .memory/conflict_log.jsonl
       - Return the Mem0 add result

    2. Conflict logging:
       - Append conflicts to .memory/conflict_log.jsonl (one JSON object per line)
       - Include: timestamp, operation, new_content, conflicting_content, reason

    3. Export: detect_conflicts, resolve_conflict, add_with_conflict_check, ConflictResult

    IMPORTANT: Per research, use metadata scoping to distinguish context-dependent truths. If a memory has {"asset_class": "crypto"} and new memory has {"asset_class": "stocks"}, they are NOT in conflict even if values differ.
  </action>
  <verify>
    python -c "
from ta_lab2.tools.ai_orchestrator.memory.conflict import ConflictResult, detect_conflicts
r = ConflictResult(
    memory_id='test', operation='ADD', confidence=0.9, reason='No conflict found',
    original_content='test', timestamp='2026-01-28T00:00:00'
)
print(f'ConflictResult works: {r.operation}')
"
  </verify>
  <done>
    Conflict detection module exists with detect_conflicts, resolve_conflict, and logging
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive conflict detection tests</name>
  <files>
    tests/orchestrator/test_conflict_detection.py
  </files>
  <action>
    1. Create test_conflict_detection.py with:

       Test ConflictResult:
       - test_conflict_result_creation: All fields populated correctly
       - test_conflict_result_defaults: Optional fields default to None

       Test detect_conflicts (with mocks):
       - test_detect_conflicts_finds_similar: Similar memory detected above threshold
       - test_detect_conflicts_ignores_different: Dissimilar memory not flagged
       - test_detect_conflicts_respects_threshold: Custom threshold works
       - test_detect_conflicts_empty_db: Empty database returns empty list

       Test resolve_conflict (with mocks):
       - test_resolve_conflict_add_operation: New unique content returns ADD
       - test_resolve_conflict_update_operation: Contradiction returns UPDATE
       - test_resolve_conflict_noop_duplicate: Exact duplicate returns NOOP
       - test_resolve_conflict_logs_result: Result written to conflict log

       Test context-dependent truths:
       - test_different_contexts_not_conflict: Same fact with different metadata not flagged
         - Memory 1: "EMA is 14 periods" with {"asset_class": "stocks"}
         - Memory 2: "EMA is 20 periods" with {"asset_class": "crypto"}
         - Both should coexist (ADD, not UPDATE)

       Test add_with_conflict_check:
       - test_add_with_conflict_check_wrapper: Calls resolve_conflict
       - test_add_with_conflict_check_logging: Writes to conflict log when enabled
       - test_add_with_conflict_check_no_logging: Skips log when disabled

       Integration test (if API keys available):
       - test_conflict_detection_real_mem0: Real Mem0 resolves contradiction
       - Mark with @pytest.mark.integration

    2. Run tests: pytest tests/orchestrator/test_conflict_detection.py -v
  </action>
  <verify>
    pytest tests/orchestrator/test_conflict_detection.py -v --tb=short

    All tests should pass.
  </verify>
  <done>
    Comprehensive test suite validates conflict detection and resolution logic
  </done>
</task>

<task type="auto">
  <name>Task 3: Update exports and verify integration</name>
  <files>
    src/ta_lab2/tools/ai_orchestrator/memory/__init__.py
  </files>
  <action>
    1. Update memory/__init__.py to export:
       - detect_conflicts, resolve_conflict, add_with_conflict_check, ConflictResult

    2. Create .memory/conflict_log.jsonl if it doesn't exist (empty file)

    3. Verify full import chain works:
       python -c "
from ta_lab2.tools.ai_orchestrator.memory import (
    detect_conflicts,
    resolve_conflict,
    add_with_conflict_check,
    ConflictResult
)
print('All conflict detection exports available')
"

    4. Run full test suite to ensure no regressions:
       pytest tests/orchestrator/ -v --tb=short
  </action>
  <verify>
    pytest tests/orchestrator/ -v --tb=short -k "mem0 or conflict or metadata"

    All related tests pass. Import verification succeeds.
  </verify>
  <done>
    Conflict detection integrated into memory module with all exports available
  </done>
</task>

</tasks>

<verification>
1. ConflictResult dataclass captures resolution details
2. detect_conflicts finds semantically similar memories
3. resolve_conflict uses Mem0's infer=True for LLM-powered resolution
4. Context-dependent truths (different metadata) not flagged as conflicts
5. Conflict log captures resolution decisions for audit
6. All tests pass
</verification>

<success_criteria>
- Conflict detection identifies contradictory memories before they poison context
- Resolution produces clear operation (ADD/UPDATE/DELETE/NOOP)
- Logging provides audit trail for manual review
- Context scoping prevents false positives on valid multi-context facts
- Ready for health monitoring integration
</success_criteria>

<output>
After completion, create `.planning/phases/03-memory-advanced-mem0-migration/03-03-SUMMARY.md`
</output>
