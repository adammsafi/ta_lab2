---
phase: 16-repository-cleanup
plan: 05
type: execute
wave: 2
depends_on: [16-01, 16-02, 16-03]
files_modified:
  - src/ta_lab2/tools/cleanup/similarity.py
  - src/ta_lab2/tools/cleanup/__init__.py
  - .planning/phases/16-repository-cleanup/similarity_report.json
autonomous: true

must_haves:
  truths:
    - "AST-based function similarity detection tool exists"
    - "Three-tier similarity report generated (95%+, 85-95%, 70-85%)"
    - "Similar function pairs flagged for manual review"
    - "Report includes file locations and function names"
  artifacts:
    - path: "src/ta_lab2/tools/cleanup/similarity.py"
      provides: "Function similarity analysis tool"
      exports: ["find_similar_functions", "generate_similarity_report"]
    - path: ".planning/phases/16-repository-cleanup/similarity_report.json"
      provides: "Similarity analysis results"
      contains: "near_exact"
  key_links:
    - from: "similarity.py"
      to: "similarity_report.json"
      via: "generate_similarity_report function"
      pattern: "def generate_similarity_report"
---

<objective>
Create AST-based function similarity tool and generate similarity report for manual review

Purpose: Flag similar functions (70%+ threshold) for potential consolidation per CLEAN-04
Output: Similarity analysis tool, three-tier report of similar function pairs for user review
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-repository-cleanup/16-CONTEXT.md
@.planning/phases/16-repository-cleanup/16-RESEARCH.md

# Cleanup module from Plan 04
@src/ta_lab2/tools/cleanup/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create function similarity analysis module</name>
  <files>
    src/ta_lab2/tools/cleanup/similarity.py
  </files>
  <action>
Create `src/ta_lab2/tools/cleanup/similarity.py` for AST-based similarity analysis:

```python
"""Function similarity detection via AST comparison.

Provides tools for finding similar Python functions across the codebase
using AST parsing and text-based similarity scoring.

Example:
    >>> from ta_lab2.tools.cleanup import find_similar_functions
    >>> similar = find_similar_functions(Path("src"), threshold=0.85)
    >>> print(f"Found {len(similar)} similar function pairs")
"""
import ast
from pathlib import Path
from difflib import SequenceMatcher
from dataclasses import dataclass, field
from typing import Optional
import logging

logger = logging.getLogger(__name__)

# Directories to exclude from scanning
EXCLUDE_DIRS = {".git", ".venv", ".venv311", "__pycache__", ".pytest_cache", ".archive"}


@dataclass
class FunctionInfo:
    """Information about a parsed function."""
    file: Path
    name: str
    lineno: int
    code: str  # Unparsed AST (normalized)
    docstring: Optional[str] = None
    arg_count: int = 0

    @property
    def location(self) -> str:
        return f"{self.file}:{self.name}:{self.lineno}"


@dataclass
class SimilarityMatch:
    """A pair of similar functions."""
    func1: FunctionInfo
    func2: FunctionInfo
    similarity: float
    tier: str  # "near_exact", "similar", "related"

    def __str__(self) -> str:
        return f"{self.func1.location} <-> {self.func2.location} ({self.similarity:.1%} {self.tier})"

    def to_dict(self) -> dict:
        return {
            "func1": {
                "file": str(self.func1.file),
                "name": self.func1.name,
                "lineno": self.func1.lineno,
                "arg_count": self.func1.arg_count,
            },
            "func2": {
                "file": str(self.func2.file),
                "name": self.func2.name,
                "lineno": self.func2.lineno,
                "arg_count": self.func2.arg_count,
            },
            "similarity": self.similarity,
            "tier": self.tier,
        }


def extract_functions(file_path: Path) -> list[FunctionInfo]:
    """Extract all function definitions from a Python file.

    Args:
        file_path: Path to Python file

    Returns:
        List of FunctionInfo for each function in the file
    """
    functions = []

    try:
        code = file_path.read_text(encoding="utf-8")
        tree = ast.parse(code, filename=str(file_path))
    except (SyntaxError, UnicodeDecodeError) as e:
        logger.debug(f"Skipping {file_path}: {e}")
        return []

    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            try:
                # Normalize AST for comparison (remove location info)
                normalized = normalize_ast(node)
                unparsed = ast.unparse(normalized)

                # Extract docstring if present
                docstring = ast.get_docstring(node)

                functions.append(FunctionInfo(
                    file=file_path,
                    name=node.name,
                    lineno=node.lineno,
                    code=unparsed,
                    docstring=docstring,
                    arg_count=len(node.args.args)
                ))
            except Exception as e:
                logger.debug(f"Error processing {node.name} in {file_path}: {e}")
                continue

    return functions


def normalize_ast(node: ast.AST) -> ast.AST:
    """Normalize AST by removing location information.

    This allows comparing functions regardless of where they appear in files.
    """
    for child in ast.walk(node):
        for attr in ("lineno", "col_offset", "end_lineno", "end_col_offset"):
            if hasattr(child, attr):
                delattr(child, attr)
    return node


def compare_functions(func1: FunctionInfo, func2: FunctionInfo) -> float:
    """Compare two functions and return similarity score 0.0-1.0."""
    # Use SequenceMatcher on normalized code
    return SequenceMatcher(None, func1.code, func2.code).ratio()


def classify_similarity(score: float) -> str:
    """Classify similarity score into tier."""
    if score >= 0.95:
        return "near_exact"
    elif score >= 0.85:
        return "similar"
    elif score >= 0.70:
        return "related"
    else:
        return "different"


def find_similar_functions(
    root: Path,
    pattern: str = "**/*.py",
    threshold: float = 0.70,
    exclude_dirs: set[str] | None = None,
    min_lines: int = 5,
) -> list[SimilarityMatch]:
    """Find similar functions across Python files.

    Args:
        root: Root directory to scan
        pattern: Glob pattern for Python files
        threshold: Minimum similarity score (0.0-1.0)
        exclude_dirs: Directory names to exclude
        min_lines: Minimum function lines to consider (skip trivial functions)

    Returns:
        List of SimilarityMatch objects for similar function pairs
    """
    exclude = exclude_dirs or EXCLUDE_DIRS
    all_functions: list[FunctionInfo] = []

    # Collect all functions
    for file_path in root.glob(pattern):
        if not file_path.is_file():
            continue
        if any(part in exclude for part in file_path.parts):
            continue

        functions = extract_functions(file_path)

        # Filter by minimum lines
        for func in functions:
            if func.code.count("\n") >= min_lines - 1:  # -1 because single line has 0 newlines
                all_functions.append(func)

    logger.info(f"Extracted {len(all_functions)} functions from {root}")

    # Compare all pairs (O(n^2) but acceptable for typical codebase size)
    matches: list[SimilarityMatch] = []

    for i, func1 in enumerate(all_functions):
        for func2 in all_functions[i + 1:]:
            # Skip same file same name (likely same function)
            if func1.file == func2.file and func1.name == func2.name:
                continue

            # Quick filter: skip if arg counts differ significantly
            if abs(func1.arg_count - func2.arg_count) > 3:
                continue

            similarity = compare_functions(func1, func2)

            if similarity >= threshold:
                tier = classify_similarity(similarity)
                matches.append(SimilarityMatch(
                    func1=func1,
                    func2=func2,
                    similarity=similarity,
                    tier=tier
                ))

    # Sort by similarity (highest first)
    matches.sort(key=lambda m: m.similarity, reverse=True)

    return matches


def generate_similarity_report(matches: list[SimilarityMatch]) -> dict:
    """Generate JSON-serializable similarity report.

    Returns:
        Report dict with summary and matches categorized by tier
    """
    report = {
        "$schema": "https://ta_lab2.local/schemas/similarity-report/v1.0.0",
        "version": "1.0.0",
        "summary": {
            "total_matches": len(matches),
            "near_exact": len([m for m in matches if m.tier == "near_exact"]),
            "similar": len([m for m in matches if m.tier == "similar"]),
            "related": len([m for m in matches if m.tier == "related"]),
        },
        "near_exact": [],  # 95%+ similarity
        "similar": [],     # 85-95% similarity
        "related": [],     # 70-85% similarity
    }

    for match in matches:
        report[match.tier].append(match.to_dict())

    return report
```
  </action>
  <verify>
- `python -c "from ta_lab2.tools.cleanup.similarity import find_similar_functions; print('OK')"`
- `python -c "from ta_lab2.tools.cleanup.similarity import generate_similarity_report; print('OK')"`
- Module has docstrings and type hints
  </verify>
  <done>
Function similarity analysis module created with AST-based comparison and three-tier classification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update cleanup module exports</name>
  <files>src/ta_lab2/tools/cleanup/__init__.py</files>
  <action>
Update `src/ta_lab2/tools/cleanup/__init__.py` to export similarity functions:

```python
"""Cleanup tools for repository maintenance.

Provides tools for duplicate detection, similarity analysis, and
repository organization.
"""
from ta_lab2.tools.cleanup.duplicates import (
    DuplicateGroup,
    EXCLUDE_DIRS as DUPLICATE_EXCLUDE_DIRS,
    find_duplicates,
    generate_duplicate_report,
)
from ta_lab2.tools.cleanup.similarity import (
    FunctionInfo,
    SimilarityMatch,
    EXCLUDE_DIRS as SIMILARITY_EXCLUDE_DIRS,
    extract_functions,
    find_similar_functions,
    generate_similarity_report,
)

__all__ = [
    # Duplicate detection
    "DuplicateGroup",
    "DUPLICATE_EXCLUDE_DIRS",
    "find_duplicates",
    "generate_duplicate_report",
    # Similarity analysis
    "FunctionInfo",
    "SimilarityMatch",
    "SIMILARITY_EXCLUDE_DIRS",
    "extract_functions",
    "find_similar_functions",
    "generate_similarity_report",
]
```
  </action>
  <verify>
- `python -c "from ta_lab2.tools.cleanup import find_similar_functions, find_duplicates; print('OK')"`
  </verify>
  <done>
Cleanup module exports both duplicate detection and similarity analysis functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run similarity analysis and generate report</name>
  <files>
    .planning/phases/16-repository-cleanup/similarity_report.json
  </files>
  <action>
Run similarity analysis on the src/ directory and generate report:

```python
import json
import logging
from pathlib import Path
from ta_lab2.tools.cleanup import find_similar_functions, generate_similarity_report

# Enable logging to see progress
logging.basicConfig(level=logging.INFO)

# Scan src/ta_lab2 for similar functions
root = Path("src/ta_lab2")
matches = find_similar_functions(
    root,
    pattern="**/*.py",
    threshold=0.70,  # 70% minimum similarity
    min_lines=5,     # Skip trivial functions
)

# Generate report
report = generate_similarity_report(matches)

# Save report
report_path = Path(".planning/phases/16-repository-cleanup/similarity_report.json")
report_path.write_text(json.dumps(report, indent=2))

# Print summary
print(f"\nSimilarity Analysis Complete")
print(f"=" * 40)
print(f"Total function pairs found: {report['summary']['total_matches']}")
print(f"  Near-exact (95%+): {report['summary']['near_exact']}")
print(f"  Similar (85-95%): {report['summary']['similar']}")
print(f"  Related (70-85%): {report['summary']['related']}")

# Show top 5 near-exact matches
if report['near_exact']:
    print(f"\nTop near-exact matches (candidates for consolidation):")
    for match in report['near_exact'][:5]:
        print(f"  {match['func1']['file']}:{match['func1']['name']} <-> {match['func2']['file']}:{match['func2']['name']} ({match['similarity']:.1%})")
```

**Expected outputs:**
- `.planning/phases/16-repository-cleanup/similarity_report.json` with three-tier results
- Console output showing summary counts

**What to do with results:**
This report is for **manual review only** per CONTEXT.md decisions:
- "Similar functions: Flag for manual review - generate report, user decides later"
- No automatic consolidation - user controls refactoring decisions

The report enables future refactoring decisions but does not execute them.
  </action>
  <verify>
- `test -f .planning/phases/16-repository-cleanup/similarity_report.json`
- `cat .planning/phases/16-repository-cleanup/similarity_report.json | python -m json.tool`
- Report contains "$schema", "summary", "near_exact", "similar", "related" keys
  </verify>
  <done>
Similarity analysis complete. Report saved to .planning/phases/16-repository-cleanup/similarity_report.json for manual review.
  </done>
</task>

</tasks>

<verification>
Phase 16 Plan 05 verification:

1. Similarity analysis tool works:
   ```bash
   python -c "
   from pathlib import Path
   from ta_lab2.tools.cleanup import find_similar_functions
   matches = find_similar_functions(Path('src/ta_lab2'), threshold=0.85, min_lines=5)
   print(f'Found {len(matches)} similar pairs at 85%+ threshold')
   "
   ```

2. Report generated with valid schema:
   ```bash
   python -c "
   import json
   r = json.load(open('.planning/phases/16-repository-cleanup/similarity_report.json'))
   print(f'Schema: {r.get(\"$schema\")}')
   print(f'Summary: {r[\"summary\"]}')
   "
   ```

3. Three-tier classification present:
   ```bash
   python -c "
   import json
   r = json.load(open('.planning/phases/16-repository-cleanup/similarity_report.json'))
   assert 'near_exact' in r
   assert 'similar' in r
   assert 'related' in r
   print('All tiers present')
   "
   ```
</verification>

<success_criteria>
- src/ta_lab2/tools/cleanup/similarity.py exists with find_similar_functions() and generate_similarity_report()
- src/ta_lab2/tools/cleanup/__init__.py exports both duplicate and similarity functions
- .planning/phases/16-repository-cleanup/similarity_report.json exists with valid schema
- Report contains three-tier classification (near_exact, similar, related)
- Similar function pairs are documented with file locations, names, and similarity scores
- No automatic consolidation performed (report for manual review only)
</success_criteria>

<output>
After completion, create `.planning/phases/16-repository-cleanup/16-05-SUMMARY.md`
</output>
