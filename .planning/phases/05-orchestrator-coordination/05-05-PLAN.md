---
phase: 05-orchestrator-coordination
plan: 05
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/execution.py
  - tests/orchestrator/test_error_handling.py
autonomous: true

must_haves:
  truths:
    - "Failed tasks retry with exponential backoff"
    - "Fallback routing tries alternative platforms"
    - "Retries exhausted returns error result"
    - "Quota exhaustion triggers fallback"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/execution.py"
      provides: "execute_with_fallback method with retry logic"
      contains: "execute_with_fallback"
    - path: "tests/orchestrator/test_error_handling.py"
      provides: "Error handling test coverage"
      min_lines: 50
  key_links:
    - from: "execution.py"
      to: "routing.py"
      via: "route_cost_optimized"
      pattern: "router.*route"
    - from: "execution.py"
      to: "retry.py"
      via: "retry decorator"
      pattern: "retry_on_rate_limit"
---

<objective>
Add error handling with retries and fallback routing

Purpose: Implement ORCH-08 - retry failed tasks with exponential backoff and route to fallback platforms when primary fails or quota exhausted.

Output: Extended execution.py with execute_with_fallback method and error handling tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-orchestrator-coordination/05-CONTEXT.md
@.planning/phases/05-orchestrator-coordination/05-01-SUMMARY.md
@.planning/phases/05-orchestrator-coordination/05-02-SUMMARY.md
@src/ta_lab2/tools/ai_orchestrator/execution.py
@src/ta_lab2/tools/ai_orchestrator/retry.py
@src/ta_lab2/tools/ai_orchestrator/routing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add execute_with_fallback to AsyncOrchestrator</name>
  <files>src/ta_lab2/tools/ai_orchestrator/execution.py</files>
  <action>
Extend AsyncOrchestrator class with error handling and fallback routing:

```python
# Add to imports at top
from typing import Set

# Add constants
MAX_RETRIES = 3
RETRY_BASE_DELAY = 1.0  # seconds

# Add to AsyncOrchestrator class:

async def execute_with_fallback(
    self,
    task: Task,
    max_retries: int = MAX_RETRIES,
    exclude_platforms: Optional[Set[Platform]] = None,
) -> Result:
    """
    Execute task with retry logic and fallback routing.

    Per ORCH-08: Retry failed tasks and route to fallback platforms.

    Strategy:
    1. Route to best platform via cost-optimized routing
    2. On failure, retry with exponential backoff (up to max_retries)
    3. If retries exhausted, try next platform in cost priority order
    4. If all platforms fail, return error result

    Args:
        task: Task to execute
        max_retries: Max retries per platform (default: 3)
        exclude_platforms: Platforms to skip (e.g., already tried)

    Returns:
        Result from successful execution or final error
    """
    exclude = exclude_platforms or set()
    attempted_platforms: List[Platform] = []
    last_error: Optional[str] = None

    # Get all available platforms in cost order
    platforms = self._get_platforms_by_cost(exclude)

    for platform in platforms:
        if platform in exclude:
            continue

        attempted_platforms.append(platform)
        adapter = self._adapters.get(platform)

        if not adapter:
            last_error = f"No adapter for {platform.value}"
            continue

        # Try this platform with retries
        result = await self._execute_with_retries(
            task, adapter, platform, max_retries
        )

        if result.success:
            return result

        # Platform failed after retries, try next
        last_error = result.error

    # All platforms failed
    return Result(
        task=task,
        platform=attempted_platforms[-1] if attempted_platforms else Platform.CLAUDE_CODE,
        output="",
        success=False,
        status=TaskStatus.FAILED,
        error=f"All platforms failed. Last error: {last_error}. Tried: {[p.value for p in attempted_platforms]}",
    )


async def _execute_with_retries(
    self,
    task: Task,
    adapter: AsyncBasePlatformAdapter,
    platform: Platform,
    max_retries: int,
) -> Result:
    """
    Execute task on single platform with exponential backoff retries.

    Args:
        task: Task to execute
        adapter: Adapter instance
        platform: Platform being used
        max_retries: Max retry attempts

    Returns:
        Result from execution (success or final failure)
    """
    last_result: Optional[Result] = None

    for attempt in range(max_retries + 1):  # +1 for initial attempt
        try:
            # Submit and wait for result
            task_id = await adapter.submit_task(task)
            timeout = task.constraints.timeout_seconds if task.constraints else 300
            result = await adapter.get_result(task_id, timeout=timeout)

            if result.success:
                return result

            last_result = result

            # Check if error is retryable
            if not self._is_retryable_error(result.error):
                return result

            # Exponential backoff before retry
            if attempt < max_retries:
                delay = RETRY_BASE_DELAY * (2 ** attempt)
                await asyncio.sleep(delay)

        except asyncio.CancelledError:
            raise  # Always propagate cancellation
        except asyncio.TimeoutError:
            last_result = Result(
                task=task,
                platform=platform,
                output="",
                success=False,
                status=TaskStatus.FAILED,
                error=f"Timeout on attempt {attempt + 1}",
            )
            if attempt < max_retries:
                delay = RETRY_BASE_DELAY * (2 ** attempt)
                await asyncio.sleep(delay)
        except Exception as e:
            last_result = Result(
                task=task,
                platform=platform,
                output="",
                success=False,
                status=TaskStatus.FAILED,
                error=str(e),
            )
            if attempt < max_retries:
                delay = RETRY_BASE_DELAY * (2 ** attempt)
                await asyncio.sleep(delay)

    return last_result or self._error_result(task, RuntimeError("No result after retries"))


def _is_retryable_error(self, error: Optional[str]) -> bool:
    """
    Check if error is retryable.

    Retryable: rate limits, timeouts, transient server errors
    Not retryable: auth errors, invalid requests, quota exhausted
    """
    if not error:
        return False

    error_lower = error.lower()

    # Retryable patterns
    retryable_patterns = [
        "rate limit",
        "timeout",
        "timed out",
        "503",
        "502",
        "500",
        "server error",
        "connection error",
        "temporarily unavailable",
    ]

    for pattern in retryable_patterns:
        if pattern in error_lower:
            return True

    # Non-retryable patterns
    non_retryable_patterns = [
        "quota exhausted",
        "quota exceeded",
        "unauthorized",
        "invalid api key",
        "authentication",
        "permission denied",
        "invalid request",
    ]

    for pattern in non_retryable_patterns:
        if pattern in error_lower:
            return False

    # Default: retry unknown errors
    return True


def _get_platforms_by_cost(
    self,
    exclude: Set[Platform] = None
) -> List[Platform]:
    """
    Get platforms ordered by cost priority.

    Per ORCH-04: Gemini free first, then subscriptions, then paid.
    """
    from .routing import COST_TIERS

    exclude = exclude or set()
    platforms = []
    seen = set()

    for tier in sorted(COST_TIERS, key=lambda t: t["priority"]):
        platform = tier["platform"]
        if platform not in seen and platform not in exclude:
            # Check if we have an adapter for this platform
            if platform in self._adapters:
                platforms.append(platform)
                seen.add(platform)

    return platforms


async def execute_parallel_with_fallback(
    self,
    tasks: List[Task],
    max_retries: int = MAX_RETRIES,
    max_concurrent: Optional[int] = None,
) -> AggregatedResult:
    """
    Execute tasks in parallel with per-task fallback routing.

    Combines parallel execution with individual task retry/fallback.
    """
    limit = max_concurrent or self._max_concurrent
    semaphore = Semaphore(limit)

    results: Dict[int, Result] = {}

    async def execute_one(idx: int, task: Task):
        async with semaphore:
            result = await self.execute_with_fallback(task, max_retries)
            results[idx] = result

    try:
        async with TaskGroup() as tg:
            for idx, task in enumerate(tasks):
                tg.create_task(execute_one(idx, task))
    except* Exception:
        pass  # Results already collected

    ordered = [results.get(i, self._error_result(tasks[i], RuntimeError("Unknown")))
               for i in range(len(tasks))]

    return aggregate_results(ordered)
```
  </action>
  <verify>
Import verification: `python -c "from ta_lab2.tools.ai_orchestrator.execution import AsyncOrchestrator; print('OK')"`
  </verify>
  <done>
execute_with_fallback method exists with retry logic and fallback routing; _is_retryable_error correctly classifies errors; _get_platforms_by_cost returns cost-ordered platforms
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for error handling</name>
  <files>tests/orchestrator/test_error_handling.py</files>
  <action>
Create test file with comprehensive coverage:

```python
"""Tests for error handling, retries, and fallback routing."""
import asyncio
import pytest
from unittest.mock import AsyncMock, Mock, patch

from ta_lab2.tools.ai_orchestrator.execution import (
    AsyncOrchestrator,
    MAX_RETRIES,
    RETRY_BASE_DELAY,
)
from ta_lab2.tools.ai_orchestrator.core import Task, Result, TaskType, Platform, TaskStatus


class TestRetryLogic:
    """Test retry with exponential backoff."""

    @pytest.mark.asyncio
    async def test_retries_on_transient_error(self):
        """Retries when error is retryable."""
        mock_adapter = AsyncMock()

        # First two calls fail, third succeeds
        mock_adapter.submit_task.return_value = "task_123"
        mock_adapter.get_result.side_effect = [
            Result(task=Mock(), platform=Platform.GEMINI, output="", success=False, error="rate limit"),
            Result(task=Mock(), platform=Platform.GEMINI, output="", success=False, error="timeout"),
            Result(task=Mock(), platform=Platform.GEMINI, output="Success!", success=True),
        ]

        orch = AsyncOrchestrator(
            adapters={Platform.GEMINI: mock_adapter},
            max_concurrent=1,
        )

        task = Task(type=TaskType.CODE_GENERATION, prompt="Test")

        with patch.object(orch, '_router') as mock_router:
            mock_router.route_cost_optimized.return_value = Platform.GEMINI

            result = await orch._execute_with_retries(task, mock_adapter, Platform.GEMINI, 3)

        assert result.success is True
        assert mock_adapter.get_result.call_count == 3

    @pytest.mark.asyncio
    async def test_no_retry_on_auth_error(self):
        """Does not retry authentication errors."""
        mock_adapter = AsyncMock()
        mock_adapter.submit_task.return_value = "task_123"
        mock_adapter.get_result.return_value = Result(
            task=Mock(), platform=Platform.GEMINI, output="", success=False,
            error="Invalid API key"
        )

        orch = AsyncOrchestrator(adapters={Platform.GEMINI: mock_adapter})
        task = Task(type=TaskType.CODE_GENERATION, prompt="Test")

        result = await orch._execute_with_retries(task, mock_adapter, Platform.GEMINI, 3)

        assert result.success is False
        assert mock_adapter.get_result.call_count == 1  # No retries


class TestFallbackRouting:
    """Test fallback to alternative platforms."""

    @pytest.mark.asyncio
    async def test_falls_back_on_platform_failure(self):
        """Tries next platform when first fails."""
        gemini_adapter = AsyncMock()
        gemini_adapter.submit_task.return_value = "g_task"
        gemini_adapter.get_result.return_value = Result(
            task=Mock(), platform=Platform.GEMINI, output="", success=False,
            error="Quota exhausted"
        )

        claude_adapter = AsyncMock()
        claude_adapter.submit_task.return_value = "c_task"
        claude_adapter.get_result.return_value = Result(
            task=Mock(), platform=Platform.CLAUDE_CODE, output="Success", success=True
        )

        orch = AsyncOrchestrator(
            adapters={
                Platform.GEMINI: gemini_adapter,
                Platform.CLAUDE_CODE: claude_adapter,
            },
        )

        task = Task(type=TaskType.CODE_GENERATION, prompt="Test")

        with patch.object(orch, '_get_platforms_by_cost', return_value=[Platform.GEMINI, Platform.CLAUDE_CODE]):
            result = await orch.execute_with_fallback(task, max_retries=0)

        assert result.success is True
        assert result.platform == Platform.CLAUDE_CODE

    @pytest.mark.asyncio
    async def test_returns_error_when_all_fail(self):
        """Returns error result when all platforms fail."""
        mock_adapter = AsyncMock()
        mock_adapter.submit_task.return_value = "task_123"
        mock_adapter.get_result.return_value = Result(
            task=Mock(), platform=Platform.GEMINI, output="", success=False,
            error="Permanent failure"
        )

        orch = AsyncOrchestrator(adapters={Platform.GEMINI: mock_adapter})
        task = Task(type=TaskType.CODE_GENERATION, prompt="Test")

        with patch.object(orch, '_get_platforms_by_cost', return_value=[Platform.GEMINI]):
            result = await orch.execute_with_fallback(task, max_retries=1)

        assert result.success is False
        assert "All platforms failed" in result.error


class TestIsRetryableError:
    """Test error classification."""

    def test_rate_limit_is_retryable(self):
        """Rate limit errors are retryable."""
        orch = AsyncOrchestrator()
        assert orch._is_retryable_error("Rate limit exceeded") is True

    def test_timeout_is_retryable(self):
        """Timeout errors are retryable."""
        orch = AsyncOrchestrator()
        assert orch._is_retryable_error("Request timed out") is True

    def test_auth_error_not_retryable(self):
        """Auth errors are not retryable."""
        orch = AsyncOrchestrator()
        assert orch._is_retryable_error("Invalid API key") is False

    def test_quota_exhausted_not_retryable(self):
        """Quota exhaustion is not retryable (should fallback instead)."""
        orch = AsyncOrchestrator()
        assert orch._is_retryable_error("Quota exhausted") is False


class TestGetPlatformsByCost:
    """Test cost-ordered platform list."""

    def test_returns_available_platforms(self):
        """Returns only platforms with adapters."""
        mock_adapter = Mock()
        orch = AsyncOrchestrator(adapters={Platform.GEMINI: mock_adapter})

        with patch("ta_lab2.tools.ai_orchestrator.execution.COST_TIERS", [
            {"platform": Platform.GEMINI, "priority": 1},
            {"platform": Platform.CLAUDE_CODE, "priority": 2},
        ]):
            platforms = orch._get_platforms_by_cost()

        assert Platform.GEMINI in platforms
        assert Platform.CLAUDE_CODE not in platforms  # No adapter

    def test_respects_exclude_set(self):
        """Excludes specified platforms."""
        orch = AsyncOrchestrator(adapters={
            Platform.GEMINI: Mock(),
            Platform.CLAUDE_CODE: Mock(),
        })

        with patch("ta_lab2.tools.ai_orchestrator.execution.COST_TIERS", [
            {"platform": Platform.GEMINI, "priority": 1},
            {"platform": Platform.CLAUDE_CODE, "priority": 2},
        ]):
            platforms = orch._get_platforms_by_cost(exclude={Platform.GEMINI})

        assert Platform.GEMINI not in platforms
        assert Platform.CLAUDE_CODE in platforms
```
  </action>
  <verify>
Run tests: `pytest tests/orchestrator/test_error_handling.py -v`
  </verify>
  <done>
All error handling tests pass, covering retry logic, fallback routing, error classification, and platform ordering
  </done>
</task>

</tasks>

<verification>
1. Import verification: `python -c "from ta_lab2.tools.ai_orchestrator.execution import AsyncOrchestrator"`
2. Test suite: `pytest tests/orchestrator/test_error_handling.py -v`
3. All orchestrator tests pass: `pytest tests/orchestrator/ -v`
</verification>

<success_criteria>
- execute_with_fallback retries transient errors with exponential backoff
- Fallback routing tries next platform when current fails
- _is_retryable_error correctly classifies retryable vs non-retryable errors
- Auth/quota errors trigger immediate fallback (no retry)
- All platforms failed returns comprehensive error message
</success_criteria>

<output>
After completion, create `.planning/phases/05-orchestrator-coordination/05-05-SUMMARY.md`
</output>
