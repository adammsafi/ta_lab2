---
phase: 05-orchestrator-coordination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/routing.py
  - tests/orchestrator/test_cost_routing.py
autonomous: true

must_haves:
  truths:
    - "Routing prioritizes Gemini free tier first"
    - "Subscriptions used when free tier exhausted"
    - "Paid APIs are last resort"
    - "Platform hints are advisory (fallback allowed)"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/routing.py"
      provides: "Cost-optimized TaskRouter.route_cost_optimized method"
      contains: "route_cost_optimized"
    - path: "tests/orchestrator/test_cost_routing.py"
      provides: "Cost routing test coverage"
      min_lines: 50
  key_links:
    - from: "routing.py"
      to: "quota.py"
      via: "QuotaTracker.can_use"
      pattern: "quota.*can_use"
---

<objective>
Enhance TaskRouter with cost-optimized routing logic

Purpose: Implement ORCH-04 requirement - route tasks to cheapest available platform (Gemini CLI free tier first, then subscriptions, then paid APIs) while respecting platform hints as advisory.

Output: Extended routing.py with route_cost_optimized method and comprehensive tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-orchestrator-coordination/05-CONTEXT.md
@.planning/phases/05-orchestrator-coordination/05-RESEARCH.md
@src/ta_lab2/tools/ai_orchestrator/routing.py
@src/ta_lab2/tools/ai_orchestrator/quota.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cost-optimized routing method to TaskRouter</name>
  <files>src/ta_lab2/tools/ai_orchestrator/routing.py</files>
  <action>
Extend TaskRouter class with route_cost_optimized method that:

1. Define COST_TIERS constant (or update existing COST_PRIORITY):
```python
COST_TIERS = [
    # Tier 1: Gemini CLI free tier (1500 req/day) - ALWAYS try first
    {"platform": Platform.GEMINI, "quota_key": "gemini_cli", "cost_per_req": 0.0, "priority": 1},

    # Tier 2: Subscription-included (already paid, effectively free)
    {"platform": Platform.CLAUDE_CODE, "quota_key": "claude_code", "cost_per_req": 0.0, "priority": 2},
    {"platform": Platform.CHATGPT, "quota_key": "chatgpt_plus", "cost_per_req": 0.0, "priority": 2},

    # Tier 3: Paid APIs (last resort)
    {"platform": Platform.GEMINI, "quota_key": "gemini_api", "cost_per_req": 0.0001, "priority": 3},
    {"platform": Platform.CHATGPT, "quota_key": "openai_api", "cost_per_req": 0.002, "priority": 3},
]
```

2. Add route_cost_optimized method:
```python
def route_cost_optimized(self, task: Task, quota_tracker: QuotaTracker) -> Platform:
    """
    Route to cheapest available platform per ROADMAP success criteria #1.

    Priority:
    1. Honor platform_hint if specified and available (advisory - fallback allowed)
    2. Try Gemini CLI free tier first
    3. Fall back to subscriptions (Claude Code, ChatGPT Plus)
    4. Last resort: paid APIs

    Args:
        task: Task to route
        quota_tracker: QuotaTracker instance

    Returns:
        Platform enum for cheapest available platform

    Raises:
        RuntimeError: If no platforms available (all quotas exhausted)
    """
```

3. Implementation logic:
- If task.platform_hint is set and quota_tracker.can_use(hint) returns True, return hint
- Otherwise iterate through COST_TIERS sorted by priority
- For each tier, check quota_tracker.can_use(tier["quota_key"])
- Return first available platform
- If all exhausted, raise RuntimeError with helpful message

4. Add warn_quota_threshold method:
```python
def warn_quota_threshold(self, quota_tracker: QuotaTracker, threshold: int = 90) -> list[str]:
    """Return warning messages for quotas above threshold percent."""
```

5. Update existing route() method to call route_cost_optimized internally (or make it an optional flag)
  </action>
  <verify>
Import the module: `python -c "from ta_lab2.tools.ai_orchestrator.routing import TaskRouter, COST_TIERS; print('COST_TIERS:', len(COST_TIERS))"`
  </verify>
  <done>
TaskRouter.route_cost_optimized method exists and returns Platform based on cost priority, COST_TIERS constant defined with correct priority order
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for cost routing</name>
  <files>tests/orchestrator/test_cost_routing.py</files>
  <action>
Create test file with comprehensive coverage:

```python
"""Tests for cost-optimized routing."""
import pytest
from unittest.mock import Mock, patch

from ta_lab2.tools.ai_orchestrator.routing import TaskRouter, COST_TIERS
from ta_lab2.tools.ai_orchestrator.core import Task, TaskType, Platform
from ta_lab2.tools.ai_orchestrator.quota import QuotaTracker


class TestCostTiers:
    """Test COST_TIERS configuration."""

    def test_gemini_free_is_first_priority(self):
        """Gemini CLI free tier should be priority 1."""

    def test_subscriptions_are_second_priority(self):
        """Claude Code and ChatGPT Plus should be priority 2."""

    def test_paid_apis_are_last_priority(self):
        """Paid APIs should be priority 3."""


class TestRouteCostOptimized:
    """Test TaskRouter.route_cost_optimized method."""

    def test_routes_to_gemini_free_first_when_available(self):
        """When Gemini free tier has quota, route there."""

    def test_honors_platform_hint_when_available(self):
        """Platform hint should be respected if quota available."""

    def test_falls_back_from_hint_when_quota_exhausted(self):
        """Should fall back when hinted platform has no quota."""

    def test_routes_to_subscription_when_free_exhausted(self):
        """When Gemini free exhausted, route to Claude Code or ChatGPT."""

    def test_routes_to_paid_api_as_last_resort(self):
        """Paid APIs only when all free/subscription exhausted."""

    def test_raises_when_all_exhausted(self):
        """RuntimeError when no platforms available."""


class TestQuotaWarnings:
    """Test quota threshold warning functionality."""

    def test_warn_at_90_percent(self):
        """Warn when quota above 90%."""

    def test_no_warn_below_threshold(self):
        """No warning when below threshold."""
```

Each test should:
- Create mock QuotaTracker with controlled can_use() return values
- Verify correct platform selection
- Test edge cases (exact threshold, multiple exhausted)
  </action>
  <verify>
Run tests: `pytest tests/orchestrator/test_cost_routing.py -v`
  </verify>
  <done>
All cost routing tests pass, covering priority order, hint handling, fallback behavior, and quota warnings
  </done>
</task>

</tasks>

<verification>
1. Import verification: `python -c "from ta_lab2.tools.ai_orchestrator.routing import TaskRouter, COST_TIERS"`
2. Test suite: `pytest tests/orchestrator/test_cost_routing.py -v`
3. All existing tests still pass: `pytest tests/orchestrator/ -v`
</verification>

<success_criteria>
- COST_TIERS constant defines correct priority order (Gemini free=1, subscriptions=2, paid=3)
- route_cost_optimized method routes to cheapest available platform
- Platform hints are advisory (fallback allowed per CONTEXT.md decision)
- Tests cover all routing scenarios
- No regressions in existing routing tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-orchestrator-coordination/05-01-SUMMARY.md`
</output>
