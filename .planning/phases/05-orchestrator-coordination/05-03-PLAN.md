---
phase: 05-orchestrator-coordination
plan: 03
type: execute
wave: 2
depends_on: ["05-02"]
files_modified:
  - src/ta_lab2/tools/ai_orchestrator/handoff.py
  - tests/orchestrator/test_handoff.py
autonomous: true

must_haves:
  truths:
    - "Task A can spawn Task B with context pointer"
    - "Full context stored in memory, summary passed inline"
    - "Child task fails immediately if memory lookup fails"
    - "Task chains tracked for cost attribution"
  artifacts:
    - path: "src/ta_lab2/tools/ai_orchestrator/handoff.py"
      provides: "HandoffContext, TaskChain, spawn_child_task"
      exports: ["HandoffContext", "TaskChain", "ChainTracker", "spawn_child_task", "load_handoff_context"]
    - path: "tests/orchestrator/test_handoff.py"
      provides: "Handoff test coverage"
      min_lines: 60
  key_links:
    - from: "handoff.py"
      to: "memory/update.py"
      via: "add_memory"
      pattern: "add_memory"
    - from: "handoff.py"
      to: "memory/query.py"
      via: "get_memory_by_id"
      pattern: "get_memory_by_id"
---

<objective>
Implement AI-to-AI handoff mechanism with memory integration

Purpose: Implement ORCH-07 - Task A writes to memory, spawns Task B with context pointer. Uses hybrid (pointer + summary) pattern per CONTEXT.md decision.

Output: New handoff.py module with HandoffContext, TaskChain, spawn_child_task, and tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-orchestrator-coordination/05-CONTEXT.md
@.planning/phases/05-orchestrator-coordination/05-RESEARCH.md
@.planning/phases/05-orchestrator-coordination/05-02-SUMMARY.md
@src/ta_lab2/tools/ai_orchestrator/core.py
@src/ta_lab2/tools/ai_orchestrator/memory/update.py
@src/ta_lab2/tools/ai_orchestrator/memory/query.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create handoff module with HandoffContext and TaskChain</name>
  <files>src/ta_lab2/tools/ai_orchestrator/handoff.py</files>
  <action>
Create new handoff.py module:

```python
"""AI-to-AI handoff mechanism for task chains."""

from __future__ import annotations

import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Dict, List, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from .core import Task, Result

from .core import Task, Result, Platform, TaskType


@dataclass
class HandoffContext:
    """
    Context passed between tasks in a chain.

    Per CONTEXT.md: Hybrid (pointer + summary) - Task A includes small summary
    inline for quick reference, full context stored in memory with pointer.
    """
    memory_id: str              # Pointer to full context in memory
    summary: str                # Brief inline summary for quick reference
    parent_task_id: str         # Track genealogy (Task A -> B -> C)
    chain_id: str               # Workflow-level ID for cost attribution
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def to_context_dict(self) -> dict:
        """Convert to dict for task.context field."""
        return {
            "handoff_memory_id": self.memory_id,
            "handoff_summary": self.summary,
            "parent_task_id": self.parent_task_id,
            "chain_id": self.chain_id,
        }


@dataclass
class TaskChain:
    """
    Tracks a workflow's task genealogy.

    Per CONTEXT.md: Explicit chain tracking for debugging, visualization,
    and cost attribution.
    """
    chain_id: str
    tasks: List[str] = field(default_factory=list)  # task_ids in order
    total_cost: float = 0.0
    total_tokens: int = 0
    root_task_id: Optional[str] = None
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def add_task(self, task_id: str, cost: float = 0.0, tokens: int = 0):
        """Add a task to this chain."""
        self.tasks.append(task_id)
        self.total_cost += cost
        self.total_tokens += tokens
        if self.root_task_id is None:
            self.root_task_id = task_id

    @property
    def depth(self) -> int:
        """Return chain depth (number of tasks)."""
        return len(self.tasks)


class ChainTracker:
    """
    Manages task chains for workflow cost attribution.

    Maintains in-memory tracking of active chains. For persistence,
    use CostTracker (Plan 04) which writes to SQLite.
    """

    def __init__(self):
        self._chains: Dict[str, TaskChain] = {}

    def get_or_create_chain(self, chain_id: str) -> TaskChain:
        """Get existing chain or create new one."""
        if chain_id not in self._chains:
            self._chains[chain_id] = TaskChain(chain_id=chain_id)
        return self._chains[chain_id]

    def record_task(self, chain_id: str, task_id: str, cost: float = 0.0, tokens: int = 0):
        """Record a task in a chain."""
        chain = self.get_or_create_chain(chain_id)
        chain.add_task(task_id, cost, tokens)

    def get_chain(self, chain_id: str) -> Optional[TaskChain]:
        """Get chain by ID, or None if not found."""
        return self._chains.get(chain_id)

    def get_chain_cost(self, chain_id: str) -> float:
        """Get total cost for a workflow chain."""
        chain = self._chains.get(chain_id)
        return chain.total_cost if chain else 0.0

    def get_all_chains(self) -> Dict[str, TaskChain]:
        """Get all tracked chains."""
        return dict(self._chains)


async def spawn_child_task(
    parent_result: Result,
    child_prompt: str,
    child_type: TaskType = None,
    chain_id: Optional[str] = None,
    max_summary_length: int = 500,
) -> tuple[Task, HandoffContext]:
    """
    Create child task with context from parent.

    Per CONTEXT.md: Hybrid (pointer + summary) - stores full context in memory,
    passes pointer + brief summary to child task.

    Args:
        parent_result: Result from parent task
        child_prompt: Prompt for child task
        child_type: TaskType for child (defaults to parent type)
        chain_id: Optional chain ID (generated if not provided)
        max_summary_length: Max chars for inline summary (default 500)

    Returns:
        Tuple of (child_task, handoff_context)

    Raises:
        RuntimeError: If memory storage fails
    """
    # Import here to avoid circular dependency
    from .memory.update import add_memory

    # Generate IDs
    parent_task_id = parent_result.task.task_id or "unknown"
    memory_id = f"handoff_{parent_task_id}_{uuid.uuid4().hex[:8]}"
    effective_chain_id = chain_id or parent_result.task.metadata.get("chain_id") or uuid.uuid4().hex

    # Store full context in memory
    full_context = f"Parent task output:\n{parent_result.output}"
    try:
        add_memory(
            memory_id=memory_id,
            content=full_context,
            metadata={
                "type": "handoff",
                "parent_task_id": parent_task_id,
                "chain_id": effective_chain_id,
                "created_at": datetime.now(timezone.utc).isoformat(),
            }
        )
    except Exception as e:
        raise RuntimeError(f"Failed to store handoff context in memory: {e}")

    # Create brief summary for inline reference
    output_text = parent_result.output
    if len(output_text) > max_summary_length:
        summary = output_text[:max_summary_length] + "..."
    else:
        summary = output_text

    # Create handoff context
    handoff = HandoffContext(
        memory_id=memory_id,
        summary=summary,
        parent_task_id=parent_task_id,
        chain_id=effective_chain_id,
    )

    # Create child task with context pointer
    child_task = Task(
        type=child_type or parent_result.task.type,
        prompt=child_prompt,
        context=handoff.to_context_dict(),
        platform_hint=parent_result.task.platform_hint,  # Preserve hint
        metadata={"chain_id": effective_chain_id},
    )

    return child_task, handoff


async def load_handoff_context(task: Task) -> str:
    """
    Load full context from memory for a child task.

    Per CONTEXT.md: Fail Task B immediately if context can't be retrieved.

    Args:
        task: Child task with handoff context

    Returns:
        Full context string from memory

    Raises:
        RuntimeError: If memory lookup fails (per CONTEXT.md decision)
    """
    from .memory.query import get_memory_by_id

    memory_id = task.context.get("handoff_memory_id")
    if not memory_id:
        raise RuntimeError("Task has no handoff_memory_id in context")

    result = get_memory_by_id(memory_id)
    if result is None:
        # Per CONTEXT.md: Fail Task B immediately if memory lookup fails
        raise RuntimeError(f"Handoff context not found in memory: {memory_id}")

    return result.get("content", "") if isinstance(result, dict) else str(result)


def has_handoff_context(task: Task) -> bool:
    """Check if task has handoff context from parent."""
    return "handoff_memory_id" in task.context
```
  </action>
  <verify>
First verify memory modules are available, then verify handoff module imports:
```bash
python -c "from ta_lab2.tools.ai_orchestrator.memory.update import add_memory; from ta_lab2.tools.ai_orchestrator.memory.query import get_memory_by_id; print('Memory modules available')"
python -c "from ta_lab2.tools.ai_orchestrator.handoff import HandoffContext, TaskChain, ChainTracker, spawn_child_task, load_handoff_context, has_handoff_context; print('OK')"
```
  </verify>
  <done>
HandoffContext, TaskChain, ChainTracker classes exist; spawn_child_task stores context in memory and returns child task with pointer; load_handoff_context retrieves context or fails fast
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for handoff mechanism</name>
  <files>tests/orchestrator/test_handoff.py</files>
  <action>
Create test file with comprehensive coverage:

```python
"""Tests for AI-to-AI handoff mechanism."""
import pytest
from unittest.mock import AsyncMock, Mock, patch
from datetime import datetime, timezone

from ta_lab2.tools.ai_orchestrator.handoff import (
    HandoffContext,
    TaskChain,
    ChainTracker,
    spawn_child_task,
    load_handoff_context,
    has_handoff_context,
)
from ta_lab2.tools.ai_orchestrator.core import Task, Result, TaskType, Platform


class TestHandoffContext:
    """Test HandoffContext dataclass."""

    def test_to_context_dict(self):
        """Converts to dict with correct keys."""
        ctx = HandoffContext(
            memory_id="mem_123",
            summary="Brief summary",
            parent_task_id="task_abc",
            chain_id="chain_xyz",
        )
        d = ctx.to_context_dict()
        assert d["handoff_memory_id"] == "mem_123"
        assert d["handoff_summary"] == "Brief summary"
        assert d["parent_task_id"] == "task_abc"
        assert d["chain_id"] == "chain_xyz"


class TestTaskChain:
    """Test TaskChain dataclass."""

    def test_add_task_sets_root(self):
        """First task becomes root_task_id."""

    def test_add_task_accumulates_cost(self):
        """Total cost accumulates from all tasks."""

    def test_depth_property(self):
        """Depth returns number of tasks in chain."""


class TestChainTracker:
    """Test ChainTracker class."""

    def test_get_or_create_chain_creates_new(self):
        """Creates new chain if not exists."""

    def test_get_or_create_chain_returns_existing(self):
        """Returns existing chain if exists."""

    def test_record_task_adds_to_chain(self):
        """record_task adds task to chain."""

    def test_get_chain_cost_returns_total(self):
        """get_chain_cost returns accumulated total."""


class TestSpawnChildTask:
    """Test spawn_child_task function."""

    @pytest.mark.asyncio
    async def test_stores_context_in_memory(self):
        """Full context stored via add_memory."""
        with patch("ta_lab2.tools.ai_orchestrator.handoff.add_memory") as mock_add:
            # Create parent result
            parent_task = Task(type=TaskType.CODE_GENERATION, prompt="Parent", task_id="parent_123")
            parent_result = Result(
                task=parent_task,
                platform=Platform.CLAUDE_CODE,
                output="Parent output text",
                success=True,
            )

            child_task, handoff = await spawn_child_task(parent_result, "Child prompt")

            mock_add.assert_called_once()
            call_args = mock_add.call_args
            assert "Parent output text" in call_args[1]["content"]

    @pytest.mark.asyncio
    async def test_truncates_long_summary(self):
        """Summary truncated to max_summary_length."""

    @pytest.mark.asyncio
    async def test_child_task_has_context_pointer(self):
        """Child task.context has handoff_memory_id."""

    @pytest.mark.asyncio
    async def test_preserves_chain_id(self):
        """Uses existing chain_id if provided."""


class TestLoadHandoffContext:
    """Test load_handoff_context function."""

    @pytest.mark.asyncio
    async def test_retrieves_from_memory(self):
        """Loads context from memory by ID."""
        with patch("ta_lab2.tools.ai_orchestrator.handoff.get_memory_by_id") as mock_get:
            mock_get.return_value = {"content": "Full context"}
            task = Task(
                type=TaskType.CODE_GENERATION,
                prompt="Child",
                context={"handoff_memory_id": "mem_123"},
            )

            content = await load_handoff_context(task)
            assert content == "Full context"
            mock_get.assert_called_with("mem_123")

    @pytest.mark.asyncio
    async def test_raises_if_no_memory_id(self):
        """Raises RuntimeError if no handoff_memory_id."""
        task = Task(type=TaskType.CODE_GENERATION, prompt="Child", context={})
        with pytest.raises(RuntimeError, match="no handoff_memory_id"):
            await load_handoff_context(task)

    @pytest.mark.asyncio
    async def test_raises_if_memory_not_found(self):
        """Raises RuntimeError if memory lookup returns None (fail-fast per CONTEXT.md)."""
        with patch("ta_lab2.tools.ai_orchestrator.handoff.get_memory_by_id") as mock_get:
            mock_get.return_value = None
            task = Task(
                type=TaskType.CODE_GENERATION,
                prompt="Child",
                context={"handoff_memory_id": "mem_missing"},
            )

            with pytest.raises(RuntimeError, match="not found"):
                await load_handoff_context(task)


class TestHasHandoffContext:
    """Test has_handoff_context helper."""

    def test_returns_true_if_has_memory_id(self):
        """True when handoff_memory_id in context."""

    def test_returns_false_if_no_memory_id(self):
        """False when handoff_memory_id not in context."""
```
  </action>
  <verify>
Run tests: `pytest tests/orchestrator/test_handoff.py -v`
  </verify>
  <done>
All handoff tests pass, covering context storage, pointer passing, fail-fast behavior, and chain tracking
  </done>
</task>

</tasks>

<verification>
1. Memory module verification: `python -c "from ta_lab2.tools.ai_orchestrator.memory.update import add_memory; from ta_lab2.tools.ai_orchestrator.memory.query import get_memory_by_id; print('Memory modules available')"`
2. Import verification: `python -c "from ta_lab2.tools.ai_orchestrator.handoff import spawn_child_task, load_handoff_context"`
3. Test suite: `pytest tests/orchestrator/test_handoff.py -v`
4. All orchestrator tests pass: `pytest tests/orchestrator/ -v`
</verification>

<success_criteria>
- spawn_child_task stores full context in memory, returns task with pointer + summary
- load_handoff_context retrieves from memory or raises RuntimeError (fail-fast per CONTEXT.md)
- ChainTracker maintains task genealogy for cost attribution
- Tests verify hybrid (pointer + summary) pattern and fail-fast behavior
</success_criteria>

<output>
After completion, create `.planning/phases/05-orchestrator-coordination/05-03-SUMMARY.md`
</output>
