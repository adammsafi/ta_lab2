---
phase: 24-pattern-consistency
plan: 03
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py
  - src/ta_lab2/scripts/bars/base_bar_builder.py
autonomous: true

must_haves:
  truths:
    - "Multi-TF bar builder inherits from BaseBarBuilder"
    - "Polars optimization preserved"
    - "Carry-forward optimization preserved"
    - "Backfill detection logic preserved"
    - "CLI interface unchanged (backward compatible)"
  artifacts:
    - path: "src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py"
      provides: "Multi-TF bar builder using BaseBarBuilder"
      exports: ["MultiTFBarBuilder", "main"]
  key_links:
    - from: "src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py"
      to: "src/ta_lab2/scripts/bars/base_bar_builder.py"
      via: "class inheritance"
      pattern: "class MultiTFBarBuilder\\(BaseBarBuilder\\)"
    - from: "src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py"
      to: "src/ta_lab2/scripts/bars/polars_bar_operations.py"
      via: "imports Polars operations"
      pattern: "from.*polars_bar_operations import"
---

<objective>
Refactor the main multi-TF bar builder (refresh_cmc_price_bars_multi_tf.py) to use BaseBarBuilder.

Purpose: Apply the BaseBarBuilder pattern to the most important multi-TF builder. This builder is more complex than 1D (multiple timeframes, Polars optimization, carry-forward, backfill detection) and proves the pattern scales. It also uses the existing polars_bar_operations.py extraction, demonstrating how shared utilities compose with the base class.

Output: refresh_cmc_price_bars_multi_tf.py reduced from ~1729 LOC to ~400-500 LOC through base class inheritance and polars_bar_operations.py usage, with identical output and CLI interface.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Base class from Plan 01
@src/ta_lab2/scripts/bars/base_bar_builder.py
@src/ta_lab2/scripts/bars/bar_builder_config.py

# Script to refactor
@src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py

# Shared Polars operations already extracted
@src/ta_lab2/scripts/bars/polars_bar_operations.py

# Common utilities
@src/ta_lab2/scripts/bars/common_snapshot_contract.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MultiTFBarBuilder subclass with state management</name>
  <files>src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py</files>
  <action>
Before making changes, capture baseline:
1. Note current LOC: wc -l refresh_cmc_price_bars_multi_tf.py (expect ~1729)
2. Review existing architecture: main(), refresh patterns, state management

Read refresh_cmc_price_bars_multi_tf.py completely and identify:
- State table: cmc_price_bars_multi_tf_state (has tf column, backfill detection)
- Source data: price_histories7 AND cmc_price_bars_1d (for derivation mode)
- Timeframe handling: dim_timeframe query
- Polars optimizations: polars_bar_operations.py usage
- Carry-forward optimization: strict gate check
- Module-level state flags: _FROM_1D, _VALIDATE_DERIVATION

Create MultiTFBarBuilder class:
```python
from ta_lab2.scripts.bars.base_bar_builder import BaseBarBuilder
from ta_lab2.scripts.bars.bar_builder_config import BarBuilderConfig
from ta_lab2.scripts.bars.polars_bar_operations import (
    apply_standard_polars_pipeline,
    # other Polars functions
)

class MultiTFBarBuilder(BaseBarBuilder):
    """
    Multi-TF Bar Builder - builds multi-timeframe snapshot bars.

    Supports tf_day family timeframes (2D, 3D, 5D, 7D, 14D, etc.)
    Uses Polars for 20-30% performance improvement.
    Supports carry-forward optimization for strict snapshot gates.
    Inherits shared infrastructure from BaseBarBuilder.
    """

    STATE_TABLE = "public.cmc_price_bars_multi_tf_state"
    OUTPUT_TABLE = "public.cmc_price_bars_multi_tf"

    def __init__(self, config: BarBuilderConfig, engine, timeframes: list[str] = None):
        super().__init__(config, engine)
        self.timeframes = timeframes or self._load_timeframes()
```

Key difference from 1D: State table has (id, tf) PRIMARY KEY, not just (id).
Handle this by overriding state methods if needed, or extending base class.
  </action>
  <verify>
- grep "class MultiTFBarBuilder" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py shows inheritance
- grep "polars_bar_operations" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py shows import maintained
- python -c "from ta_lab2.scripts.bars.refresh_cmc_price_bars_multi_tf import MultiTFBarBuilder; print('Import OK')"
  </verify>
  <done>MultiTFBarBuilder class created inheriting from BaseBarBuilder, Polars imports preserved</done>
</task>

<task type="auto">
  <name>Task 2: Implement abstract methods preserving Polars optimization</name>
  <files>src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py</files>
  <action>
Implement all abstract methods:

1. get_state_table_name() - return STATE_TABLE constant

2. get_output_table_name() - return OUTPUT_TABLE constant

3. get_source_query(id_, start_ts, tf=None) - complexity here:
   - May need to extend signature for tf parameter
   - Source depends on _FROM_1D flag: price_histories7 or cmc_price_bars_1d
   - If base class signature doesn't support, add **kwargs or override

4. build_bars_for_id(df_daily, id_, timeframes=None) - key implementation:
   - Use polars_bar_operations.apply_standard_polars_pipeline()
   - Handle multiple timeframes (loop or batch)
   - Preserve carry-forward optimization
   - This is the 20% variant-specific logic

5. _load_timeframes() - load from dim_timeframe:
   - Query for alignment_type='tf_day', canonical_only=True
   - Filter to day-label format (7D, 14D, etc.)

6. create_argument_parser() - extend base parser:
   - --from-1d, --validate-derivation (Phase 22 additions)
   - --tfs for specific timeframes
   - Keep all existing CLI args

7. from_cli_args(args) - factory method:
   - Handle _FROM_1D module-level flag setup
   - Create engine, resolve IDs, load timeframes
   - Return MultiTFBarBuilder instance

Preserve existing optimizations:
- Polars vectorization (DO NOT convert back to pandas for processing)
- Carry-forward check: if strict_gate_ok, update only snapshot timestamp
- Backfill detection: compare daily_min_seen, trigger rebuild if needed
  </action>
  <verify>
- grep "apply_standard_polars_pipeline" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py confirms Polars usage
- grep "_load_timeframes" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py shows TF loading
- grep "from-1d" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py shows CLI arg preserved
  </verify>
  <done>All abstract methods implemented, Polars optimization preserved, backfill detection preserved</done>
</task>

<task type="auto">
  <name>Task 3: Update main() and verify backward compatibility</name>
  <files>src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py</files>
  <action>
Update main() to use the new class structure:
```python
def main() -> None:
    """Entry point for multi-TF bar builder."""
    parser = MultiTFBarBuilder.create_argument_parser()
    args = parser.parse_args()

    # Set module-level flags for derivation mode
    global _FROM_1D, _VALIDATE_DERIVATION
    _FROM_1D = args.from_1d
    _VALIDATE_DERIVATION = args.validate_derivation

    builder = MultiTFBarBuilder.from_cli_args(args)
    builder.run()

if __name__ == "__main__":
    main()
```

Remove duplicate code now in base class:
- Generic DB connection setup
- Generic logging setup
- Generic ID resolution
- Generic state table creation

Keep multi-TF-specific code:
- MultiTFBarBuilder class with all its methods
- Polars helper functions (if not in polars_bar_operations.py)
- Backfill detection logic
- Carry-forward optimization logic
- Module-level flags

Verify backward compatibility:
1. CLI interface unchanged:
   python refresh_cmc_price_bars_multi_tf.py --help
   Verify --from-1d, --validate-derivation, --tfs present

2. Check syntax and imports:
   python -c "from ta_lab2.scripts.bars.refresh_cmc_price_bars_multi_tf import MultiTFBarBuilder, main"

Calculate LOC reduction:
- Before: ~1729 LOC
- After: Target ~400-500 LOC (70% reduction)
- Note: Some reduction already achieved via polars_bar_operations.py
  </action>
  <verify>
- python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py --help runs without error
- grep -E "from-1d|validate-derivation" shows Phase 22 CLI args preserved
- wc -l src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py shows reduction from 1729
- python -c "from ta_lab2.scripts.bars.refresh_cmc_price_bars_multi_tf import MultiTFBarBuilder, main; print('OK')"
  </verify>
  <done>main() uses new class structure, LOC reduced by 50%+, CLI interface unchanged, derivation mode preserved</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py --help shows all expected arguments
2. Import test: python -c "from ta_lab2.scripts.bars.refresh_cmc_price_bars_multi_tf import MultiTFBarBuilder"
3. Verify LOC reduction: wc -l shows meaningful reduction from ~1729
4. Verify Polars preserved: grep "polars" confirms usage
5. Verify --from-1d preserved: grep "from-1d" in help output
</verification>

<success_criteria>
1. MultiTFBarBuilder inherits from BaseBarBuilder
2. All abstract methods implemented preserving existing logic
3. Polars optimization via polars_bar_operations.py maintained
4. Carry-forward and backfill detection preserved
5. CLI interface unchanged (all Phase 22 args preserved)
6. LOC reduced by at least 40% (from ~1729 to <1000)
</success_criteria>

<output>
After completion, create `.planning/phases/24-pattern-consistency/24-03-SUMMARY.md`
</output>
