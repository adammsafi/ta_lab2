---
phase: 24-pattern-consistency
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py
  - src/ta_lab2/scripts/bars/base_bar_builder.py
autonomous: true

must_haves:
  truths:
    - "1D bar builder inherits from BaseBarBuilder"
    - "All shared infrastructure moved to base class"
    - "Variant-specific bar building logic remains in subclass"
    - "CLI interface unchanged (backward compatible)"
    - "Output identical to before refactoring"
  artifacts:
    - path: "src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py"
      provides: "1D bar builder using BaseBarBuilder"
      exports: ["OneDayBarBuilder", "main"]
  key_links:
    - from: "src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py"
      to: "src/ta_lab2/scripts/bars/base_bar_builder.py"
      via: "class inheritance"
      pattern: "class OneDayBarBuilder\\(BaseBarBuilder\\)"
    - from: "src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py"
      to: "public.cmc_price_bars_1d"
      via: "writes bars"
      pattern: "cmc_price_bars_1d"
---

<objective>
Refactor the 1D bar builder (refresh_cmc_price_bars_1d.py) to use BaseBarBuilder as proof of concept.

Purpose: Validate the BaseBarBuilder design by refactoring the simplest builder first. The 1D builder is ideal because it has straightforward logic (no multi-TF complexity, no calendar alignment) while still exercising all base class functionality. This proves the pattern works before refactoring the more complex builders.

Output: refresh_cmc_price_bars_1d.py reduced from ~971 LOC to ~200-300 LOC through base class inheritance, with identical output and CLI interface.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Base class from Plan 01
@src/ta_lab2/scripts/bars/base_bar_builder.py
@src/ta_lab2/scripts/bars/bar_builder_config.py

# Script to refactor
@src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py

# Pattern reference
@src/ta_lab2/scripts/emas/refresh_cmc_ema_multi_tf_from_bars.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OneDayBarBuilder subclass skeleton</name>
  <files>src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py</files>
  <action>
Before making changes, capture baseline:
1. Run: python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py --help > /tmp/1d_help_before.txt
2. Note current LOC: wc -l refresh_cmc_price_bars_1d.py

Read refresh_cmc_price_bars_1d.py completely and identify:
- Existing main() function structure
- State management logic (cmc_price_bars_1d_state table)
- Source query (price_histories7)
- Bar building logic (OHLC aggregation per day)
- Validation and reject handling

Create OneDayBarBuilder class that inherits from BaseBarBuilder:
```python
from ta_lab2.scripts.bars.base_bar_builder import BaseBarBuilder
from ta_lab2.scripts.bars.bar_builder_config import BarBuilderConfig

class OneDayBarBuilder(BaseBarBuilder):
    """
    1D Bar Builder - builds daily OHLC bars from price_histories7.

    Simplest bar builder - one row per local calendar day per asset.
    Inherits shared infrastructure from BaseBarBuilder.
    Implements variant-specific: source query, bar building logic.
    """

    STATE_TABLE = "public.cmc_price_bars_1d_state"
    OUTPUT_TABLE = "public.cmc_price_bars_1d"
    SOURCE_TABLE = "public.price_histories7"
```

Keep the existing logic but organize it into abstract method implementations:
- get_state_table_name() -> return self.STATE_TABLE
- get_output_table_name() -> return self.OUTPUT_TABLE
- get_source_query() -> existing SQL for price_histories7
- build_bars_for_id() -> existing OHLC aggregation logic
  </action>
  <verify>
- grep "class OneDayBarBuilder" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py shows inheritance from BaseBarBuilder
- python -c "from ta_lab2.scripts.bars.refresh_cmc_price_bars_1d import OneDayBarBuilder; print('Import OK')"
  </verify>
  <done>OneDayBarBuilder class created inheriting from BaseBarBuilder, class constants defined for tables</done>
</task>

<task type="auto">
  <name>Task 2: Implement abstract methods with existing logic</name>
  <files>src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py</files>
  <action>
Implement all abstract methods required by BaseBarBuilder:

1. get_state_table_name() - trivial, return constant
2. get_output_table_name() - trivial, return constant
3. get_source_query(id_, start_ts) - move existing SQL query here:
   - Query price_histories7 for id, filtering by timestamp if incremental
   - Include all columns needed for OHLC: id, timestamp, open, high, low, close, volume, timehigh, timelow

4. build_bars_for_id(df_daily, id_) - move existing bar building logic:
   - Convert timestamps to local date
   - Aggregate OHLC per day (first open, max high, min low, last close, sum volume)
   - Handle time_high/time_low determinism (earliest among ties)
   - Assign bar_seq
   - Apply enforce_ohlc_sanity if needed
   - Return DataFrame ready for upsert

5. create_argument_parser() - extend base parser:
   - Call super().create_base_argument_parser()
   - Add 1D-specific args if any (e.g., --lookback-days)

6. from_cli_args(args) - factory method:
   - Resolve db_url
   - Create engine
   - Build BarBuilderConfig from args
   - Return OneDayBarBuilder instance

Keep helper functions as private methods or module-level utilities:
- _repair_time_high_low() - if exists, keep as private method
- Any validation helpers

DO NOT change the bar building algorithm - only reorganize code structure.
  </action>
  <verify>
- grep -c "def get_" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py shows at least 3 get_* methods
- grep "def build_bars_for_id" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py shows the method exists
- grep "def from_cli_args" src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py shows factory method
  </verify>
  <done>All 6 abstract methods implemented with existing logic migrated, no algorithm changes</done>
</task>

<task type="auto">
  <name>Task 3: Update main() and verify backward compatibility</name>
  <files>src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py</files>
  <action>
Update main() to use the new class structure:
```python
def main() -> None:
    """Entry point for 1D bar builder."""
    parser = OneDayBarBuilder.create_argument_parser()
    args = parser.parse_args()

    builder = OneDayBarBuilder.from_cli_args(args)
    builder.run()

if __name__ == "__main__":
    main()
```

Remove duplicate code that's now in base class:
- DB connection setup (moved to base)
- Generic logging setup (moved to base)
- State loading/updating (moved to base)
- ID resolution (moved to base)

Keep 1D-specific code:
- The OneDayBarBuilder class with its method implementations
- Any helper functions unique to 1D processing
- Module docstring

Verify backward compatibility:
1. CLI interface unchanged:
   python refresh_cmc_price_bars_1d.py --help
   Compare output with baseline - same arguments available

2. Dry-run test (if --dry-run exists) or limited test:
   python refresh_cmc_price_bars_1d.py --ids 1 --dry-run
   Or if no dry-run: check syntax and imports only

Calculate LOC reduction:
- Before: ~971 LOC
- After: Target ~200-300 LOC (70% reduction)
- Document actual reduction in summary
  </action>
  <verify>
- python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py --help runs without error
- wc -l src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py shows significant reduction from 971
- python -c "from ta_lab2.scripts.bars.refresh_cmc_price_bars_1d import OneDayBarBuilder, main; print('All exports OK')"
  </verify>
  <done>main() uses new class structure, LOC reduced by 50%+, CLI interface unchanged, all imports work</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. python src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py --help shows same interface as before
2. Import test: python -c "from ta_lab2.scripts.bars.refresh_cmc_price_bars_1d import OneDayBarBuilder"
3. Verify LOC reduction: wc -l shows meaningful reduction from ~971
4. Verify no algorithm changes: grep for OHLC aggregation logic confirms it's preserved
</verification>

<success_criteria>
1. OneDayBarBuilder inherits from BaseBarBuilder
2. All 6 abstract methods implemented with existing logic
3. main() uses class-based entry point
4. CLI interface unchanged (backward compatible)
5. LOC reduced by at least 50% (from ~971 to <500)
6. No functional changes to bar building algorithm
</success_criteria>

<output>
After completion, create `.planning/phases/24-pattern-consistency/24-02-SUMMARY.md`
</output>
