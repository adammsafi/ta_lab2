---
phase: 24-pattern-consistency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ta_lab2/scripts/bars/base_bar_builder.py
  - src/ta_lab2/scripts/bars/bar_builder_config.py
autonomous: true

must_haves:
  truths:
    - "BaseBarBuilder abstract base class exists with template method pattern"
    - "BarBuilderConfig dataclass captures all configuration across builders"
    - "Abstract methods defined for variant-specific behavior"
    - "Shared methods defined for common infrastructure"
  artifacts:
    - path: "src/ta_lab2/scripts/bars/base_bar_builder.py"
      provides: "Template method base class for bar builders"
      min_lines: 300
    - path: "src/ta_lab2/scripts/bars/bar_builder_config.py"
      provides: "Configuration dataclass for bar builders"
      min_lines: 50
  key_links:
    - from: "src/ta_lab2/scripts/bars/base_bar_builder.py"
      to: "src/ta_lab2/scripts/emas/base_ema_refresher.py"
      via: "mirrors template method pattern"
      pattern: "class.*ABC.*abstractmethod"
    - from: "src/ta_lab2/scripts/bars/base_bar_builder.py"
      to: "src/ta_lab2/scripts/bars/common_snapshot_contract.py"
      via: "imports shared utilities"
      pattern: "from.*common_snapshot_contract import"
---

<objective>
Design and create the BaseBarBuilder template method base class following the proven BaseEMARefresher pattern.

Purpose: Establish the foundation for 70% LOC reduction across 6 bar builders by extracting shared infrastructure (DB connection, CLI parsing, state loading, table creation) into a reusable base class while keeping variant-specific logic (bar boundaries, calendar alignment, bar_seq assignment) in subclasses.

Output: base_bar_builder.py with abstract methods for variant behavior and concrete methods for shared infrastructure, plus bar_builder_config.py with configuration dataclass.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase analysis
@.planning/phases/21-comprehensive-review/deliverables/gap-analysis.md

# Pattern reference - BaseEMARefresher is the template to follow
@src/ta_lab2/scripts/emas/base_ema_refresher.py
@src/ta_lab2/scripts/emas/ema_state_manager.py

# Existing bar builder infrastructure
@src/ta_lab2/scripts/bars/common_snapshot_contract.py
@src/ta_lab2/scripts/bars/polars_bar_operations.py
@src/ta_lab2/scripts/bars/refresh_cmc_price_bars_1d.py
@src/ta_lab2/scripts/bars/refresh_cmc_price_bars_multi_tf.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analyze bar builder structure and design BaseBarBuilder interface</name>
  <files>src/ta_lab2/scripts/bars/base_bar_builder.py, src/ta_lab2/scripts/bars/bar_builder_config.py</files>
  <action>
Read and analyze:
1. base_ema_refresher.py completely (lines 1-1112) to understand the template method pattern
2. refresh_cmc_price_bars_1d.py to understand 1D builder structure
3. refresh_cmc_price_bars_multi_tf.py to understand multi-TF builder structure
4. At least one calendar builder (refresh_cmc_price_bars_multi_tf_cal_us.py) for calendar variant

Identify shared infrastructure (80% target):
- DB connection and engine management
- CLI argument parsing (argparse setup)
- State table loading/updating
- ID resolution (from CLI args or database)
- Logging setup
- Table existence checks and creation

Identify variant-specific behavior (20% target):
- Bar boundary logic (rolling window vs calendar-aligned)
- Bar_seq assignment strategy
- Timeframe handling (dim_timeframe query vs implicit)
- Source data loading (which table to read)
- OHLC aggregation specifics (different for 1D vs multi-TF vs calendar)

Create bar_builder_config.py with:
```python
@dataclass
class BarBuilderConfig:
    """Configuration for bar builders - mirrors EMARefresherConfig pattern."""
    db_url: str
    ids: list[int]
    full_refresh: bool = False
    keep_rejects: bool = False
    rejects_table: str | None = None
    batch_size: int = 10
    parallel: bool = True
    workers: int | None = None
    log_level: str = "INFO"
    # Add variant-specific fields as needed
```

Create base_bar_builder.py skeleton with:
- Import statements (ABC, abstractmethod, argparse, etc.)
- Module docstring explaining template method pattern for bars
- BarBuilderConfig import
- BaseBarBuilder class with clear section comments
  </action>
  <verify>
- cat src/ta_lab2/scripts/bars/bar_builder_config.py shows BarBuilderConfig dataclass with at least 8 fields
- cat src/ta_lab2/scripts/bars/base_bar_builder.py shows class BaseBarBuilder(ABC) with module docstring
- python -c "from ta_lab2.scripts.bars.bar_builder_config import BarBuilderConfig; print('Import OK')"
  </verify>
  <done>BarBuilderConfig dataclass created with all common configuration fields, BaseBarBuilder skeleton exists with clear structure</done>
</task>

<task type="auto">
  <name>Task 2: Implement abstract methods and concrete shared methods</name>
  <files>src/ta_lab2/scripts/bars/base_bar_builder.py</files>
  <action>
Add abstract methods that subclasses must implement (variant-specific behavior):

```python
@abstractmethod
def get_state_table_name(self) -> str:
    """Return state table name for this builder variant."""

@abstractmethod
def get_output_table_name(self) -> str:
    """Return output table name for bars."""

@abstractmethod
def get_source_query(self, id_: int, start_ts: datetime | None) -> str:
    """Return SQL query to load source data for one ID."""

@abstractmethod
def build_bars_for_id(self, df_daily: pd.DataFrame, id_: int) -> pd.DataFrame:
    """Build bars from daily data for one ID - variant-specific logic."""

@classmethod
@abstractmethod
def create_argument_parser(cls) -> argparse.ArgumentParser:
    """Create argument parser with variant-specific arguments."""

@classmethod
@abstractmethod
def from_cli_args(cls, args: argparse.Namespace) -> "BaseBarBuilder":
    """Factory: Create builder from CLI arguments."""
```

Add concrete shared methods (shared infrastructure):

```python
def create_base_argument_parser(cls) -> argparse.ArgumentParser:
    """Create parser with standard arguments common to all builders."""
    # Pattern: --db-url, --ids, --full-refresh, --keep-rejects, --log-level

def resolve_ids(self, ids_arg: list[int] | None) -> list[int]:
    """Resolve IDs from CLI args or load all from dim_assets."""

def ensure_output_table_exists(self) -> None:
    """Create output table if it doesn't exist."""

def load_state(self, id_: int) -> dict:
    """Load state for one ID from state table."""

def update_state(self, id_: int, state_dict: dict) -> None:
    """Update state for one ID in state table."""

def run(self) -> None:
    """Template method: Main execution flow."""
    # 1. Ensure tables exist
    # 2. Resolve IDs
    # 3. For each ID: load state, build bars, write bars, update state
    # 4. Log summary
```

Mirror BaseEMARefresher patterns:
- Use @classmethod for factory methods
- Use property for engine, logger access
- Include type hints throughout
- Add docstrings with clear contract explanations
  </action>
  <verify>
- grep -c "@abstractmethod" src/ta_lab2/scripts/bars/base_bar_builder.py shows at least 6 abstract methods
- grep "def run" src/ta_lab2/scripts/bars/base_bar_builder.py shows run() template method
- python -c "from ta_lab2.scripts.bars.base_bar_builder import BaseBarBuilder; print('Import OK')"
  </verify>
  <done>BaseBarBuilder has 6+ abstract methods for variant behavior and 5+ concrete methods for shared infrastructure, template method run() orchestrates execution flow</done>
</task>

<task type="auto">
  <name>Task 3: Add CLI helpers, logging, and integration with existing infrastructure</name>
  <files>src/ta_lab2/scripts/bars/base_bar_builder.py</files>
  <action>
Add CLI helper integration:
- Import and use add_logging_args from existing logging_config if available, otherwise create inline
- create_base_argument_parser() returns parser with standard args:
  - --db-url (DATABASE_URL env fallback)
  - --ids (optional, defaults to all from dim_assets)
  - --full-refresh (flag)
  - --keep-rejects, --rejects-table
  - --batch-size, --parallel, --workers
  - --log-level

Add logging setup:
- setup_logging() method that configures root logger
- get_logger() property that returns configured logger
- Log format matching existing scripts

Add integration with existing infrastructure:
- Import from common_snapshot_contract: load_all_ids, upsert_bars, detect_ohlc_violations, log_to_rejects
- Import from polars_bar_operations if applicable
- Resolve db_url using existing pattern (args.db_url or os.getenv("DATABASE_URL"))

Add run() template method implementation:
```python
def run(self) -> None:
    """Template method: Execute bar building workflow."""
    self.logger.info(f"Starting {self.__class__.__name__}")

    # 1. Ensure tables exist
    self.ensure_output_table_exists()

    # 2. Resolve IDs
    ids = self.config.ids or self.resolve_ids(None)
    self.logger.info(f"Processing {len(ids)} IDs")

    # 3. Process each ID
    total_bars = 0
    for id_ in ids:
        state = self.load_state(id_)
        df_daily = self.load_source_data(id_, state.get('last_ts'))
        if df_daily.empty:
            continue
        df_bars = self.build_bars_for_id(df_daily, id_)
        rows = self.write_bars(df_bars)
        self.update_state(id_, df_bars)
        total_bars += rows

    # 4. Log summary
    self.logger.info(f"Complete: {total_bars} bars written for {len(ids)} IDs")
```
  </action>
  <verify>
- grep "create_base_argument_parser" src/ta_lab2/scripts/bars/base_bar_builder.py shows the method exists
- grep "from ta_lab2.scripts.bars.common_snapshot_contract import" src/ta_lab2/scripts/bars/base_bar_builder.py shows imports
- python -c "from ta_lab2.scripts.bars.base_bar_builder import BaseBarBuilder; print(BaseBarBuilder.create_base_argument_parser()); print('OK')" shows parser with help
  </verify>
  <done>BaseBarBuilder integrates with existing logging, CLI, and common_snapshot_contract infrastructure, run() template method is fully implemented</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. python -c "from ta_lab2.scripts.bars.base_bar_builder import BaseBarBuilder; from ta_lab2.scripts.bars.bar_builder_config import BarBuilderConfig; print('All imports OK')"
2. Verify BaseBarBuilder cannot be instantiated directly (abstract class)
3. Verify abstract methods are documented with clear contracts
4. Verify run() template method calls abstract methods at correct points
</verification>

<success_criteria>
1. BaseBarBuilder abstract base class exists with template method pattern matching BaseEMARefresher style
2. BarBuilderConfig dataclass captures all common configuration (mirrors EMARefresherConfig)
3. At least 6 abstract methods define variant-specific behavior
4. At least 5 concrete methods provide shared infrastructure
5. run() template method orchestrates execution flow
6. Integration with common_snapshot_contract confirmed via imports
</success_criteria>

<output>
After completion, create `.planning/phases/24-pattern-consistency/24-01-SUMMARY.md`
</output>
