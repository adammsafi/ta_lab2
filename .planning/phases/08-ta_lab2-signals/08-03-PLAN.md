---
phase: 08-ta_lab2-signals
plan: 03
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/ta_lab2/scripts/signals/generate_signals_rsi.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_rsi_mean_revert.py
  - tests/signals/test_rsi_signal_generation.py
autonomous: true

must_haves:
  truths:
    - "RSI mean reversion signals generated from cmc_daily_features and stored in database"
    - "RSI thresholds (lower/upper) loaded from dim_signals params"
    - "Signal records include rsi_at_entry and rsi_at_exit for analysis"
    - "Adaptive threshold support built but uses static thresholds by default"
  artifacts:
    - path: "src/ta_lab2/scripts/signals/generate_signals_rsi.py"
      provides: "RSI mean reversion signal generation"
      exports: ["RSISignalGenerator"]
    - path: "src/ta_lab2/scripts/signals/refresh_cmc_signals_rsi_mean_revert.py"
      provides: "CLI for RSI signal refresh"
      min_lines: 80
  key_links:
    - from: "src/ta_lab2/scripts/signals/generate_signals_rsi.py"
      to: "src/ta_lab2/signals/rsi_mean_revert.py"
      via: "calls make_signals for signal generation"
      pattern: "from.*signals.*rsi_mean_revert.*import.*make_signals"
    - from: "src/ta_lab2/scripts/signals/generate_signals_rsi.py"
      to: "src/ta_lab2/scripts/signals/signal_utils.py"
      via: "uses compute_feature_hash"
      pattern: "compute_feature_hash"
---

<objective>
Create RSI mean reversion signal generation: load thresholds from dim_signals, generate signals using existing rsi_mean_revert.py adapter, track RSI values at entry/exit, store in cmc_signals_rsi_mean_revert.

Purpose: Second signal type demonstrating database-driven threshold configuration and signal-specific analytics (rsi_at_entry, rsi_at_exit). Adaptive threshold infrastructure built for future calibration.

Output: RSISignalGenerator class, CLI refresh script, 12+ tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ta_lab2-signals/08-CONTEXT.md
@.planning/phases/08-ta_lab2-signals/08-RESEARCH.md
@.planning/phases/08-ta_lab2-signals/08-01-SUMMARY.md

# Existing signal adapter to leverage
@src/ta_lab2/signals/rsi_mean_revert.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RSISignalGenerator class</name>
  <files>
    src/ta_lab2/scripts/signals/generate_signals_rsi.py
  </files>
  <action>
    Create RSISignalGenerator following EMASignalGenerator pattern:

    1. **Load configuration from dim_signals:**
       ```python
       # dim_signals params for RSI:
       # {"lower": 30, "upper": 70, "rsi_col": "rsi_14", "confirm_cross": true}
       configs = load_active_signals(engine, 'rsi_mean_revert')
       ```

    2. **Load features from cmc_daily_features:**
       ```python
       def load_features(self, ids: list[int], start_ts: pd.Timestamp) -> pd.DataFrame:
           sql = """
               SELECT id, ts, close, rsi_14, rsi_7, rsi_21, atr_14
               FROM cmc_daily_features
               WHERE id = ANY(:ids) AND ts >= :start_ts
               ORDER BY id, ts
           """
       ```

    3. **Generate signals using existing adapter:**
       ```python
       from ta_lab2.signals.rsi_mean_revert import make_signals

       entries, exits, size = make_signals(
           df_features,
           rsi_col=params.get('rsi_col', 'rsi_14'),
           lower=params.get('lower', 30.0),
           upper=params.get('upper', 70.0),
           confirm_cross=params.get('confirm_cross', True),
           allow_shorts=params.get('allow_shorts', False),
       )
       ```

    4. **Transform to stateful records with RSI tracking:**
       ```python
       def transform_signals_to_records(...) -> pd.DataFrame:
           # Same as EMA but with RSI-specific fields:
           # - rsi_at_entry: RSI value when signal opened
           # - rsi_at_exit: RSI value when signal closed
           # - feature_snapshot includes: close, rsi_14, atr_14
       ```

    5. **Optional adaptive threshold support (future use):**
       ```python
       def compute_adaptive_thresholds(
           df: pd.DataFrame,
           rsi_col: str,
           lookback: int = 100,
           lower_pct: float = 20.0,  # 20th percentile
           upper_pct: float = 80.0,  # 80th percentile
       ) -> tuple[pd.Series, pd.Series]:
           """
           Rolling percentile-based adaptive thresholds.
           Returns (lower_series, upper_series) aligned to df index.

           Not used by default - params from dim_signals take precedence.
           Built for future calibration experiments.
           """
           lower = df[rsi_col].rolling(lookback).quantile(lower_pct / 100)
           upper = df[rsi_col].rolling(lookback).quantile(upper_pct / 100)
           return lower, upper
       ```

    Class structure:
    ```python
    @dataclass
    class RSISignalGenerator:
        engine: Engine
        state_manager: SignalStateManager
        signal_version: str = "1.0"

        def generate_for_ids(self, ids: list[int], signal_config: dict, full_refresh: bool = False) -> int:
            # Same pattern as EMA
            # Adds: rsi_at_entry, rsi_at_exit to records
    ```
  </action>
  <verify>
    Run: `python -c "from ta_lab2.scripts.signals.generate_signals_rsi import RSISignalGenerator; print('OK')"`
    Verify class imports without error.
  </verify>
  <done>
    RSISignalGenerator class created with generate_for_ids method, RSI value tracking at entry/exit, and adaptive threshold utility function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create refresh CLI script</name>
  <files>
    src/ta_lab2/scripts/signals/refresh_cmc_signals_rsi_mean_revert.py
  </files>
  <action>
    Create CLI script following same pattern as EMA:

    ```python
    #!/usr/bin/env python
    """Refresh RSI mean reversion signals from cmc_daily_features."""

    import argparse
    import logging
    import os
    from sqlalchemy import create_engine
    from ta_lab2.scripts.signals import (
        SignalStateManager, SignalStateConfig, load_active_signals
    )
    from ta_lab2.scripts.signals.generate_signals_rsi import RSISignalGenerator

    def main():
        parser = argparse.ArgumentParser()
        parser.add_argument('--ids', type=int, nargs='+', help='Asset IDs')
        parser.add_argument('--signal-id', type=int, help='Specific signal_id')
        parser.add_argument('--full-refresh', action='store_true')
        parser.add_argument('--dry-run', action='store_true')
        parser.add_argument('--verbose', '-v', action='store_true')
        args = parser.parse_args()

        logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)
        logger = logging.getLogger(__name__)

        engine = create_engine(os.environ['TARGET_DB_URL'])

        config = SignalStateConfig(signal_type='rsi_mean_revert')
        state_manager = SignalStateManager(engine, config)
        state_manager.ensure_state_table()

        if args.signal_id:
            configs = [c for c in load_active_signals(engine, 'rsi_mean_revert')
                       if c['signal_id'] == args.signal_id]
        else:
            configs = load_active_signals(engine, 'rsi_mean_revert')

        ids = args.ids or _get_all_asset_ids(engine)

        generator = RSISignalGenerator(engine, state_manager)
        total_signals = 0

        for config in configs:
            logger.info(f"Processing signal: {config['signal_name']}")
            n = generator.generate_for_ids(
                ids=ids,
                signal_config=config,
                full_refresh=args.full_refresh,
                dry_run=args.dry_run,
            )
            total_signals += n

        logger.info(f"Total: {total_signals} RSI signals generated")

    if __name__ == '__main__':
        main()
    ```
  </action>
  <verify>
    Run: `python src/ta_lab2/scripts/signals/refresh_cmc_signals_rsi_mean_revert.py --help`
    Verify help text shows all arguments.
  </verify>
  <done>
    CLI script created with same flags as EMA refresh script.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create tests for RSI signal generation</name>
  <files>
    tests/signals/test_rsi_signal_generation.py
  </files>
  <action>
    Create tests using unittest.mock:

    **Unit tests:**
    - test_transform_signals_includes_rsi_at_entry: Verify rsi_at_entry captured
    - test_transform_signals_includes_rsi_at_exit: Verify rsi_at_exit captured
    - test_generate_loads_thresholds_from_config: Mock config, verify lower/upper passed
    - test_generate_uses_correct_rsi_column: params['rsi_col'] used in make_signals
    - test_confirm_cross_parameter_passed: confirm_cross from params honored
    - test_adaptive_thresholds_computes_percentiles: Verify rolling quantile logic
    - test_adaptive_thresholds_handles_short_window: Less than lookback rows
    - test_pnl_calculation_correct: (exit_price - entry_price) / entry_price
    - test_feature_hash_includes_rsi: Hash computed on rsi columns

    **Integration tests (skipif not TARGET_DB_URL):**
    - test_roundtrip_rsi_signal_generation: Generate, query, verify structure
    - test_rsi_values_tracked_correctly: Verify rsi_at_entry/exit match source data
    - test_different_thresholds_produce_different_signals: 30/70 vs 25/75
  </action>
  <verify>
    Run: `pytest tests/signals/test_rsi_signal_generation.py -v`
    All tests pass.
  </verify>
  <done>
    12+ tests passing for RSI signal generation.
  </done>
</task>

</tasks>

<verification>
Phase verification checklist:
- [ ] RSISignalGenerator.generate_for_ids produces signal records
- [ ] Signals stored in cmc_signals_rsi_mean_revert table
- [ ] rsi_at_entry and rsi_at_exit columns populated
- [ ] RSI thresholds loaded from dim_signals params
- [ ] compute_adaptive_thresholds utility function works
- [ ] CLI script runs with --help
- [ ] All tests pass (12+ tests)
</verification>

<success_criteria>
1. RSI mean reversion signals generated from cmc_daily_features
2. RSI values tracked at entry and exit for analysis
3. Thresholds configurable via dim_signals (30/70 default)
4. Adaptive threshold utility available for future calibration
</success_criteria>

<output>
After completion, create `.planning/phases/08-ta_lab2-signals/08-03-SUMMARY.md`
</output>
