---
phase: 08-ta_lab2-signals
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/ta_lab2/scripts/signals/generate_signals_ema.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_ema_crossover.py
  - tests/signals/test_ema_signal_generation.py
autonomous: true

must_haves:
  truths:
    - "EMA crossover signals generated from cmc_daily_features and stored in database"
    - "Open positions carried forward during incremental refresh"
    - "Each signal record contains feature_version_hash for reproducibility"
    - "Signal generation loads parameters from dim_signals (not hardcoded)"
  artifacts:
    - path: "src/ta_lab2/scripts/signals/generate_signals_ema.py"
      provides: "EMA crossover signal generation logic"
      exports: ["EMASignalGenerator"]
    - path: "src/ta_lab2/scripts/signals/refresh_cmc_signals_ema_crossover.py"
      provides: "CLI for EMA signal refresh"
      min_lines: 80
  key_links:
    - from: "src/ta_lab2/scripts/signals/generate_signals_ema.py"
      to: "src/ta_lab2/signals/ema_trend.py"
      via: "calls make_signals for signal generation"
      pattern: "from.*signals.*ema_trend.*import.*make_signals"
    - from: "src/ta_lab2/scripts/signals/generate_signals_ema.py"
      to: "src/ta_lab2/scripts/signals/signal_utils.py"
      via: "uses compute_feature_hash, load_active_signals"
      pattern: "compute_feature_hash|load_active_signals"
---

<objective>
Create EMA crossover signal generation: load parameters from dim_signals, generate signals using existing ema_trend.py adapter, transform to stateful position records, store in cmc_signals_ema_crossover with feature hashing.

Purpose: First signal type implementation demonstrating database-driven configuration, stateful position tracking, and reproducibility. Establishes pattern for RSI and ATR signals.

Output: EMASignalGenerator class, CLI refresh script, 12+ tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ta_lab2-signals/08-CONTEXT.md
@.planning/phases/08-ta_lab2-signals/08-RESEARCH.md
@.planning/phases/08-ta_lab2-signals/08-01-SUMMARY.md

# Existing signal adapter to leverage
@src/ta_lab2/signals/ema_trend.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EMASignalGenerator class</name>
  <files>
    src/ta_lab2/scripts/signals/generate_signals_ema.py
  </files>
  <action>
    Create EMASignalGenerator that:

    1. **Load configuration from dim_signals:**
       ```python
       configs = load_active_signals(engine, 'ema_crossover')
       # Returns: [{signal_id: 1, signal_name: 'ema_9_21', params: {"fast_ema": "ema_9", ...}}]
       ```

    2. **Load features from cmc_daily_features:**
       ```python
       def load_features(self, ids: list[int], start_ts: pd.Timestamp) -> pd.DataFrame:
           sql = """
               SELECT id, ts, close, ema_9, ema_10, ema_21, ema_50, ema_200, rsi_14, atr_14
               FROM cmc_daily_features
               WHERE id = ANY(:ids) AND ts >= :start_ts
               ORDER BY id, ts
           """
           # Use explicit column list for hash stability
       ```

    3. **Generate signals using existing adapter:**
       ```python
       from ta_lab2.signals.ema_trend import make_signals

       entries, exits, size = make_signals(
           df_features,
           fast_ema=params['fast_ema'],
           slow_ema=params['slow_ema'],
           use_rsi_filter=params.get('use_rsi_filter', False),
           allow_shorts=params.get('allow_shorts', False),
       )
       ```

    4. **Transform to stateful records:**
       ```python
       def transform_signals_to_records(
           df: pd.DataFrame,
           entries: pd.Series,
           exits: pd.Series,
           signal_id: int,
           params: dict,
           open_positions: pd.DataFrame,  # From SignalStateManager
       ) -> pd.DataFrame:
           # Logic:
           # - Entry event: Create record with position_state='open', entry_price=close
           # - Exit event: Find matching open position, update to 'closed', compute pnl_pct
           # - Capture feature_snapshot at entry: {close, fast_ema, slow_ema, rsi}
           # - Compute feature_version_hash, params_hash for reproducibility
       ```

    5. **Write to database:**
       ```python
       def write_signals(self, records: pd.DataFrame, signal_table: str):
           # Use pandas to_sql with if_exists='append'
           # Or use UPSERT on (id, ts, signal_id) for idempotency
       ```

    Class structure:
    ```python
    @dataclass
    class EMASignalGenerator:
        engine: Engine
        state_manager: SignalStateManager
        signal_version: str = "1.0"

        def generate_for_ids(self, ids: list[int], signal_config: dict, full_refresh: bool = False) -> int:
            # Main entry point
            # 1. Load open positions from state if incremental
            # 2. Determine dirty window start
            # 3. Load features
            # 4. Generate signals
            # 5. Transform to records
            # 6. Write to DB
            # 7. Update state
            # Returns: number of signals generated
    ```
  </action>
  <verify>
    Run: `python -c "from ta_lab2.scripts.signals.generate_signals_ema import EMASignalGenerator; print('OK')"`
    Verify class imports without error.
  </verify>
  <done>
    EMASignalGenerator class created with generate_for_ids method integrating ema_trend.py adapter, feature loading, stateful record transformation, and database write.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create refresh CLI script</name>
  <files>
    src/ta_lab2/scripts/signals/refresh_cmc_signals_ema_crossover.py
  </files>
  <action>
    Create CLI script following refresh_cmc_returns_daily.py pattern:

    ```python
    #!/usr/bin/env python
    """Refresh EMA crossover signals from cmc_daily_features."""

    import argparse
    import logging
    from sqlalchemy import create_engine
    from ta_lab2.scripts.signals import (
        SignalStateManager, SignalStateConfig, load_active_signals
    )
    from ta_lab2.scripts.signals.generate_signals_ema import EMASignalGenerator

    def main():
        parser = argparse.ArgumentParser()
        parser.add_argument('--ids', type=int, nargs='+', help='Asset IDs (default: all)')
        parser.add_argument('--signal-id', type=int, help='Specific signal_id from dim_signals')
        parser.add_argument('--full-refresh', action='store_true', help='Recompute all signals')
        parser.add_argument('--dry-run', action='store_true', help='Preview without writing')
        parser.add_argument('--verbose', '-v', action='store_true')
        args = parser.parse_args()

        # Setup logging
        logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)
        logger = logging.getLogger(__name__)

        # Connect to database
        engine = create_engine(os.environ['TARGET_DB_URL'])

        # Setup state manager
        config = SignalStateConfig(signal_type='ema_crossover')
        state_manager = SignalStateManager(engine, config)
        state_manager.ensure_state_table()

        # Load signal configurations
        if args.signal_id:
            configs = [c for c in load_active_signals(engine, 'ema_crossover')
                       if c['signal_id'] == args.signal_id]
        else:
            configs = load_active_signals(engine, 'ema_crossover')

        # Get IDs from database if not specified
        if args.ids:
            ids = args.ids
        else:
            ids = _get_all_asset_ids(engine)  # Query distinct IDs from cmc_daily_features

        # Generate signals
        generator = EMASignalGenerator(engine, state_manager)
        total_signals = 0

        for config in configs:
            logger.info(f"Processing signal: {config['signal_name']}")
            n = generator.generate_for_ids(
                ids=ids,
                signal_config=config,
                full_refresh=args.full_refresh,
                dry_run=args.dry_run,
            )
            total_signals += n
            logger.info(f"  Generated {n} signals")

        # Update state
        if not args.dry_run:
            state_manager.update_state_after_generation(
                signal_table='cmc_signals_ema_crossover',
                signal_id=config['signal_id'],
            )

        logger.info(f"Total: {total_signals} signals generated")

    if __name__ == '__main__':
        main()
    ```

    Support flags:
    - --ids: Filter to specific assets
    - --signal-id: Process single signal configuration
    - --full-refresh: Recompute from beginning (ignore state)
    - --dry-run: Preview without database writes
    - --verbose: Debug logging
  </action>
  <verify>
    Run: `python src/ta_lab2/scripts/signals/refresh_cmc_signals_ema_crossover.py --help`
    Verify help text shows all arguments.
  </verify>
  <done>
    CLI script created with --ids, --signal-id, --full-refresh, --dry-run, --verbose flags.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create tests for EMA signal generation</name>
  <files>
    tests/signals/test_ema_signal_generation.py
  </files>
  <action>
    Create tests using unittest.mock for database-free testing:

    **Unit tests:**
    - test_transform_signals_creates_entry_record: Entry True creates position_state='open'
    - test_transform_signals_closes_open_position: Exit True + open position = 'closed' with pnl_pct
    - test_transform_signals_computes_pnl_correctly: (exit_price - entry_price) / entry_price
    - test_transform_signals_includes_feature_snapshot: Verify JSONB structure
    - test_transform_signals_includes_version_hashes: feature_version_hash, params_hash present
    - test_generate_for_ids_loads_features_from_db: Mock read_sql, verify query
    - test_generate_for_ids_calls_ema_trend_make_signals: Mock make_signals, verify params
    - test_generate_for_ids_respects_full_refresh_flag: full_refresh=True ignores state
    - test_generate_for_ids_incremental_uses_dirty_window: full_refresh=False uses last_entry_ts
    - test_dry_run_does_not_write: dry_run=True skips database write

    **Integration tests (skipif not TARGET_DB_URL):**
    - test_roundtrip_signal_generation: Generate signals, query back, verify structure
    - test_incremental_refresh_carries_open_positions: Generate, add new bars, generate again
  </action>
  <verify>
    Run: `pytest tests/signals/test_ema_signal_generation.py -v`
    All tests pass.
  </verify>
  <done>
    12+ tests passing for EMA signal generation.
  </done>
</task>

</tasks>

<verification>
Phase verification checklist:
- [ ] EMASignalGenerator.generate_for_ids produces signal records
- [ ] Signals stored in cmc_signals_ema_crossover table
- [ ] Each signal has feature_version_hash computed from source features
- [ ] Signal parameters loaded from dim_signals (not hardcoded)
- [ ] Incremental refresh carries forward open positions
- [ ] CLI script runs with --help showing all flags
- [ ] All tests pass (12+ tests)
</verification>

<success_criteria>
1. EMA crossover signals generated from cmc_daily_features
2. Signals stored with feature_version_hash for reproducibility
3. Parameters loaded from dim_signals configuration
4. Incremental and full refresh modes work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/08-ta_lab2-signals/08-02-SUMMARY.md`
</output>
