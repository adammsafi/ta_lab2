---
phase: 08-ta_lab2-signals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sql/lookups/030_dim_signals.sql
  - sql/signals/060_cmc_signals_ema_crossover.sql
  - sql/signals/061_cmc_signals_rsi_mean_revert.sql
  - sql/signals/062_cmc_signals_atr_breakout.sql
  - sql/signals/063_cmc_signal_state.sql
  - src/ta_lab2/scripts/signals/__init__.py
  - src/ta_lab2/scripts/signals/signal_state_manager.py
  - src/ta_lab2/scripts/signals/signal_utils.py
  - src/ta_lab2/scripts/setup/ensure_dim_signals.py
  - tests/signals/test_signal_state_manager.py
autonomous: true

must_haves:
  truths:
    - "dim_signals table contains active signal configurations queryable by signal_type"
    - "SignalStateManager tracks open positions and last_entry_ts per (id, signal_type, signal_id)"
    - "Signal tables store position lifecycle (entry_ts, exit_ts, pnl_pct, position_state)"
    - "Feature hashing utility computes SHA256 hash of feature data for reproducibility"
  artifacts:
    - path: "sql/lookups/030_dim_signals.sql"
      provides: "Signal configuration table with JSONB params"
      contains: "CREATE TABLE"
    - path: "src/ta_lab2/scripts/signals/signal_state_manager.py"
      provides: "State tracking for stateful signal positions"
      exports: ["SignalStateManager", "SignalStateConfig"]
    - path: "src/ta_lab2/scripts/signals/signal_utils.py"
      provides: "Feature hashing and signal utilities"
      exports: ["compute_feature_hash", "compute_params_hash", "load_active_signals"]
  key_links:
    - from: "src/ta_lab2/scripts/signals/signal_state_manager.py"
      to: "sql/signals/063_cmc_signal_state.sql"
      via: "SQL template matches state table schema"
      pattern: "cmc_signal_state"
    - from: "src/ta_lab2/scripts/signals/signal_utils.py"
      to: "sql/lookups/030_dim_signals.sql"
      via: "load_active_signals queries dim_signals"
      pattern: "dim_signals"
---

<objective>
Create signal infrastructure: dim_signals configuration table, signal table schemas, SignalStateManager for position lifecycle tracking, and reproducibility utilities (feature hashing).

Purpose: Establish foundation for database-driven signal generation with stateful position tracking and reproducibility guarantees. Follows Phase 7 patterns (dim_indicators, FeatureStateManager) adapted for signals.

Output: DDL files for signal tables, SignalStateManager class, signal utilities with feature hashing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ta_lab2-signals/08-CONTEXT.md
@.planning/phases/08-ta_lab2-signals/08-RESEARCH.md

# Phase 7 patterns to follow
@src/ta_lab2/scripts/features/feature_state_manager.py
@sql/lookups/021_dim_indicators.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dim_signals and signal table DDLs</name>
  <files>
    sql/lookups/030_dim_signals.sql
    sql/signals/060_cmc_signals_ema_crossover.sql
    sql/signals/061_cmc_signals_rsi_mean_revert.sql
    sql/signals/062_cmc_signals_atr_breakout.sql
    sql/signals/063_cmc_signal_state.sql
  </files>
  <action>
    Create DDL files following dim_indicators pattern:

    **030_dim_signals.sql:**
    - signal_id SERIAL PRIMARY KEY
    - signal_type TEXT NOT NULL ('ema_crossover', 'rsi_mean_revert', 'atr_breakout')
    - signal_name TEXT NOT NULL UNIQUE (e.g., 'ema_9_21_long', 'rsi_30_70_mr')
    - params JSONB NOT NULL (e.g., {"fast_ema": "ema_21", "slow_ema": "ema_50"})
    - is_active BOOLEAN DEFAULT TRUE
    - description TEXT
    - created_at TIMESTAMPTZ DEFAULT now()
    - Insert seed data for each signal type:
      - ema_crossover: ema_9_21, ema_21_50, ema_50_200
      - rsi_mean_revert: rsi_30_70 (standard), rsi_25_75 (conservative)
      - atr_breakout: atr_20_donchian (Donchian + ATR confirmation)

    **060_cmc_signals_ema_crossover.sql:**
    - id INTEGER NOT NULL (asset)
    - ts TIMESTAMPTZ NOT NULL (signal timestamp)
    - signal_id INTEGER NOT NULL (FK to dim_signals)
    - direction TEXT NOT NULL ('long', 'short')
    - position_state TEXT NOT NULL ('open', 'closed')
    - entry_price NUMERIC, entry_ts TIMESTAMPTZ
    - exit_price NUMERIC, exit_ts TIMESTAMPTZ
    - pnl_pct NUMERIC (computed on close)
    - feature_snapshot JSONB (close, ema_fast, ema_slow, rsi at entry)
    - signal_version TEXT, feature_version_hash TEXT, params_hash TEXT
    - PRIMARY KEY (id, ts, signal_id)
    - INDEX on (id, signal_id, position_state) for open position queries

    **061_cmc_signals_rsi_mean_revert.sql:**
    - Same structure as EMA crossover
    - feature_snapshot includes: close, rsi, atr
    - Add rsi_at_entry, rsi_at_exit columns for analysis

    **062_cmc_signals_atr_breakout.sql:**
    - Same structure
    - feature_snapshot includes: close, high, low, atr, channel_high, channel_low
    - Add breakout_type column ('channel_break', 'atr_expansion', 'both')

    **063_cmc_signal_state.sql:**
    - id INTEGER NOT NULL
    - signal_type TEXT NOT NULL
    - signal_id INTEGER NOT NULL
    - last_entry_ts TIMESTAMPTZ
    - last_exit_ts TIMESTAMPTZ
    - open_position_count INTEGER DEFAULT 0
    - updated_at TIMESTAMPTZ DEFAULT now()
    - PRIMARY KEY (id, signal_type, signal_id)
  </action>
  <verify>
    Run: `psql $TARGET_DB_URL -f sql/lookups/030_dim_signals.sql`
    Run: `psql $TARGET_DB_URL -f sql/signals/060_cmc_signals_ema_crossover.sql`
    (etc. for each file)
    Verify tables created with: `\dt public.dim_signals` and `\dt public.cmc_signals_*`
  </verify>
  <done>
    dim_signals exists with seed data, all 3 signal tables created with correct schema, cmc_signal_state table created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SignalStateManager and signal utilities</name>
  <files>
    src/ta_lab2/scripts/signals/__init__.py
    src/ta_lab2/scripts/signals/signal_state_manager.py
    src/ta_lab2/scripts/signals/signal_utils.py
    src/ta_lab2/scripts/setup/ensure_dim_signals.py
  </files>
  <action>
    **signal_state_manager.py:**
    Adapt FeatureStateManager pattern for signal lifecycle:

    ```python
    @dataclass(frozen=True)
    class SignalStateConfig:
        state_schema: str = "public"
        state_table: str = "cmc_signal_state"
        signal_type: str  # 'ema_crossover', 'rsi_mean_revert', 'atr_breakout'
        ts_column: str = "ts"
        id_column: str = "id"

    class SignalStateManager:
        def __init__(self, engine: Engine, config: SignalStateConfig): ...
        def ensure_state_table(self) -> None: ...
        def load_open_positions(self, ids: list[int], signal_id: int) -> pd.DataFrame:
            # Query signal table for position_state='open'
            # Returns: id, signal_id, entry_ts, entry_price, feature_snapshot
        def update_state_after_generation(self, signal_table: str, signal_id: int) -> None:
            # UPSERT into cmc_signal_state from signal table aggregates
        def get_dirty_window_start(self, ids: list[int], signal_id: int) -> dict[int, pd.Timestamp]:
            # Return last_entry_ts per id for incremental processing
    ```

    **signal_utils.py:**
    ```python
    def compute_feature_hash(df: pd.DataFrame, columns: list[str]) -> str:
        # SHA256 of sorted CSV, return first 16 chars
        df_sorted = df.sort_values('ts')
        csv_bytes = df_sorted[columns].to_csv(index=False).encode('utf-8')
        return hashlib.sha256(csv_bytes).hexdigest()[:16]

    def compute_params_hash(params: dict) -> str:
        # SHA256 of JSON with sorted keys
        json_str = json.dumps(params, sort_keys=True)
        return hashlib.sha256(json_str.encode('utf-8')).hexdigest()[:16]

    def load_active_signals(engine: Engine, signal_type: str) -> list[dict]:
        # Query dim_signals WHERE signal_type = :type AND is_active = TRUE
        # Return list of {signal_id, signal_name, params}
    ```

    **ensure_dim_signals.py:**
    - Idempotent script to ensure dim_signals populated
    - Check if table exists and has rows
    - If not, execute 030_dim_signals.sql
    - Log status

    **__init__.py:**
    Export: SignalStateManager, SignalStateConfig, compute_feature_hash, compute_params_hash, load_active_signals
  </action>
  <verify>
    Run: `python -c "from ta_lab2.scripts.signals import SignalStateManager, compute_feature_hash; print('OK')"`
    Verify imports work without errors.
  </verify>
  <done>
    SignalStateManager class created with load_open_positions, update_state_after_generation methods.
    signal_utils.py exports compute_feature_hash, compute_params_hash, load_active_signals.
    ensure_dim_signals.py script created.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create tests for signal infrastructure</name>
  <files>
    tests/signals/__init__.py
    tests/signals/test_signal_state_manager.py
    tests/signals/test_signal_utils.py
  </files>
  <action>
    **test_signal_state_manager.py:**
    Use unittest.mock for database-free testing (follow Phase 7 pattern):
    - test_ensure_state_table_executes_create: Mock engine, verify SQL executed
    - test_load_open_positions_returns_dataframe: Mock read_sql, verify query structure
    - test_load_open_positions_empty_returns_empty_df: No open positions returns empty
    - test_update_state_after_generation_upserts: Verify UPSERT SQL template
    - test_get_dirty_window_start_returns_dict: Verify timestamp dict returned
    - test_config_immutable: Verify frozen dataclass
    - Integration tests with skipif(not TARGET_DB_URL):
      - test_roundtrip_open_positions: Insert signal, load open, verify match

    **test_signal_utils.py:**
    - test_compute_feature_hash_deterministic: Same data = same hash
    - test_compute_feature_hash_changes_on_data_change: Modify value, hash differs
    - test_compute_feature_hash_order_independent: Row order doesn't affect (sorted internally)
    - test_compute_params_hash_sorted_keys: Different insertion order, same hash
    - test_load_active_signals_filters_inactive: Mock query with is_active filter
    - test_load_active_signals_returns_list_of_dicts: Verify structure
  </action>
  <verify>
    Run: `pytest tests/signals/test_signal_state_manager.py tests/signals/test_signal_utils.py -v`
    All tests pass.
  </verify>
  <done>
    14+ tests passing for signal infrastructure (state manager + utilities).
  </done>
</task>

</tasks>

<verification>
Phase verification checklist:
- [ ] dim_signals table exists with seed data for 3 signal types
- [ ] cmc_signals_ema_crossover, cmc_signals_rsi_mean_revert, cmc_signals_atr_breakout tables exist
- [ ] cmc_signal_state table exists with correct PK
- [ ] SignalStateManager.load_open_positions returns DataFrame with expected columns
- [ ] compute_feature_hash produces deterministic 16-char hash
- [ ] load_active_signals returns list of dicts with signal_id, signal_name, params
- [ ] All tests pass (14+ tests)
</verification>

<success_criteria>
1. dim_signals contains active signal configurations (at least 6 seed records)
2. SignalStateManager tracks open positions per (id, signal_type, signal_id)
3. Feature hashing utility produces reproducible hashes
4. All signal infrastructure tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-ta_lab2-signals/08-01-SUMMARY.md`
</output>
