---
phase: 08-ta_lab2-signals
plan: 04
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/ta_lab2/scripts/signals/generate_signals_atr.py
  - src/ta_lab2/scripts/signals/refresh_cmc_signals_atr_breakout.py
  - tests/signals/test_atr_signal_generation.py
autonomous: true

must_haves:
  truths:
    - "ATR breakout signals generated from cmc_daily_features and stored in database"
    - "Breakout parameters (lookback, atr_mult) loaded from dim_signals"
    - "breakout_type column indicates signal trigger (channel_break, atr_expansion)"
    - "Channel high/low captured in feature_snapshot for audit"
  artifacts:
    - path: "src/ta_lab2/scripts/signals/generate_signals_atr.py"
      provides: "ATR breakout signal generation"
      exports: ["ATRSignalGenerator"]
    - path: "src/ta_lab2/scripts/signals/refresh_cmc_signals_atr_breakout.py"
      provides: "CLI for ATR signal refresh"
      min_lines: 80
  key_links:
    - from: "src/ta_lab2/scripts/signals/generate_signals_atr.py"
      to: "src/ta_lab2/signals/breakout_atr.py"
      via: "calls make_signals for signal generation"
      pattern: "from.*signals.*breakout_atr.*import.*make_signals"
    - from: "src/ta_lab2/scripts/signals/generate_signals_atr.py"
      to: "src/ta_lab2/scripts/signals/signal_utils.py"
      via: "uses compute_feature_hash"
      pattern: "compute_feature_hash"
---

<objective>
Create ATR breakout signal generation: load parameters from dim_signals, generate signals using existing breakout_atr.py adapter, track breakout type and channel levels, store in cmc_signals_atr_breakout.

Purpose: Third signal type completing the signal generation suite. ATR breakouts detect momentum moves using Donchian channels with ATR confirmation. Provides trend-following signals to complement mean-reversion (RSI).

Output: ATRSignalGenerator class, CLI refresh script, 12+ tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ta_lab2-signals/08-CONTEXT.md
@.planning/phases/08-ta_lab2-signals/08-RESEARCH.md
@.planning/phases/08-ta_lab2-signals/08-01-SUMMARY.md

# Existing signal adapter to leverage
@src/ta_lab2/signals/breakout_atr.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ATRSignalGenerator class</name>
  <files>
    src/ta_lab2/scripts/signals/generate_signals_atr.py
  </files>
  <action>
    Create ATRSignalGenerator following established pattern:

    1. **Load configuration from dim_signals:**
       ```python
       # dim_signals params for ATR breakout:
       # {"lookback": 20, "atr_col": "atr_14", "trail_atr_mult": 2.0,
       #  "confirm_close": true, "exit_on_channel_crossback": true}
       configs = load_active_signals(engine, 'atr_breakout')
       ```

    2. **Load features from cmc_daily_features:**
       ```python
       def load_features(self, ids: list[int], start_ts: pd.Timestamp) -> pd.DataFrame:
           sql = """
               SELECT id, ts, open, high, low, close, atr_14,
                      bb_up_20_2, bb_lo_20_2
               FROM cmc_daily_features
               WHERE id = ANY(:ids) AND ts >= :start_ts
               ORDER BY id, ts
           """
           # Include OHLC for Donchian channel computation
           # Include BB for optional Bollinger confirmation
       ```

    3. **Generate signals using existing adapter:**
       ```python
       from ta_lab2.signals.breakout_atr import make_signals

       entries, exits, size = make_signals(
           df_features,
           lookback=params.get('lookback', 20),
           atr_col=params.get('atr_col', 'atr_14'),
           confirm_close=params.get('confirm_close', True),
           exit_on_channel_crossback=params.get('exit_on_channel_crossback', True),
           use_trailing_atr_stop=params.get('use_trailing_atr_stop', True),
           trail_atr_mult=params.get('trail_atr_mult', 2.0),
       )
       ```

    4. **Compute channel levels for audit trail:**
       ```python
       def compute_channel_levels(df: pd.DataFrame, lookback: int) -> pd.DataFrame:
           """Add channel_high, channel_low columns for feature_snapshot."""
           df['channel_high'] = df['high'].rolling(lookback, min_periods=lookback).max()
           df['channel_low'] = df['low'].rolling(lookback, min_periods=lookback).min()
           return df
       ```

    5. **Transform to stateful records with breakout tracking:**
       ```python
       def transform_signals_to_records(...) -> pd.DataFrame:
           # ATR-specific fields:
           # - breakout_type: 'channel_break' (price > channel_high)
           #                  'atr_expansion' (if ATR filter triggered)
           #                  'both' (channel break with ATR confirmation)
           # - feature_snapshot includes: close, high, low, atr, channel_high, channel_low
       ```

    6. **Determine breakout_type:**
       ```python
       def classify_breakout_type(row, params) -> str:
           # Logic:
           # - If close > channel_high: 'channel_break'
           # - If ATR expanding (ATR > ATR_sma * 1.5): 'atr_expansion'
           # - If both: 'both'
           # Store for analysis of which breakout type performs better
       ```

    Class structure:
    ```python
    @dataclass
    class ATRSignalGenerator:
        engine: Engine
        state_manager: SignalStateManager
        signal_version: str = "1.0"

        def generate_for_ids(self, ids: list[int], signal_config: dict, full_refresh: bool = False) -> int:
            # Same pattern as EMA/RSI
            # Adds: breakout_type, channel_high, channel_low to records
    ```
  </action>
  <verify>
    Run: `python -c "from ta_lab2.scripts.signals.generate_signals_atr import ATRSignalGenerator; print('OK')"`
    Verify class imports without error.
  </verify>
  <done>
    ATRSignalGenerator class created with generate_for_ids method, breakout classification, and channel level tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create refresh CLI script</name>
  <files>
    src/ta_lab2/scripts/signals/refresh_cmc_signals_atr_breakout.py
  </files>
  <action>
    Create CLI script following established pattern:

    ```python
    #!/usr/bin/env python
    """Refresh ATR breakout signals from cmc_daily_features."""

    import argparse
    import logging
    import os
    from sqlalchemy import create_engine
    from ta_lab2.scripts.signals import (
        SignalStateManager, SignalStateConfig, load_active_signals
    )
    from ta_lab2.scripts.signals.generate_signals_atr import ATRSignalGenerator

    def main():
        parser = argparse.ArgumentParser()
        parser.add_argument('--ids', type=int, nargs='+', help='Asset IDs')
        parser.add_argument('--signal-id', type=int, help='Specific signal_id')
        parser.add_argument('--full-refresh', action='store_true')
        parser.add_argument('--dry-run', action='store_true')
        parser.add_argument('--verbose', '-v', action='store_true')
        args = parser.parse_args()

        logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)
        logger = logging.getLogger(__name__)

        engine = create_engine(os.environ['TARGET_DB_URL'])

        config = SignalStateConfig(signal_type='atr_breakout')
        state_manager = SignalStateManager(engine, config)
        state_manager.ensure_state_table()

        if args.signal_id:
            configs = [c for c in load_active_signals(engine, 'atr_breakout')
                       if c['signal_id'] == args.signal_id]
        else:
            configs = load_active_signals(engine, 'atr_breakout')

        ids = args.ids or _get_all_asset_ids(engine)

        generator = ATRSignalGenerator(engine, state_manager)
        total_signals = 0

        for config in configs:
            logger.info(f"Processing signal: {config['signal_name']}")
            n = generator.generate_for_ids(
                ids=ids,
                signal_config=config,
                full_refresh=args.full_refresh,
                dry_run=args.dry_run,
            )
            total_signals += n

        logger.info(f"Total: {total_signals} ATR breakout signals generated")

    if __name__ == '__main__':
        main()
    ```
  </action>
  <verify>
    Run: `python src/ta_lab2/scripts/signals/refresh_cmc_signals_atr_breakout.py --help`
    Verify help text shows all arguments.
  </verify>
  <done>
    CLI script created with same flags as other signal refresh scripts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create tests for ATR signal generation</name>
  <files>
    tests/signals/test_atr_signal_generation.py
  </files>
  <action>
    Create tests using unittest.mock:

    **Unit tests:**
    - test_compute_channel_levels_rolling_max_min: Verify Donchian channel calculation
    - test_classify_breakout_type_channel_break: close > channel_high
    - test_classify_breakout_type_atr_expansion: ATR expanding condition
    - test_classify_breakout_type_both: Channel break with ATR confirmation
    - test_transform_signals_includes_breakout_type: Verify column populated
    - test_transform_signals_includes_channel_levels: channel_high, channel_low in snapshot
    - test_generate_loads_lookback_from_config: params['lookback'] used
    - test_generate_uses_atr_column_from_config: params['atr_col'] passed
    - test_trailing_stop_parameter_honored: use_trailing_atr_stop controls exit logic

    **Integration tests (skipif not TARGET_DB_URL):**
    - test_roundtrip_atr_signal_generation: Generate, query, verify structure
    - test_channel_levels_match_source_data: Verify computed channels align
    - test_different_lookbacks_produce_different_signals: lookback=10 vs 20
  </action>
  <verify>
    Run: `pytest tests/signals/test_atr_signal_generation.py -v`
    All tests pass.
  </verify>
  <done>
    12+ tests passing for ATR signal generation.
  </done>
</task>

</tasks>

<verification>
Phase verification checklist:
- [ ] ATRSignalGenerator.generate_for_ids produces signal records
- [ ] Signals stored in cmc_signals_atr_breakout table
- [ ] breakout_type column indicates trigger (channel_break, atr_expansion, both)
- [ ] channel_high, channel_low in feature_snapshot
- [ ] Parameters loaded from dim_signals
- [ ] CLI script runs with --help
- [ ] All tests pass (12+ tests)
</verification>

<success_criteria>
1. ATR breakout signals generated from cmc_daily_features
2. Breakout type classified and stored for analysis
3. Channel levels captured for audit trail
4. Parameters configurable via dim_signals
</success_criteria>

<output>
After completion, create `.planning/phases/08-ta_lab2-signals/08-04-SUMMARY.md`
</output>
