---
phase: 14-tools-integration
plan: 09
type: execute
wave: 5
depends_on: ["14-03", "14-04", "14-05", "14-06", "14-07", "14-08"]
files_modified:
  - tests/tools/data_tools/test_imports_smoke.py
  - tests/tools/data_tools/test_hardcoded_paths.py
  - tests/tools/data_tools/conftest.py
autonomous: true

must_haves:
  truths:
    - "All migrated modules pass import smoke tests"
    - "No hardcoded absolute paths in migrated code"
    - "Test failures documented for gap closure"
  artifacts:
    - path: "tests/tools/data_tools/test_imports_smoke.py"
      provides: "Parametrized import tests"
      contains: "pytest.mark.parametrize"
    - path: "tests/tools/data_tools/test_hardcoded_paths.py"
      provides: "AST-based path validation"
      contains: "ast.walk"
  key_links:
    - from: "tests/tools/data_tools/test_imports_smoke.py"
      to: "src/ta_lab2/tools/data_tools"
      via: "importlib.import_module"
      pattern: "importlib.import_module.*ta_lab2.tools.data_tools"
---

<objective>
Create validation tests for migrated scripts (smoke tests + path validation)

Purpose: Verify all migrated scripts import successfully and contain no hardcoded absolute paths. Document any failures for gap closure plans.

Output: Passing smoke tests and path validation; documented failures if any
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-tools-integration/14-CONTEXT.md
@.planning/phases/14-tools-integration/14-RESEARCH.md
@.planning/phases/14-tools-integration/14-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create smoke test for module imports</name>
  <files>
    tests/tools/data_tools/conftest.py
    tests/tools/data_tools/test_imports_smoke.py
  </files>
  <action>
Create test directory and smoke tests:

**conftest.py:**
```python
"""Shared fixtures for data_tools tests."""
import pytest
from pathlib import Path

@pytest.fixture
def data_tools_root():
    """Path to data_tools package."""
    return Path(__file__).parent.parent.parent.parent / "src" / "ta_lab2" / "tools" / "data_tools"
```

**test_imports_smoke.py:**
```python
"""Smoke tests: verify all migrated data_tools modules import successfully."""
import importlib
import pytest

# Build module list from 14-01-discovery.json "migrate" entries
# Group by category for clarity

ANALYSIS_MODULES = [
    "ta_lab2.tools.data_tools.analysis.generate_function_map",
    "ta_lab2.tools.data_tools.analysis.tree_structure",
]

DATABASE_MODULES = [
    "ta_lab2.tools.data_tools.database_utils.write_daily_emas",
    "ta_lab2.tools.data_tools.database_utils.write_multi_tf_emas",
    "ta_lab2.tools.data_tools.database_utils.write_ema_multi_tf_cal",
    "ta_lab2.tools.data_tools.database_utils.upsert_new_emas",
]

MEMORY_MODULES = [
    "ta_lab2.tools.data_tools.memory.embed_codebase",
    "ta_lab2.tools.data_tools.memory.embed_memories",
    "ta_lab2.tools.data_tools.memory.generate_memories_from_code",
    "ta_lab2.tools.data_tools.memory.memory_bank_rest",
    "ta_lab2.tools.data_tools.memory.setup_mem0",
]

EXPORT_MODULES = [
    "ta_lab2.tools.data_tools.export.export_chatgpt_conversations",
    "ta_lab2.tools.data_tools.export.chatgpt_export_diff",
    "ta_lab2.tools.data_tools.export.chatgpt_export_clean",
    "ta_lab2.tools.data_tools.export.chatgpt_pipeline",
    "ta_lab2.tools.data_tools.export.process_new_chatgpt_dump",
]

GENERATOR_MODULES = [
    "ta_lab2.tools.data_tools.generators.review_generator",
    "ta_lab2.tools.data_tools.generators.category_digest_generator",
    "ta_lab2.tools.data_tools.generators.finetuning_data_generator",
]

CONTEXT_MODULES = [
    "ta_lab2.tools.data_tools.context.get_context",
    "ta_lab2.tools.data_tools.context.chat_with_context",
    "ta_lab2.tools.data_tools.context.ask_project",
]

ALL_MODULES = (
    ANALYSIS_MODULES
    + DATABASE_MODULES
    + MEMORY_MODULES
    + EXPORT_MODULES
    + GENERATOR_MODULES
    + CONTEXT_MODULES
)


@pytest.mark.parametrize("module_name", ALL_MODULES)
def test_module_imports_successfully(module_name):
    """Smoke test: each migrated module can be imported without errors."""
    try:
        importlib.import_module(module_name)
    except ImportError as e:
        # Allow graceful failures for optional dependencies
        if "pip install" in str(e):
            pytest.skip(f"Optional dependency not installed: {e}")
        else:
            pytest.fail(f"Failed to import {module_name}: {e}")


@pytest.mark.parametrize("module_name", ALL_MODULES)
def test_module_has_docstring(module_name):
    """Each module should have a docstring explaining its purpose."""
    try:
        module = importlib.import_module(module_name)
    except ImportError:
        pytest.skip("Module has optional dependency not installed")

    assert module.__doc__ is not None, f"{module_name} missing docstring"
    assert len(module.__doc__.strip()) > 10, f"{module_name} docstring too short"
```

Update module lists based on actual migrated scripts from prior plans.
  </action>
  <verify>pytest tests/tools/data_tools/test_imports_smoke.py -v --collect-only shows all tests</verify>
  <done>Smoke tests created for all migrated modules</done>
</task>

<task type="auto">
  <name>Task 2: Create AST-based hardcoded path validation</name>
  <files>tests/tools/data_tools/test_hardcoded_paths.py</files>
  <action>
Create AST-based path detection test (from 14-RESEARCH.md pattern):

```python
"""Validation: ensure no hardcoded absolute paths remain in migrated code."""
import ast
from pathlib import Path
import pytest


def find_hardcoded_paths(file_path: Path) -> list[tuple[int, str]]:
    """
    Scan Python file for potential hardcoded absolute paths.

    Returns list of (line_number, path_string) tuples.
    """
    source = file_path.read_text(encoding="utf-8")
    try:
        tree = ast.parse(source, filename=str(file_path))
    except SyntaxError:
        return []  # Skip files with syntax errors (will fail import tests)

    suspicious = []
    for node in ast.walk(tree):
        if isinstance(node, ast.Constant) and isinstance(node.value, str):
            val = node.value
            # Check for absolute path patterns
            if any(
                val.startswith(prefix)
                for prefix in ["C:\\", "C:/", "/home/", "/Users/", "D:\\", "E:\\"]
            ):
                # Filter out short strings (likely not paths) and URL-like patterns
                if len(val) > 10 and "://" not in val:
                    suspicious.append((node.lineno, val))

    return suspicious


def test_no_hardcoded_paths_in_migrated_modules():
    """Migrated modules must not contain hardcoded absolute paths."""
    data_tools_dir = (
        Path(__file__).parent.parent.parent.parent
        / "src"
        / "ta_lab2"
        / "tools"
        / "data_tools"
    )
    python_files = list(data_tools_dir.rglob("*.py"))

    assert len(python_files) > 0, "No Python files found in data_tools"

    failures = []
    for py_file in python_files:
        if py_file.name == "__init__.py":
            continue  # __init__.py files often have import path strings

        hardcoded = find_hardcoded_paths(py_file)
        if hardcoded:
            failures.append((py_file, hardcoded))

    if failures:
        msg = "Found hardcoded absolute paths:\n"
        for file_path, paths in failures:
            rel_path = file_path.relative_to(data_tools_dir.parent.parent.parent.parent)
            msg += f"\n{rel_path}:\n"
            for lineno, path in paths:
                msg += f"  Line {lineno}: {path[:50]}{'...' if len(path) > 50 else ''}\n"
        pytest.fail(msg)


def test_no_sys_path_manipulation():
    """Migrated modules should not manipulate sys.path."""
    data_tools_dir = (
        Path(__file__).parent.parent.parent.parent
        / "src"
        / "ta_lab2"
        / "tools"
        / "data_tools"
    )
    python_files = list(data_tools_dir.rglob("*.py"))

    failures = []
    for py_file in python_files:
        source = py_file.read_text(encoding="utf-8")
        try:
            tree = ast.parse(source)
        except SyntaxError:
            continue

        for node in ast.walk(tree):
            # Check for sys.path.append() or sys.path.insert()
            if (
                isinstance(node, ast.Call)
                and isinstance(node.func, ast.Attribute)
                and node.func.attr in ("append", "insert")
                and isinstance(node.func.value, ast.Attribute)
                and node.func.value.attr == "path"
                and isinstance(node.func.value.value, ast.Name)
                and node.func.value.value.id == "sys"
            ):
                failures.append((py_file, node.lineno))

    if failures:
        msg = "Found sys.path manipulation:\n"
        for file_path, lineno in failures:
            rel_path = file_path.relative_to(data_tools_dir.parent.parent.parent.parent)
            msg += f"  {rel_path}: Line {lineno}\n"
        pytest.fail(msg)
```
  </action>
  <verify>pytest tests/tools/data_tools/test_hardcoded_paths.py -v passes</verify>
  <done>Path validation tests created with AST-based detection</done>
</task>

<task type="auto">
  <name>Task 3: Run tests and document failures</name>
  <files>None (test execution only)</files>
  <action>
Run all validation tests:

```bash
pytest tests/tools/data_tools/ -v --tb=short
```

If tests fail:
1. Document failures in SUMMARY with specific files/lines
2. Create list of gap closure items:
   - Import failures -> missing refactoring
   - Hardcoded paths -> need path parameterization
   - sys.path manipulation -> need import cleanup

If all tests pass:
1. Document success in SUMMARY
2. Note that Phase 14 validation complete

Commit tests:
```bash
git add tests/tools/data_tools/
git commit -m "test(14): add validation tests for migrated data_tools

- test_imports_smoke.py: Parametrized import tests for all modules
- test_hardcoded_paths.py: AST-based path detection
- conftest.py: Shared fixtures

Tests verify:
- All migrated modules importable (with graceful skip for optional deps)
- No hardcoded absolute paths remain
- No sys.path manipulation in migrated code"
```
  </action>
  <verify>pytest tests/tools/data_tools/ -v completes (pass or documented failures)</verify>
  <done>Tests executed; results documented for gap closure if needed</done>
</task>

</tasks>

<verification>
- `pytest tests/tools/data_tools/ -v --collect-only` shows expected test count
- `pytest tests/tools/data_tools/test_imports_smoke.py` passes (or skips for optional deps)
- `pytest tests/tools/data_tools/test_hardcoded_paths.py` passes
</verification>

<success_criteria>
1. Smoke tests created for all migrated modules (parametrized)
2. Path validation tests created with AST-based detection
3. sys.path manipulation detection test created
4. Tests run and results documented
5. Any failures documented for gap closure
6. Tests committed to git
</success_criteria>

<output>
After completion, create `.planning/phases/14-tools-integration/14-09-SUMMARY.md`
</output>
