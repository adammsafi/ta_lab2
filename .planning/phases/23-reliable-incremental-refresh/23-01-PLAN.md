---
phase: 23-reliable-incremental-refresh
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ta_lab2/scripts/emas/run_all_ema_refreshes.py
autonomous: true

must_haves:
  truths:
    - "EMA orchestrator uses subprocess for isolation (consistent with bar orchestrator)"
    - "User can run --dry-run to see what would execute without running"
    - "User can control verbosity with --verbose flag"
    - "Summary report shows counts, durations, and success/failure per step"
  artifacts:
    - path: "src/ta_lab2/scripts/emas/run_all_ema_refreshes.py"
      provides: "Enhanced EMA orchestrator with subprocess isolation"
      exports: ["main", "RefresherConfig", "RefresherResult"]
  key_links:
    - from: "run_all_ema_refreshes.py"
      to: "subprocess.run"
      via: "subprocess call for each EMA script"
      pattern: "subprocess\\.run"
---

<objective>
Enhance EMA orchestrator to match bar orchestrator quality

Purpose: The bar orchestrator (`run_all_bar_builders.py`) uses subprocess isolation, has dry-run support, and produces clean summary reports. The EMA orchestrator uses runpy (in-process) which can leak state and doesn't support dry-run. Align patterns for consistency and reliability.

Output: Enhanced `run_all_ema_refreshes.py` with subprocess isolation, dry-run, verbose control, and summary reporting matching bar orchestrator patterns.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Source files to reference
@src/ta_lab2/scripts/bars/run_all_bar_builders.py
@src/ta_lab2/scripts/emas/run_all_ema_refreshes.py
@src/ta_lab2/scripts/emas/logging_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor EMA orchestrator to use subprocess</name>
  <files>src/ta_lab2/scripts/emas/run_all_ema_refreshes.py</files>
  <action>
Refactor `run_all_ema_refreshes.py` to use subprocess instead of runpy:

1. **Create RefresherConfig dataclass** (mirror BuilderConfig from bar orchestrator):
   ```python
   @dataclass
   class RefresherConfig:
       name: str
       script_path: str
       description: str
       supports_scheme: bool = False  # For cal/cal_anchor with us/iso/both
       custom_args: dict[str, str] | None = None
   ```

2. **Define ALL_REFRESHERS list** with 4 configs:
   - multi_tf: "refresh_cmc_ema_multi_tf_from_bars.py" - "Multi-TF EMAs (tf_day based)"
   - cal: "refresh_cmc_ema_multi_tf_cal_from_bars.py" - "Calendar-aligned EMAs (us/iso)"
   - cal_anchor: "refresh_cmc_ema_multi_tf_cal_anchor_from_bars.py" - "Calendar-anchored EMAs"
   - v2: "refresh_cmc_ema_multi_tf_v2.py" - "Daily-space EMAs (v2)"

3. **Use relative paths from script directory** (not hardcoded absolute paths):
   ```python
   script_dir = Path(__file__).parent
   script_path = script_dir / refresher.script_path
   ```

4. **Replace runpy.run_path with subprocess.run**:
   ```python
   def run_refresher(refresher: RefresherConfig, cmd: list[str], *, verbose: bool) -> RefresherResult:
       # Mirror run_builder() from bar orchestrator
       if verbose:
           result = subprocess.run(cmd, check=False)
       else:
           result = subprocess.run(cmd, check=False, capture_output=True, text=True)
           if result.returncode != 0:
               # Show output only on error
   ```

5. **Create RefresherResult dataclass** (mirror BuilderResult):
   ```python
   @dataclass
   class RefresherResult:
       name: str
       success: bool
       duration_sec: float
       returncode: int
       error_message: str | None = None
   ```

6. **Preserve existing CLI arguments** but reorganize:
   - Keep all existing args: --ids, --start, --end, --periods, --cal-scheme, --anchor-scheme, etc.
   - Move scheme mapping logic into build_command() function
   - Keep --only for filtering which refreshers to run

7. **Remove the _run_script function** that uses runpy - replace with run_refresher that uses subprocess.
  </action>
  <verify>
Run `python src/ta_lab2/scripts/emas/run_all_ema_refreshes.py --help` and verify all existing CLI options still appear.
Run `python -c "from ta_lab2.scripts.emas.run_all_ema_refreshes import RefresherConfig, RefresherResult; print('OK')"` to verify imports work.
  </verify>
  <done>EMA orchestrator uses subprocess.run instead of runpy.run_path for script execution</done>
</task>

<task type="auto">
  <name>Task 2: Add dry-run, verbose, and summary reporting</name>
  <files>src/ta_lab2/scripts/emas/run_all_ema_refreshes.py</files>
  <action>
Add dry-run support, verbose control, and summary reporting to match bar orchestrator:

1. **Add CLI arguments**:
   ```python
   p.add_argument("--dry-run", action="store_true", help="Print commands without executing")
   p.add_argument("--verbose", action="store_true", help="Show refresher output (default: only show on error)")
   ```

2. **Implement build_command() function** that constructs subprocess command:
   ```python
   def build_command(refresher: RefresherConfig, *, ids: str, start: str, end: str | None,
                     periods: str, scheme: str | None, ...) -> list[str]:
       script_dir = Path(__file__).parent
       cmd = [sys.executable, str(script_dir / refresher.script_path)]
       # Map global args to per-script args
       cmd.extend(["--ids", ids])
       if refresher.supports_scheme and scheme:
           cmd.extend(["--scheme", scheme])
       # ... etc
       return cmd
   ```

3. **Implement print_summary() function** (mirror bar orchestrator exactly):
   ```python
   def print_summary(results: list[RefresherResult]) -> bool:
       print(f"\n{'='*70}")
       print("EXECUTION SUMMARY")
       print(f"{'='*70}")
       # Total refreshers, successful, failed, total time
       # List successful with duration
       # List failed with error message
       # Return True if all success, False otherwise
   ```

4. **Update main() loop**:
   ```python
   for refresher in refreshers:
       cmd = build_command(refresher, ...)
       if args.dry_run:
           print(f"\n[DRY RUN] {refresher.name}:")
           print(f"  {' '.join(cmd)}")
           continue
       result = run_refresher(refresher, cmd, verbose=args.verbose)
       results.append(result)
       if not result.success and not args.continue_on_error:
           break
   ```

5. **Keep existing --validate and --alert-on-validation-error** functionality - this already works and should remain.

6. **Banner at start** (mirror bar orchestrator):
   ```python
   print(f"\n{'='*70}")
   print(f"EMA REFRESHERS ORCHESTRATOR")
   print(f"{'='*70}")
   print(f"\nRefreshers to run: {', '.join(r.name for r in refreshers)}")
   # ... config summary
   ```
  </action>
  <verify>
Run `python src/ta_lab2/scripts/emas/run_all_ema_refreshes.py --dry-run --ids 1` and verify it prints commands without executing.
Run with `--verbose` flag and `--dry-run` to see output format matches bar orchestrator style.
  </verify>
  <done>EMA orchestrator has dry-run, verbose control, and summary reporting matching bar orchestrator patterns</done>
</task>

</tasks>

<verification>
1. `python src/ta_lab2/scripts/emas/run_all_ema_refreshes.py --help` shows all CLI options including --dry-run and --verbose
2. `python src/ta_lab2/scripts/emas/run_all_ema_refreshes.py --dry-run --ids 1` prints 4 commands without executing
3. The script no longer imports runpy (use `grep -c "import runpy" src/ta_lab2/scripts/emas/run_all_ema_refreshes.py` should return 0)
4. RefresherConfig and RefresherResult dataclasses are importable
</verification>

<success_criteria>
- EMA orchestrator uses subprocess.run for isolation
- --dry-run flag shows commands without executing
- --verbose flag controls output visibility
- Summary report at end shows counts, durations, success/failure per step
- All existing CLI functionality preserved (--ids, --periods, --cal-scheme, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/23-reliable-incremental-refresh/23-01-SUMMARY.md`
</output>
