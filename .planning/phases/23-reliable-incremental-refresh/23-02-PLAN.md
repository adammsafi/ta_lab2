---
phase: 23-reliable-incremental-refresh
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/ta_lab2/scripts/run_daily_refresh.py
  - src/ta_lab2/scripts/refresh_utils.py
autonomous: true

must_haves:
  truths:
    - "User can run one command for complete daily refresh (bars + EMAs)"
    - "User can run bars-only or EMAs-only with explicit flags"
    - "Script checks bar freshness before running EMAs (state-based)"
    - "Partial failures skip affected IDs but continue for others"
  artifacts:
    - path: "src/ta_lab2/scripts/run_daily_refresh.py"
      provides: "Unified orchestration entry point"
      exports: ["main"]
    - path: "src/ta_lab2/scripts/refresh_utils.py"
      provides: "Shared utilities for state checking and ID filtering"
      exports: ["check_bar_freshness", "get_fresh_ids", "FreshnessResult"]
  key_links:
    - from: "run_daily_refresh.py"
      to: "run_all_bar_builders.py"
      via: "subprocess call"
      pattern: "subprocess\\.run.*bar_builders"
    - from: "run_daily_refresh.py"
      to: "run_all_ema_refreshes.py"
      via: "subprocess call"
      pattern: "subprocess\\.run.*ema_refreshes"
    - from: "run_daily_refresh.py"
      to: "cmc_price_bars_1d_state"
      via: "freshness check query"
      pattern: "check_bar_freshness|get_fresh_ids"
---

<objective>
Create unified daily refresh orchestration script

Purpose: Users need one command for daily refresh with clear visibility into what happened. The script coordinates bars -> EMAs with state-based checking, handles partial failures gracefully, and provides meaningful summary output.

Output: `run_daily_refresh.py` that orchestrates bars and EMAs with modular separation and state-based coordination.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Source files to reference
@src/ta_lab2/scripts/bars/run_all_bar_builders.py
@src/ta_lab2/scripts/emas/run_all_ema_refreshes.py
@sql/ddl/create_cmc_price_bars_1d_state.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create refresh utilities module</name>
  <files>src/ta_lab2/scripts/refresh_utils.py</files>
  <action>
Create `refresh_utils.py` with shared utilities for state checking:

1. **FreshnessResult dataclass**:
   ```python
   @dataclass
   class FreshnessResult:
       id: int
       last_src_ts: datetime | None
       is_fresh: bool
       staleness_hours: float | None
       reason: str  # "fresh", "stale", "no_state"
   ```

2. **check_bar_freshness() function**:
   ```python
   def check_bar_freshness(
       db_url: str,
       ids: list[int] | None = None,
       max_staleness_hours: float = 48.0,
   ) -> list[FreshnessResult]:
       """
       Check bar freshness by comparing last_src_ts to current time.

       Args:
           db_url: Database connection URL
           ids: Specific IDs to check (None = all with state)
           max_staleness_hours: Max hours since last update to consider fresh

       Returns:
           List of FreshnessResult for each ID
       """
       # Query cmc_price_bars_1d_state table
       # Compare last_src_ts to now()
       # Return results with staleness calculation
   ```

3. **get_fresh_ids() convenience function**:
   ```python
   def get_fresh_ids(
       db_url: str,
       ids: list[int] | None = None,
       max_staleness_hours: float = 48.0,
   ) -> tuple[list[int], list[int]]:
       """
       Get IDs with fresh bars vs stale/missing bars.

       Returns:
           (fresh_ids, stale_ids) - IDs suitable for EMA refresh vs needing bar refresh
       """
       results = check_bar_freshness(db_url, ids, max_staleness_hours)
       fresh = [r.id for r in results if r.is_fresh]
       stale = [r.id for r in results if not r.is_fresh]
       return fresh, stale
   ```

4. **parse_ids() helper** (extract from orchestrators to share):
   ```python
   def parse_ids(ids_arg: str, db_url: str | None = None) -> list[int] | None:
       """
       Parse --ids argument into list of integers.

       Args:
           ids_arg: "all" or comma-separated IDs like "1,52,825"
           db_url: If provided and ids_arg is "all", query dim_assets for valid IDs

       Returns:
           None for "all", list of ints otherwise
       """
   ```

5. **resolve_db_url() helper** (extract common pattern):
   ```python
   def resolve_db_url(cli_db_url: str | None = None) -> str:
       """
       Resolve database URL from CLI arg, config file, or environment.

       Priority:
       1. CLI argument if provided
       2. db_config.env file (searched up to 5 dirs up)
       3. TARGET_DB_URL environment variable
       4. MARKETDATA_DB_URL environment variable

       Raises:
           RuntimeError if no database URL found
       """
   ```
  </action>
  <verify>
Run `python -c "from ta_lab2.scripts.refresh_utils import check_bar_freshness, get_fresh_ids, FreshnessResult; print('OK')"` to verify imports.
  </verify>
  <done>Shared utilities module exists with state checking functions</done>
</task>

<task type="auto">
  <name>Task 2: Create unified daily refresh script</name>
  <files>src/ta_lab2/scripts/run_daily_refresh.py</files>
  <action>
Create `run_daily_refresh.py` as the unified orchestration entry point:

1. **CLI arguments** (explicit targets required):
   ```python
   p.add_argument("--bars", action="store_true", help="Run bar builders only")
   p.add_argument("--emas", action="store_true", help="Run EMA refreshers only")
   p.add_argument("--all", action="store_true", help="Run bars then EMAs (full refresh)")
   p.add_argument("--ids", default="all", help='Comma-separated IDs or "all"')
   p.add_argument("--db-url", help="Database URL (default: from config/env)")
   p.add_argument("--dry-run", action="store_true", help="Show what would execute")
   p.add_argument("--verbose", action="store_true", help="Show detailed output")
   p.add_argument("--continue-on-error", action="store_true", help="Continue on failures")
   p.add_argument("--skip-stale-check", action="store_true", help="Skip bar freshness check for EMAs")
   p.add_argument("--staleness-hours", type=float, default=48.0, help="Max hours for bar freshness")
   ```

2. **Validation** - require explicit target:
   ```python
   if not (args.bars or args.emas or args.all):
       parser.error("Must specify --bars, --emas, or --all")
   ```

3. **Execution flow**:
   ```python
   def main():
       # Parse args, resolve db_url

       # Determine what to run
       run_bars = args.bars or args.all
       run_emas = args.emas or args.all

       results = []

       # Run bars if requested
       if run_bars:
           bar_result = run_bar_builders(args)
           results.append(("bars", bar_result))

           if not bar_result.success and not args.continue_on_error:
               return 1

       # Run EMAs if requested
       if run_emas:
           # Check bar freshness first (unless --skip-stale-check)
           if not args.skip_stale_check:
               fresh_ids, stale_ids = get_fresh_ids(db_url, parsed_ids, args.staleness_hours)
               if stale_ids:
                   print(f"[WARNING] {len(stale_ids)} IDs have stale bars: {stale_ids}")
                   if not args.bars:
                       print("[INFO] Consider running with --all to refresh bars first")
                   # Filter to fresh IDs only
                   ids_for_emas = fresh_ids
               else:
                   ids_for_emas = parsed_ids
           else:
               ids_for_emas = parsed_ids

           ema_result = run_ema_refreshers(args, ids=ids_for_emas)
           results.append(("emas", ema_result))

       # Print combined summary
       print_combined_summary(results)
   ```

4. **run_bar_builders() function**:
   ```python
   def run_bar_builders(args) -> ComponentResult:
       """Run bar orchestrator via subprocess."""
       script_dir = Path(__file__).parent / "bars"
       cmd = [sys.executable, str(script_dir / "run_all_bar_builders.py")]
       cmd.extend(["--ids", args.ids])
       cmd.extend(["--db-url", args.db_url])
       if args.dry_run:
           cmd.append("--dry-run")
       if args.verbose:
           cmd.append("--verbose")
       if args.continue_on_error:
           cmd.append("--continue-on-error")
       # ... execute and return result
   ```

5. **run_ema_refreshers() function**:
   ```python
   def run_ema_refreshers(args, ids: list[int] | None = None) -> ComponentResult:
       """Run EMA orchestrator via subprocess."""
       script_dir = Path(__file__).parent / "emas"
       cmd = [sys.executable, str(script_dir / "run_all_ema_refreshes.py")]
       # Format IDs
       ids_str = ",".join(str(i) for i in ids) if ids else args.ids
       cmd.extend(["--ids", ids_str])
       if args.dry_run:
           cmd.append("--dry-run")
       if args.verbose:
           cmd.append("--verbose")
       # ... execute and return result
   ```

6. **Combined summary**:
   ```python
   def print_combined_summary(results: list[tuple[str, ComponentResult]]):
       print(f"\n{'='*70}")
       print("DAILY REFRESH SUMMARY")
       print(f"{'='*70}")
       # Show bars result
       # Show EMAs result
       # Total time, overall status
   ```
  </action>
  <verify>
Run `python src/ta_lab2/scripts/run_daily_refresh.py --help` and verify CLI options appear.
Run `python src/ta_lab2/scripts/run_daily_refresh.py --dry-run --all --ids 1` and verify it shows bar + EMA commands.
Run `python src/ta_lab2/scripts/run_daily_refresh.py --dry-run --bars --ids 1` and verify it shows only bar commands.
  </verify>
  <done>Unified daily refresh script exists with --bars, --emas, --all flags and state-based coordination</done>
</task>

</tasks>

<verification>
1. `python src/ta_lab2/scripts/run_daily_refresh.py` without flags shows error requiring --bars, --emas, or --all
2. `python src/ta_lab2/scripts/run_daily_refresh.py --dry-run --all --ids 1` shows both bar and EMA commands
3. `python src/ta_lab2/scripts/run_daily_refresh.py --dry-run --emas --ids 1` shows EMA commands only
4. `python -c "from ta_lab2.scripts.refresh_utils import check_bar_freshness; print('OK')"` works
</verification>

<success_criteria>
- One command (`run_daily_refresh.py --all`) handles complete daily refresh
- Bars and EMAs can be run separately with --bars or --emas
- State-based bar freshness check runs before EMAs (unless --skip-stale-check)
- Stale IDs are logged and skipped for EMA refresh
- Combined summary shows results from both components
</success_criteria>

<output>
After completion, create `.planning/phases/23-reliable-incremental-refresh/23-02-SUMMARY.md`
</output>
