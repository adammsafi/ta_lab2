---
phase: 23-reliable-incremental-refresh
plan: 04
type: execute
wave: 3
depends_on: ["23-01", "23-02", "23-03"]
files_modified:
  - docs/operations/DAILY_REFRESH.md
  - docs/operations/STATE_MANAGEMENT.md
autonomous: true

must_haves:
  truths:
    - "User can understand state management patterns from documentation"
    - "User knows how to run daily refresh, troubleshoot, and interpret logs"
    - "State table schemas and watermark patterns are documented"
  artifacts:
    - path: "docs/operations/DAILY_REFRESH.md"
      provides: "Operational guide for daily refresh workflow"
      min_lines: 100
    - path: "docs/operations/STATE_MANAGEMENT.md"
      provides: "State management patterns documentation"
      min_lines: 80
  key_links:
    - from: "DAILY_REFRESH.md"
      to: "run_daily_refresh.py"
      via: "usage examples"
      pattern: "run_daily_refresh"
    - from: "STATE_MANAGEMENT.md"
      to: "cmc_price_bars_1d_state"
      via: "schema documentation"
      pattern: "last_src_ts|daily_min_seen"
---

<objective>
Document state management patterns and operational procedures

Purpose: Users need to understand how state management works across bar and EMA scripts, and how to operate the daily refresh workflow effectively. This closes STAT-01 (document patterns) and provides operational reference.

Output: Two documentation files covering state management patterns and daily refresh operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Source files to reference for accurate documentation
@sql/ddl/create_cmc_price_bars_1d_state.sql
@sql/ddl/create_cmc_ema_refresh_state.sql
@src/ta_lab2/scripts/run_daily_refresh.py
@src/ta_lab2/scripts/bars/run_all_bar_builders.py
@src/ta_lab2/scripts/emas/run_all_ema_refreshes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Document state management patterns</name>
  <files>docs/operations/STATE_MANAGEMENT.md</files>
  <action>
Create `docs/operations/STATE_MANAGEMENT.md` documenting state management patterns:

```markdown
# State Management Patterns

This document describes how state is tracked across bar and EMA refresh scripts to enable reliable incremental updates.

## Overview

State management uses **watermarking** - tracking the last successfully processed timestamp to determine where to resume. This pattern:
- Enables incremental refresh (process only new data)
- Supports resume after failures
- Detects backfills that require full rebuilds

## State Tables

### cmc_price_bars_1d_state

Tracks state for 1D bar builder:

| Column | Type | Purpose |
|--------|------|---------|
| id | integer | Asset ID (FK to dim_assets) |
| last_src_ts | timestamptz | Latest source timestamp processed |
| daily_min_seen | timestamptz | Earliest timestamp ever seen (backfill detection) |
| last_run_ts | timestamptz | When script last ran |
| last_upserted | integer | Bars upserted in last run |
| last_repaired_timehigh | integer | Time_high repairs in last run |
| last_repaired_timelow | integer | Time_low repairs in last run |
| last_rejected | integer | Rows rejected in last run |

**Watermark pattern:**
- On each run, query `WHERE src.timestamp > state.last_src_ts`
- After successful upsert, update `last_src_ts = MAX(processed timestamps)`

**Backfill detection:**
- Compare current `MIN(src.timestamp)` to `daily_min_seen`
- If MIN < daily_min_seen, historical data was backfilled
- Full rebuild required to maintain bar_seq integrity

### cmc_ema_refresh_state

Tracks state for EMA refreshers:

| Column | Type | Purpose |
|--------|------|---------|
| id | integer | Asset ID |
| last_load_ts_daily | timestamptz | Last processed for daily EMAs |
| last_load_ts_multi | timestamptz | Last processed for multi-TF EMAs |
| last_load_ts_cal | timestamptz | Last processed for calendar EMAs |

## Watermark Patterns

### Standard Incremental Refresh

```python
# 1. Read watermark
last_ts = get_state_watermark(id)

# 2. Query new data
new_data = query_source(where timestamp > last_ts)

# 3. Process and write
write_to_target(new_data)

# 4. Update watermark
update_state_watermark(id, max(new_data.timestamp))
```

### Lookback Window (Late-Arriving Data)

Some scripts use a lookback window to handle late-arriving data:

```python
# Instead of strict watermark
cutoff = last_ts - timedelta(days=lookback_days)
new_data = query_source(where timestamp > cutoff)

# UPSERT handles duplicates
upsert_to_target(new_data)
```

### Full Rebuild Trigger

Full rebuild is triggered when:
1. No state exists for an ID (first run)
2. `--full-rebuild` flag is passed
3. Backfill detected (MIN timestamp < daily_min_seen)
4. State is corrupted or inconsistent

## State-Based Coordination

The unified refresh script checks bar freshness before running EMAs:

```sql
-- Check bar freshness
SELECT id, last_src_ts,
       EXTRACT(EPOCH FROM (now() - last_src_ts)) / 3600 as staleness_hours
FROM cmc_price_bars_1d_state
WHERE staleness_hours > threshold;
```

If bars are stale, EMAs are skipped for those IDs (or user is warned).

## Consistency Guarantees

1. **Atomic updates:** State is updated in same transaction as data writes
2. **Idempotent writes:** UPSERT ensures reruns produce same result
3. **Ordering preserved:** bar_seq maintains chronological order
4. **Quality flags:** is_missing_days, is_partial_end track data quality

## Troubleshooting

### Reset state for an ID
```sql
DELETE FROM cmc_price_bars_1d_state WHERE id = 825;
-- Next run will do full history for ID 825
```

### Force full rebuild
```bash
python run_daily_refresh.py --all --full-rebuild --ids 825
```

### Check state freshness
```sql
SELECT id, last_src_ts, now() - last_src_ts as age
FROM cmc_price_bars_1d_state
ORDER BY age DESC;
```
```
  </action>
  <verify>
Verify file exists and has content: `wc -l docs/operations/STATE_MANAGEMENT.md` should show 80+ lines.
  </verify>
  <done>State management patterns documented with schemas, watermark patterns, and troubleshooting</done>
</task>

<task type="auto">
  <name>Task 2: Document daily refresh operations</name>
  <files>docs/operations/DAILY_REFRESH.md</files>
  <action>
Create `docs/operations/DAILY_REFRESH.md` as operational guide:

```markdown
# Daily Refresh Operations Guide

This guide covers how to run and troubleshoot the daily data refresh workflow.

## Quick Start

```bash
# Full daily refresh (bars + EMAs)
make daily-refresh

# Or with Python directly
python src/ta_lab2/scripts/run_daily_refresh.py --all --verbose
```

## Entry Points

### Unified Script (Recommended)

`run_daily_refresh.py` - Single command for complete refresh

```bash
# Full refresh
python src/ta_lab2/scripts/run_daily_refresh.py --all

# Bars only
python src/ta_lab2/scripts/run_daily_refresh.py --bars

# EMAs only (checks bar freshness first)
python src/ta_lab2/scripts/run_daily_refresh.py --emas

# Specific IDs
python src/ta_lab2/scripts/run_daily_refresh.py --all --ids 1,52,825
```

**Flags:**
- `--all` - Run bars then EMAs
- `--bars` - Run bar builders only
- `--emas` - Run EMA refreshers only
- `--ids X,Y,Z` - Specific asset IDs
- `--dry-run` - Show commands without executing
- `--verbose` - Show detailed output
- `--continue-on-error` - Don't stop on failures
- `--skip-stale-check` - Skip bar freshness check for EMAs
- `--validate` - Run validation after refresh
- `--alert-on-error` - Send Telegram alerts on critical errors

### Separate Scripts

For fine-grained control:

```bash
# Bar builders
python src/ta_lab2/scripts/bars/run_all_bar_builders.py --ids all

# EMA refreshers
python src/ta_lab2/scripts/emas/run_all_ema_refreshes.py
```

### Makefile Targets

```bash
make bars              # Run all bar builders
make emas              # Run all EMA refreshers
make daily-refresh     # Full bars + EMAs with logging
make dry-run           # Show what would execute
make validate          # Run validation only
make clean-logs        # Remove logs older than 30 days
```

## Execution Order

### Bars (run_all_bar_builders.py)
1. 1d - Canonical daily bars
2. multi_tf - Multi-timeframe rolling bars (7d, 14d, ...)
3. cal_iso - Calendar-aligned ISO (week, month, quarter, year)
4. cal_us - Calendar-aligned US (Sunday week start)
5. cal_anchor_iso - Calendar-anchored with partial snapshots (ISO)
6. cal_anchor_us - Calendar-anchored with partial snapshots (US)

### EMAs (run_all_ema_refreshes.py)
1. multi_tf - Multi-TF EMAs (tf_day based)
2. cal - Calendar-aligned EMAs (us/iso)
3. cal_anchor - Calendar-anchored EMAs
4. v2 - Daily-space EMAs (v2)

## Logs and Monitoring

### Log Files

Logs are written to `.logs/refresh-YYYY-MM-DD.log`:

```bash
# View today's log
cat .logs/refresh-$(date +%Y-%m-%d).log

# Follow log in real-time
tail -f .logs/refresh-$(date +%Y-%m-%d).log
```

### Summary Metrics

Each run produces a summary with:
- **Counts:** Bars written, EMAs written, rows processed
- **Timing:** Duration per component
- **Quality:** Gaps flagged, repairs logged, rejects counted
- **Status:** Success/failure per builder/refresher

### Telegram Alerts

Configure alerts for critical errors:

```bash
export TELEGRAM_BOT_TOKEN="your-token"
export TELEGRAM_CHAT_ID="your-chat-id"

python run_daily_refresh.py --all --alert-on-error
```

Alerts fire on:
- Database connection errors
- OHLC corruption above threshold
- Validation failures (gaps, duplicates)

## Troubleshooting

### Common Issues

**"Bars stale for IDs: [825]"**
- Bar refresh failed or hasn't run for these IDs
- Solution: Run `--all` to refresh bars first, or `--skip-stale-check` if intentional

**"Too many database connections"**
- Multiple parallel processes exhausted connection pool
- Solution: Close other DB clients, or increase max_connections

**"Backfill detected for ID X"**
- Historical data was added to source
- Solution: Run with `--full-rebuild --ids X` to rebuild from scratch

### Force Full Rebuild

```bash
# Single ID
python run_daily_refresh.py --all --full-rebuild --ids 825

# All IDs (slow!)
python run_daily_refresh.py --all --full-rebuild
```

### Check State

```sql
-- Bar state
SELECT id, last_src_ts, last_run_ts, last_upserted
FROM cmc_price_bars_1d_state
ORDER BY last_run_ts DESC;

-- EMA state
SELECT id, last_load_ts_multi, last_load_ts_cal
FROM cmc_ema_refresh_state
ORDER BY id;
```

### Reset State for ID

```sql
-- Reset bar state (next run will rebuild)
DELETE FROM cmc_price_bars_1d_state WHERE id = 825;

-- Reset EMA state
DELETE FROM cmc_ema_refresh_state WHERE id = 825;
```

## Cron Setup

For automated daily refresh:

```bash
# crontab -e
# Run at 6 AM UTC daily
0 6 * * * cd /path/to/ta_lab2 && make daily-refresh-validate >> .logs/cron.log 2>&1
```

## See Also

- [STATE_MANAGEMENT.md](STATE_MANAGEMENT.md) - State table schemas and patterns
- [../architecture/BARS_AND_EMAS.md](../architecture/BARS_AND_EMAS.md) - Data flow architecture
```
  </action>
  <verify>
Verify file exists and has content: `wc -l docs/operations/DAILY_REFRESH.md` should show 100+ lines.
  </verify>
  <done>Daily refresh operational guide created with usage, troubleshooting, and cron setup</done>
</task>

</tasks>

<verification>
1. `docs/operations/STATE_MANAGEMENT.md` exists with 80+ lines
2. `docs/operations/DAILY_REFRESH.md` exists with 100+ lines
3. Both documents reference actual scripts and state tables accurately
4. Troubleshooting sections provide actionable guidance
</verification>

<success_criteria>
- State management patterns documented (watermarking, backfill detection, coordination)
- Daily refresh operational guide complete (quick start, flags, troubleshooting, cron)
- Documentation references actual file names and table schemas
- Users can self-serve for common operations and troubleshooting
</success_criteria>

<output>
After completion, create `.planning/phases/23-reliable-incremental-refresh/23-04-SUMMARY.md`
</output>
